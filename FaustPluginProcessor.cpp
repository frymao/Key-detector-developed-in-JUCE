/* ------------------------------------------------------------
name: "octave_sample_code"
Code generated with Faust 2.18.0 (https://faust.grame.fr)
Compilation options: -lang cpp -scal -ftz 0
------------------------------------------------------------ */

#ifndef  __mydsp_H__
#define  __mydsp_H__

/************************************************************************
 FAUST Architecture File
 Copyright (C) 2016 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 
 ************************************************************************
 ************************************************************************/

#include <algorithm>
#include <assert.h>
#include "Ball.h"

#if JUCE_WINDOWS
#define JUCE_CORE_INCLUDE_NATIVE_HEADERS 1
#endif

#include "JuceLibraryCode/JuceHeader.h"

/************************** BEGIN MapUI.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef FAUST_MAPUI_H
#define FAUST_MAPUI_H

#include <vector>
#include <map>
#include <string>

/************************** BEGIN UI.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __UI_H__
#define __UI_H__

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif

/*******************************************************************************
 * UI : Faust DSP User Interface
 * User Interface as expected by the buildUserInterface() method of a DSP.
 * This abstract class contains only the method that the Faust compiler can
 * generate to describe a DSP user interface.
 ******************************************************************************/

struct Soundfile;

template <typename REAL>
class UIReal
{
    
    public:
        
        UIReal() {}
        virtual ~UIReal() {}
        
        // -- widget's layouts
        
        virtual void openTabBox(const char* label) = 0;
        virtual void openHorizontalBox(const char* label) = 0;
        virtual void openVerticalBox(const char* label) = 0;
        virtual void closeBox() = 0;
        
        // -- active widgets
        
        virtual void addButton(const char* label, REAL* zone) = 0;
        virtual void addCheckButton(const char* label, REAL* zone) = 0;
        virtual void addVerticalSlider(const char* label, REAL* zone, REAL init, REAL min, REAL max, REAL step) = 0;
        virtual void addHorizontalSlider(const char* label, REAL* zone, REAL init, REAL min, REAL max, REAL step) = 0;
        virtual void addNumEntry(const char* label, REAL* zone, REAL init, REAL min, REAL max, REAL step) = 0;
        
        // -- passive widgets
        
        virtual void addHorizontalBargraph(const char* label, REAL* zone, REAL min, REAL max) = 0;
        virtual void addVerticalBargraph(const char* label, REAL* zone, REAL min, REAL max) = 0;
        
        // -- soundfiles
        
        virtual void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone) = 0;
        
        // -- metadata declarations
        
        virtual void declare(REAL* zone, const char* key, const char* val) {}
};

class UI : public UIReal<FAUSTFLOAT>
{

    public:

        UI() {}
        virtual ~UI() {}
};

#endif
/**************************  END  UI.h **************************/
/************************** BEGIN PathBuilder.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef FAUST_PATHBUILDER_H
#define FAUST_PATHBUILDER_H

#include <vector>
#include <string>
#include <algorithm>

/*******************************************************************************
 * PathBuilder : Faust User Interface
 * Helper class to build complete hierarchical path for UI items.
 ******************************************************************************/

class PathBuilder
{

    protected:
    
        std::vector<std::string> fControlsLevel;
       
    public:
    
        PathBuilder() {}
        virtual ~PathBuilder() {}
    
        std::string buildPath(const std::string& label) 
        {
            std::string res = "/";
            for (size_t i = 0; i < fControlsLevel.size(); i++) {
                res += fControlsLevel[i];
                res += "/";
            }
            res += label;
            std::replace(res.begin(), res.end(), ' ', '_');
            return res;
        }
    
        void pushLabel(const std::string& label) { fControlsLevel.push_back(label); }
        void popLabel() { fControlsLevel.pop_back(); }
    
};

#endif  // FAUST_PATHBUILDER_H
/**************************  END  PathBuilder.h **************************/

/*******************************************************************************
 * MapUI : Faust User Interface
 * This class creates a map of complete hierarchical path and zones for each UI items.
 ******************************************************************************/

class MapUI : public UI, public PathBuilder
{
    
    protected:
    
        // Complete path map
        std::map<std::string, FAUSTFLOAT*> fPathZoneMap;
    
        // Label zone map
        std::map<std::string, FAUSTFLOAT*> fLabelZoneMap;
    
    public:
        
        MapUI() {};
        virtual ~MapUI() {};
        
        // -- widget's layouts
        void openTabBox(const char* label)
        {
            pushLabel(label);
        }
        void openHorizontalBox(const char* label)
        {
            pushLabel(label);
        }
        void openVerticalBox(const char* label)
        {
            pushLabel(label);
        }
        void closeBox()
        {
            popLabel();
        }
        
        // -- active widgets
        void addButton(const char* label, FAUSTFLOAT* zone)
        {
            fPathZoneMap[buildPath(label)] = zone;
            fLabelZoneMap[label] = zone;
        }
        void addCheckButton(const char* label, FAUSTFLOAT* zone)
        {
            fPathZoneMap[buildPath(label)] = zone;
            fLabelZoneMap[label] = zone;
        }
        void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT fmin, FAUSTFLOAT fmax, FAUSTFLOAT step)
        {
            fPathZoneMap[buildPath(label)] = zone;
            fLabelZoneMap[label] = zone;
        }
        void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT fmin, FAUSTFLOAT fmax, FAUSTFLOAT step)
        {
            fPathZoneMap[buildPath(label)] = zone;
            fLabelZoneMap[label] = zone;
        }
        void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT fmin, FAUSTFLOAT fmax, FAUSTFLOAT step)
        {
            fPathZoneMap[buildPath(label)] = zone;
            fLabelZoneMap[label] = zone;
        }
        
        // -- passive widgets
        void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT fmin, FAUSTFLOAT fmax)
        {
            fPathZoneMap[buildPath(label)] = zone;
            fLabelZoneMap[label] = zone;
        }
        void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT fmin, FAUSTFLOAT fmax)
        {
            fPathZoneMap[buildPath(label)] = zone;
            fLabelZoneMap[label] = zone;
        }
    
        // -- soundfiles
        virtual void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone) {}
        
        // -- metadata declarations
        void declare(FAUSTFLOAT* zone, const char* key, const char* val)
        {}
        
        // set/get
        void setParamValue(const std::string& path, FAUSTFLOAT value)
        {
            if (fPathZoneMap.find(path) != fPathZoneMap.end()) {
                *fPathZoneMap[path] = value;
            } else if (fLabelZoneMap.find(path) != fLabelZoneMap.end()) {
                *fLabelZoneMap[path] = value;
            }
        }
        
        FAUSTFLOAT getParamValue(const std::string& path)
        {
            if (fPathZoneMap.find(path) != fPathZoneMap.end()) {
                return *fPathZoneMap[path];
            } else if (fLabelZoneMap.find(path) != fLabelZoneMap.end()) {
                return *fLabelZoneMap[path];
            } else {
                return FAUSTFLOAT(0);
            }
        }
    
        // map access 
        std::map<std::string, FAUSTFLOAT*>& getMap() { return fPathZoneMap; }
        
        int getParamsCount() { return int(fPathZoneMap.size()); }
        
        std::string getParamAddress(int index)
        { 
            std::map<std::string, FAUSTFLOAT*>::iterator it = fPathZoneMap.begin();
            while (index-- > 0 && it++ != fPathZoneMap.end()) {}
            return (*it).first;
        }
    
        std::string getParamAddress(FAUSTFLOAT* zone)
        {
            std::map<std::string, FAUSTFLOAT*>::iterator it = fPathZoneMap.begin();
            do {
                if ((*it).second == zone) return (*it).first;
            }
            while (it++ != fPathZoneMap.end());
            return "";
        }
    
        static bool endsWith(std::string const& str, std::string const& end)
        {
            size_t l1 = str.length();
            size_t l2 = end.length();
            return (l1 >= l2) && (0 == str.compare(l1 - l2, l2, end));
        }
};


#endif // FAUST_MAPUI_H
/**************************  END  MapUI.h **************************/
/************************** BEGIN dsp-adapter.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __dsp_adapter__
#define __dsp_adapter__

#include <string.h>
#include <iostream>

/************************** BEGIN dsp.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __dsp__
#define __dsp__

#include <string>
#include <vector>

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif

class UI;
struct Meta;

/**
 * DSP memory manager.
 */

struct dsp_memory_manager {
    
    virtual ~dsp_memory_manager() {}
    
    virtual void* allocate(size_t size) = 0;
    virtual void destroy(void* ptr) = 0;
    
};

/**
* Signal processor definition.
*/

class dsp {

    public:

        dsp() {}
        virtual ~dsp() {}

        /* Return instance number of audio inputs */
        virtual int getNumInputs() = 0;
    
        /* Return instance number of audio outputs */
        virtual int getNumOutputs() = 0;
    
        /**
         * Trigger the ui_interface parameter with instance specific calls
         * to 'addBtton', 'addVerticalSlider'... in order to build the UI.
         *
         * @param ui_interface - the user interface builder
         */
        virtual void buildUserInterface(UI* ui_interface) = 0;
    
        /* Returns the sample rate currently used by the instance */
        virtual int getSampleRate() = 0;
    
        /**
         * Global init, calls the following methods:
         * - static class 'classInit': static tables initialization
         * - 'instanceInit': constants and instance state initialization
         *
         * @param sample_rate - the sampling rate in Hertz
         */
        virtual void init(int sample_rate) = 0;

        /**
         * Init instance state
         *
         * @param sample_rate - the sampling rate in Hertz
         */
        virtual void instanceInit(int sample_rate) = 0;

        /**
         * Init instance constant state
         *
         * @param sample_rate - the sampling rate in Hertz
         */
        virtual void instanceConstants(int sample_rate) = 0;
    
        /* Init default control parameters values */
        virtual void instanceResetUserInterface() = 0;
    
        /* Init instance state (delay lines...) */
        virtual void instanceClear() = 0;
 
        /**
         * Return a clone of the instance.
         *
         * @return a copy of the instance on success, otherwise a null pointer.
         */
        virtual dsp* clone() = 0;
    
        /**
         * Trigger the Meta* parameter with instance specific calls to 'declare' (key, value) metadata.
         *
         * @param m - the Meta* meta user
         */
        virtual void metadata(Meta* m) = 0;
    
        /**
         * DSP instance computation, to be called with successive in/out audio buffers.
         *
         * @param count - the number of frames to compute
         * @param inputs - the input audio buffers as an array of non-interleaved FAUSTFLOAT samples (eiher float, double or quad)
         * @param outputs - the output audio buffers as an array of non-interleaved FAUSTFLOAT samples (eiher float, double or quad)
         *
         */
        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) = 0;
    
        /**
         * DSP instance computation: alternative method to be used by subclasses.
         *
         * @param date_usec - the timestamp in microsec given by audio driver.
         * @param count - the number of frames to compute
         * @param inputs - the input audio buffers as an array of non-interleaved FAUSTFLOAT samples (either float, double or quad)
         * @param outputs - the output audio buffers as an array of non-interleaved FAUSTFLOAT samples (either float, double or quad)
         *
         */
        virtual void compute(double /*date_usec*/, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { compute(count, inputs, outputs); }
       
};

/**
 * Generic DSP decorator.
 */

class decorator_dsp : public dsp {

    protected:

        dsp* fDSP;

    public:

        decorator_dsp(dsp* dsp = 0):fDSP(dsp) {}
        virtual ~decorator_dsp() { delete fDSP; }

        virtual int getNumInputs() { return fDSP->getNumInputs(); }
        virtual int getNumOutputs() { return fDSP->getNumOutputs(); }
        virtual void buildUserInterface(UI* ui_interface) { fDSP->buildUserInterface(ui_interface); }
        virtual int getSampleRate() { return fDSP->getSampleRate(); }
        virtual void init(int sample_rate) { fDSP->init(sample_rate); }
        virtual void instanceInit(int sample_rate) { fDSP->instanceInit(sample_rate); }
        virtual void instanceConstants(int sample_rate) { fDSP->instanceConstants(sample_rate); }
        virtual void instanceResetUserInterface() { fDSP->instanceResetUserInterface(); }
        virtual void instanceClear() { fDSP->instanceClear(); }
        virtual decorator_dsp* clone() { return new decorator_dsp(fDSP->clone()); }
        virtual void metadata(Meta* m) { fDSP->metadata(m); }
        // Beware: subclasses usually have to overload the two 'compute' methods
        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { fDSP->compute(count, inputs, outputs); }
        virtual void compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { fDSP->compute(date_usec, count, inputs, outputs); }
    
};

/**
 * DSP factory class.
 */

class dsp_factory {
    
    protected:
    
        // So that to force sub-classes to use deleteDSPFactory(dsp_factory* factory);
        virtual ~dsp_factory() {}
    
    public:
    
        virtual std::string getName() = 0;
        virtual std::string getSHAKey() = 0;
        virtual std::string getDSPCode() = 0;
        virtual std::string getCompileOptions() = 0;
        virtual std::vector<std::string> getLibraryList() = 0;
        virtual std::vector<std::string> getIncludePathnames() = 0;
    
        virtual dsp* createDSPInstance() = 0;
    
        virtual void setMemoryManager(dsp_memory_manager* manager) = 0;
        virtual dsp_memory_manager* getMemoryManager() = 0;
    
};

/**
 * On Intel set FZ (Flush to Zero) and DAZ (Denormals Are Zero)
 * flags to avoid costly denormals.
 */

#ifdef __SSE__
    #include <xmmintrin.h>
    #ifdef __SSE2__
        #define AVOIDDENORMALS _mm_setcsr(_mm_getcsr() | 0x8040)
    #else
        #define AVOIDDENORMALS _mm_setcsr(_mm_getcsr() | 0x8000)
    #endif
#else
    #define AVOIDDENORMALS
#endif

#endif
/**************************  END  dsp.h **************************/

// Adapts a DSP for a different number of inputs/outputs

class dsp_adapter : public decorator_dsp {
    
    private:
        
        FAUSTFLOAT** fAdaptedInputs;
        FAUSTFLOAT** fAdaptedOutputs;
        int fHardwareInputs;
        int fHardwareOutputs;
        
        void adaptBuffers(FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            for (int i = 0; i < fHardwareInputs; i++) {
                fAdaptedInputs[i] = inputs[i];
            }
            for (int i = 0; i < fHardwareOutputs; i++) {
                fAdaptedOutputs[i] = outputs[i];
            }
        }
        
    public:
        
        dsp_adapter(dsp* dsp, int hardware_inputs, int hardware_outputs, int buffer_size):decorator_dsp(dsp)
        {
            fHardwareInputs = hardware_inputs;
            fHardwareOutputs = hardware_outputs;
             
            fAdaptedInputs = new FAUSTFLOAT*[dsp->getNumInputs()];
            for (int i = 0; i < dsp->getNumInputs() - fHardwareInputs; i++) {
                fAdaptedInputs[i + fHardwareInputs] = new FAUSTFLOAT[buffer_size];
                memset(fAdaptedInputs[i + fHardwareInputs], 0, sizeof(FAUSTFLOAT) * buffer_size);
            }
            
            fAdaptedOutputs = new FAUSTFLOAT*[dsp->getNumOutputs()];
            for (int i = 0; i < dsp->getNumOutputs() - fHardwareOutputs; i++) {
                fAdaptedOutputs[i + fHardwareOutputs] = new FAUSTFLOAT[buffer_size];
                memset(fAdaptedOutputs[i + fHardwareOutputs], 0, sizeof(FAUSTFLOAT) * buffer_size);
            }
        }
        
        virtual ~dsp_adapter()
        {
            for (int i = 0; i < fDSP->getNumInputs() - fHardwareInputs; i++) {
                delete [] fAdaptedInputs[i + fHardwareInputs];
            }
            delete [] fAdaptedInputs;
            
            for (int i = 0; i < fDSP->getNumOutputs() - fHardwareOutputs; i++) {
                delete [] fAdaptedOutputs[i + fHardwareOutputs];
            }
            delete [] fAdaptedOutputs;
        }
    
        virtual int getNumInputs() { return fHardwareInputs; }
        virtual int getNumOutputs() { return fHardwareOutputs; }
    
        virtual void compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            adaptBuffers(inputs, outputs);
            fDSP->compute(date_usec, count, fAdaptedInputs, fAdaptedOutputs);
        }
        
        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            adaptBuffers(inputs, outputs);
            fDSP->compute(count, fAdaptedInputs, fAdaptedOutputs);
        }
};

// Adapts a DSP for a different sample size

template <typename TYPE_INT, typename TYPE_EXT>
class dsp_sample_adapter : public decorator_dsp {
    
    protected:
    
        TYPE_INT** fAdaptedInputs;
        TYPE_INT** fAdaptedOutputs;
    
        void adaptInputBuffers(int count, FAUSTFLOAT** inputs)
        {
            for (int chan = 0; chan < fDSP->getNumInputs(); chan++) {
                for (int frame = 0; frame < count; frame++) {
                    fAdaptedInputs[chan][frame] = TYPE_INT(reinterpret_cast<TYPE_EXT**>(inputs)[chan][frame]);
                }
            }
        }
    
        void adaptOutputsBuffers(int count, FAUSTFLOAT** outputs)
        {
            for (int chan = 0; chan < fDSP->getNumOutputs(); chan++) {
                for (int frame = 0; frame < count; frame++) {
                    reinterpret_cast<TYPE_EXT**>(outputs)[chan][frame] = TYPE_EXT(fAdaptedOutputs[chan][frame]);
                }
            }
        }
    
    public:
    
        dsp_sample_adapter(dsp* dsp):decorator_dsp(dsp)
        {
            fAdaptedInputs = new TYPE_INT*[dsp->getNumInputs()];
            for (int i = 0; i < dsp->getNumInputs(); i++) {
                fAdaptedInputs[i] = new TYPE_INT[4096];
            }
            
            fAdaptedOutputs = new TYPE_INT*[dsp->getNumOutputs()];
            for (int i = 0; i < dsp->getNumOutputs(); i++) {
                fAdaptedOutputs[i] = new TYPE_INT[4096];
            }
        }
    
        virtual ~dsp_sample_adapter()
        {
            for (int i = 0; i < fDSP->getNumInputs(); i++) {
                delete [] fAdaptedInputs[i];
            }
            delete [] fAdaptedInputs;
            
            for (int i = 0; i < fDSP->getNumOutputs(); i++) {
                delete [] fAdaptedOutputs[i];
            }
            delete [] fAdaptedOutputs;
        }
    
        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            adaptInputBuffers(count, inputs);
            // DSP base class uses FAUSTFLOAT** type, so reinterpret_cast has to be used even if the real DSP uses TYPE_INT
            fDSP->compute(count, reinterpret_cast<FAUSTFLOAT**>(fAdaptedInputs), reinterpret_cast<FAUSTFLOAT**>(fAdaptedOutputs));
            adaptOutputsBuffers(count, outputs);
        }
    
        virtual void compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            adaptInputBuffers(count, inputs);
            // DSP base class uses FAUSTFLOAT** type, so reinterpret_cast has to be used even if the real DSP uses TYPE_INT
            fDSP->compute(date_usec, count, reinterpret_cast<FAUSTFLOAT**>(fAdaptedInputs), reinterpret_cast<FAUSTFLOAT**>(fAdaptedOutputs));
            adaptOutputsBuffers(count, outputs);
       }
};

#endif
/**************************  END  dsp-adapter.h **************************/
/************************** BEGIN MidiUI.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef FAUST_MIDIUI_H
#define FAUST_MIDIUI_H

#include <vector>
#include <string>
#include <utility>
#include <iostream>
#include <cstdlib>
#include <cmath>

/************************** BEGIN meta.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __meta__
#define __meta__

struct Meta
{
    virtual ~Meta() {};
    virtual void declare(const char* key, const char* value) = 0;
    
};

#endif
/**************************  END  meta.h **************************/
/************************** BEGIN GUI.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/
 
#ifndef __GUI_H__
#define __GUI_H__

#include <list>
#include <map>
#include <vector>
#include <iostream>

#ifdef _WIN32
# pragma warning (disable: 4100)
#else
# pragma GCC diagnostic ignored "-Wunused-parameter"
#endif

/************************** BEGIN ring-buffer.h **************************/
/*
  Copyright (C) 2000 Paul Davis
  Copyright (C) 2003 Rohan Drape
  Copyright (C) 2016 GRAME (renaming for internal use)

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published by
  the Free Software Foundation; either version 2.1 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  ISO/POSIX C version of Paul Davis's lock free ringbuffer C++ code.
  This is safe for the case of one read thread and one write thread.
*/

#ifndef __ring_buffer__
#define __ring_buffer__

#include <stdlib.h>
#include <string.h>

#ifdef WIN32
# pragma warning (disable: 4334)
#else
# pragma GCC diagnostic ignored "-Wunused-function"
#endif

typedef struct {
    char *buf;
    size_t len;
}
ringbuffer_data_t;

typedef struct {
    char *buf;
    volatile size_t write_ptr;
    volatile size_t read_ptr;
    size_t	size;
    size_t	size_mask;
    int	mlocked;
}
ringbuffer_t;

static ringbuffer_t *ringbuffer_create(size_t sz);
static void ringbuffer_free(ringbuffer_t *rb);
static void ringbuffer_get_read_vector(const ringbuffer_t *rb,
                                         ringbuffer_data_t *vec);
static void ringbuffer_get_write_vector(const ringbuffer_t *rb,
                                          ringbuffer_data_t *vec);
static size_t ringbuffer_read(ringbuffer_t *rb, char *dest, size_t cnt);
static size_t ringbuffer_peek(ringbuffer_t *rb, char *dest, size_t cnt);
static void ringbuffer_read_advance(ringbuffer_t *rb, size_t cnt);
static size_t ringbuffer_read_space(const ringbuffer_t *rb);
static int ringbuffer_mlock(ringbuffer_t *rb);
static void ringbuffer_reset(ringbuffer_t *rb);
static void ringbuffer_reset_size (ringbuffer_t * rb, size_t sz);
static size_t ringbuffer_write(ringbuffer_t *rb, const char *src,
                                 size_t cnt);
static void ringbuffer_write_advance(ringbuffer_t *rb, size_t cnt);
static size_t ringbuffer_write_space(const ringbuffer_t *rb);

/* Create a new ringbuffer to hold at least `sz' bytes of data. The
   actual buffer size is rounded up to the next power of two. */

static ringbuffer_t *
ringbuffer_create (size_t sz)
{
	size_t power_of_two;
	ringbuffer_t *rb;

	if ((rb = (ringbuffer_t *) malloc (sizeof (ringbuffer_t))) == NULL) {
		return NULL;
	}

	for (power_of_two = 1u; 1u << power_of_two < sz; power_of_two++);

	rb->size = 1u << power_of_two;
	rb->size_mask = rb->size;
	rb->size_mask -= 1;
	rb->write_ptr = 0;
	rb->read_ptr = 0;
	if ((rb->buf = (char *) malloc (rb->size)) == NULL) {
		free (rb);
		return NULL;
	}
	rb->mlocked = 0;

	return rb;
}

/* Free all data associated with the ringbuffer `rb'. */

static void
ringbuffer_free (ringbuffer_t * rb)
{
#ifdef USE_MLOCK
	if (rb->mlocked) {
		munlock (rb->buf, rb->size);
	}
#endif /* USE_MLOCK */
	free (rb->buf);
	free (rb);
}

/* Lock the data block of `rb' using the system call 'mlock'.  */

static int
ringbuffer_mlock (ringbuffer_t * rb)
{
#ifdef USE_MLOCK
	if (mlock (rb->buf, rb->size)) {
		return -1;
	}
#endif /* USE_MLOCK */
	rb->mlocked = 1;
	return 0;
}

/* Reset the read and write pointers to zero. This is not thread
   safe. */

static void
ringbuffer_reset (ringbuffer_t * rb)
{
	rb->read_ptr = 0;
	rb->write_ptr = 0;
    memset(rb->buf, 0, rb->size);
}

/* Reset the read and write pointers to zero. This is not thread
   safe. */

static void
ringbuffer_reset_size (ringbuffer_t * rb, size_t sz)
{
    rb->size = sz;
    rb->size_mask = rb->size;
    rb->size_mask -= 1;
    rb->read_ptr = 0;
    rb->write_ptr = 0;
}

/* Return the number of bytes available for reading. This is the
   number of bytes in front of the read pointer and behind the write
   pointer.  */

static size_t
ringbuffer_read_space (const ringbuffer_t * rb)
{
	size_t w, r;

	w = rb->write_ptr;
	r = rb->read_ptr;

	if (w > r) {
		return w - r;
	} else {
		return (w - r + rb->size) & rb->size_mask;
	}
}

/* Return the number of bytes available for writing. This is the
   number of bytes in front of the write pointer and behind the read
   pointer.  */

static size_t
ringbuffer_write_space (const ringbuffer_t * rb)
{
	size_t w, r;

	w = rb->write_ptr;
	r = rb->read_ptr;

	if (w > r) {
		return ((r - w + rb->size) & rb->size_mask) - 1;
	} else if (w < r) {
		return (r - w) - 1;
	} else {
		return rb->size - 1;
	}
}

/* The copying data reader. Copy at most `cnt' bytes from `rb' to
   `dest'.  Returns the actual number of bytes copied. */

static size_t
ringbuffer_read (ringbuffer_t * rb, char *dest, size_t cnt)
{
	size_t free_cnt;
	size_t cnt2;
	size_t to_read;
	size_t n1, n2;

	if ((free_cnt = ringbuffer_read_space (rb)) == 0) {
		return 0;
	}

	to_read = cnt > free_cnt ? free_cnt : cnt;

	cnt2 = rb->read_ptr + to_read;

	if (cnt2 > rb->size) {
		n1 = rb->size - rb->read_ptr;
		n2 = cnt2 & rb->size_mask;
	} else {
		n1 = to_read;
		n2 = 0;
	}

	memcpy (dest, &(rb->buf[rb->read_ptr]), n1);
	rb->read_ptr = (rb->read_ptr + n1) & rb->size_mask;

	if (n2) {
		memcpy (dest + n1, &(rb->buf[rb->read_ptr]), n2);
		rb->read_ptr = (rb->read_ptr + n2) & rb->size_mask;
	}

	return to_read;
}

/* The copying data reader w/o read pointer advance. Copy at most
   `cnt' bytes from `rb' to `dest'.  Returns the actual number of bytes
   copied. */

static size_t
ringbuffer_peek (ringbuffer_t * rb, char *dest, size_t cnt)
{
	size_t free_cnt;
	size_t cnt2;
	size_t to_read;
	size_t n1, n2;
	size_t tmp_read_ptr;

	tmp_read_ptr = rb->read_ptr;

	if ((free_cnt = ringbuffer_read_space (rb)) == 0) {
		return 0;
	}

	to_read = cnt > free_cnt ? free_cnt : cnt;

	cnt2 = tmp_read_ptr + to_read;

	if (cnt2 > rb->size) {
		n1 = rb->size - tmp_read_ptr;
		n2 = cnt2 & rb->size_mask;
	} else {
		n1 = to_read;
		n2 = 0;
	}

	memcpy (dest, &(rb->buf[tmp_read_ptr]), n1);
	tmp_read_ptr = (tmp_read_ptr + n1) & rb->size_mask;

	if (n2) {
		memcpy (dest + n1, &(rb->buf[tmp_read_ptr]), n2);
	}

	return to_read;
}

/* The copying data writer. Copy at most `cnt' bytes to `rb' from
   `src'.  Returns the actual number of bytes copied. */

static size_t
ringbuffer_write (ringbuffer_t * rb, const char *src, size_t cnt)
{
	size_t free_cnt;
	size_t cnt2;
	size_t to_write;
	size_t n1, n2;

	if ((free_cnt = ringbuffer_write_space (rb)) == 0) {
		return 0;
	}

	to_write = cnt > free_cnt ? free_cnt : cnt;

	cnt2 = rb->write_ptr + to_write;

	if (cnt2 > rb->size) {
		n1 = rb->size - rb->write_ptr;
		n2 = cnt2 & rb->size_mask;
	} else {
		n1 = to_write;
		n2 = 0;
	}

	memcpy (&(rb->buf[rb->write_ptr]), src, n1);
	rb->write_ptr = (rb->write_ptr + n1) & rb->size_mask;

	if (n2) {
		memcpy (&(rb->buf[rb->write_ptr]), src + n1, n2);
		rb->write_ptr = (rb->write_ptr + n2) & rb->size_mask;
	}

	return to_write;
}

/* Advance the read pointer `cnt' places. */

static void
ringbuffer_read_advance (ringbuffer_t * rb, size_t cnt)
{
	size_t tmp = (rb->read_ptr + cnt) & rb->size_mask;
	rb->read_ptr = tmp;
}

/* Advance the write pointer `cnt' places. */

static void
ringbuffer_write_advance (ringbuffer_t * rb, size_t cnt)
{
	size_t tmp = (rb->write_ptr + cnt) & rb->size_mask;
	rb->write_ptr = tmp;
}

/* The non-copying data reader. `vec' is an array of two places. Set
   the values at `vec' to hold the current readable data at `rb'. If
   the readable data is in one segment the second segment has zero
   length. */

static void
ringbuffer_get_read_vector (const ringbuffer_t * rb,
				 ringbuffer_data_t * vec)
{
	size_t free_cnt;
	size_t cnt2;
	size_t w, r;

	w = rb->write_ptr;
	r = rb->read_ptr;

	if (w > r) {
		free_cnt = w - r;
	} else {
		free_cnt = (w - r + rb->size) & rb->size_mask;
	}

	cnt2 = r + free_cnt;

	if (cnt2 > rb->size) {

		/* Two part vector: the rest of the buffer after the current write
		   ptr, plus some from the start of the buffer. */

		vec[0].buf = &(rb->buf[r]);
		vec[0].len = rb->size - r;
		vec[1].buf = rb->buf;
		vec[1].len = cnt2 & rb->size_mask;

	} else {

		/* Single part vector: just the rest of the buffer */

		vec[0].buf = &(rb->buf[r]);
		vec[0].len = free_cnt;
		vec[1].len = 0;
	}
}

/* The non-copying data writer. `vec' is an array of two places. Set
   the values at `vec' to hold the current writeable data at `rb'. If
   the writeable data is in one segment the second segment has zero
   length. */

static void
ringbuffer_get_write_vector (const ringbuffer_t * rb,
				  ringbuffer_data_t * vec)
{
	size_t free_cnt;
	size_t cnt2;
	size_t w, r;

	w = rb->write_ptr;
	r = rb->read_ptr;

	if (w > r) {
		free_cnt = ((r - w + rb->size) & rb->size_mask) - 1;
	} else if (w < r) {
		free_cnt = (r - w) - 1;
	} else {
		free_cnt = rb->size - 1;
	}

	cnt2 = w + free_cnt;

	if (cnt2 > rb->size) {

		/* Two part vector: the rest of the buffer after the current write
		   ptr, plus some from the start of the buffer. */

		vec[0].buf = &(rb->buf[w]);
		vec[0].len = rb->size - w;
		vec[1].buf = rb->buf;
		vec[1].len = cnt2 & rb->size_mask;
	} else {
		vec[0].buf = &(rb->buf[w]);
		vec[0].len = free_cnt;
		vec[1].len = 0;
	}
}

#endif // __ring_buffer__
/**************************  END  ring-buffer.h **************************/

/*******************************************************************************
 * GUI : Abstract Graphic User Interface
 * Provides additional mechanisms to synchronize widgets and zones. Widgets
 * should both reflect the value of a zone and allow to change this value.
 ******************************************************************************/

class uiItem;
class GUI;
struct clist;

typedef void (*uiCallback)(FAUSTFLOAT val, void* data);

struct uiItemBase
{
    
    uiItemBase(GUI* ui, FAUSTFLOAT* zone) {}
    
    virtual ~uiItemBase()
    {}
    
    virtual void modifyZone(FAUSTFLOAT v) = 0;
    virtual void modifyZone(double date, FAUSTFLOAT v) {}
    virtual double cache() = 0;
    virtual void reflectZone() = 0;
};


static void deleteClist(clist* cl);

struct clist : public std::list<uiItemBase*>
{
    
    virtual ~clist()
    {
        deleteClist(this);
    }
        
};

static void createUiCallbackItem(GUI* ui, FAUSTFLOAT* zone, uiCallback foo, void* data);

typedef std::map<FAUSTFLOAT*, clist*> zmap;

typedef std::map<FAUSTFLOAT*, ringbuffer_t*> ztimedmap;

class GUI : public UI
{
		
    private:
     
        static std::list<GUI*> fGuiList;
        zmap fZoneMap;
        bool fStopped;
        
     public:
            
        GUI():fStopped(false)
        {	
            fGuiList.push_back(this);
        }
        
        virtual ~GUI() 
        {   
            // delete all items
            zmap::iterator it;
            for (it = fZoneMap.begin(); it != fZoneMap.end(); it++) {
                delete (*it).second;
            }
            // suppress 'this' in static fGuiList
            fGuiList.remove(this);
        }

        // -- registerZone(z,c) : zone management
        
        void registerZone(FAUSTFLOAT* z, uiItemBase* c)
        {
            if (fZoneMap.find(z) == fZoneMap.end()) fZoneMap[z] = new clist();
            fZoneMap[z]->push_back(c);
        }
 
        void updateAllZones()
        {
            for (zmap::iterator m = fZoneMap.begin(); m != fZoneMap.end(); m++) {
                FAUSTFLOAT* z = m->first;
                clist* l = m->second;
                if (z) {
                    FAUSTFLOAT v = *z;
                    for (clist::iterator c = l->begin(); c != l->end(); c++) {
                        if ((*c)->cache() != v) (*c)->reflectZone();
                    }
                }
            }
        }
        
        void updateZone(FAUSTFLOAT* z)
        {
            FAUSTFLOAT v = *z;
            clist* l = fZoneMap[z];
            for (clist::iterator c = l->begin(); c != l->end(); c++) {
                if ((*c)->cache() != v) (*c)->reflectZone();
            }
        }
    
        static void updateAllGuis()
        {
            std::list<GUI*>::iterator g;
            for (g = fGuiList.begin(); g != fGuiList.end(); g++) {
                (*g)->updateAllZones();
            }
        }
    
        void addCallback(FAUSTFLOAT* zone, uiCallback foo, void* data)
        {
            createUiCallbackItem(this, zone, foo, data);
        }

        virtual void show() {};	
        virtual bool run() { return false; };

        static void runAllGuis() {
            std::list<GUI*>::iterator g;
            for (g = fGuiList.begin(); g != fGuiList.end(); g++) {
                (*g)->run();
            }
        }
    
        virtual void stop() { fStopped = true; }
        bool stopped() { return fStopped; }
    
        // -- widget's layouts
        
        virtual void openTabBox(const char* label) {};
        virtual void openHorizontalBox(const char* label) {}
        virtual void openVerticalBox(const char* label) {}
        virtual void closeBox() {}
        
        // -- active widgets
        
        virtual void addButton(const char* label, FAUSTFLOAT* zone) {}
        virtual void addCheckButton(const char* label, FAUSTFLOAT* zone) {}
        virtual void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
        virtual void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
        virtual void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
    
        // -- passive widgets
        
        virtual void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) {}
        virtual void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) {}
    
        // -- soundfiles
    
        virtual void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone) {}
    
        // -- metadata declarations

        virtual void declare(FAUSTFLOAT*, const char*, const char*) {}
    
        // Static global for timed zones, shared between all UI that will set timed values
        static ztimedmap gTimedZoneMap;

};

/**
 * User Interface Item: abstract definition
 */

template <typename REAL>
class uiTypedItem : public uiItemBase
{
    protected:
        
        GUI* fGUI;
        REAL* fZone;
        REAL fCache;
        
        uiTypedItem(GUI* ui, REAL* zone):uiItemBase(ui, static_cast<FAUSTFLOAT*>(zone)),
        fGUI(ui), fZone(zone), fCache(REAL(-123456.654321))
        {
            ui->registerZone(zone, this);
        }
        
    public:
        
        virtual ~uiTypedItem()
        {}
    
        void modifyZone(REAL v)
        {
            fCache = v;
            if (*fZone != v) {
                *fZone = v;
                fGUI->updateZone(fZone);
            }
        }
    
        double cache() { return fCache; }
    
};

class uiItem : public uiTypedItem<FAUSTFLOAT> {
    
    protected:
    
        uiItem(GUI* ui, FAUSTFLOAT* zone):uiTypedItem<FAUSTFLOAT>(ui, zone)
        {}

    public:

        virtual ~uiItem() 
        {}

		void modifyZone(FAUSTFLOAT v)
		{
			fCache = v;
			if (*fZone != v) {
				*fZone = v;
				fGUI->updateZone(fZone);
			}
		}

};

/**
 * User Interface item owned (and so deleted) by external code
 */

class uiOwnedItem : public uiItem {
    
    protected:
    
        uiOwnedItem(GUI* ui, FAUSTFLOAT* zone):uiItem(ui, zone)
        {}
    
     public:
    
        virtual ~uiOwnedItem()
        {}
    
        virtual void reflectZone() {}
};

/**
 * Callback Item
 */

class uiCallbackItem : public uiItem {
    
    protected:
    
        uiCallback fCallback;
        void* fData;
    
    public:
    
        uiCallbackItem(GUI* ui, FAUSTFLOAT* zone, uiCallback foo, void* data)
        : uiItem(ui, zone), fCallback(foo), fData(data) {}
        
        virtual void reflectZone() 
        {		
            FAUSTFLOAT v = *fZone;
            fCache = v; 
            fCallback(v, fData);	
        }
};

/**
 *  For timestamped control
 */

struct DatedControl {
    
    double fDate;
    FAUSTFLOAT fValue;
    
    DatedControl(double d = 0., FAUSTFLOAT v = FAUSTFLOAT(0)):fDate(d), fValue(v) {}
    
};

/**
 * Base class for timed items
 */

class uiTimedItem : public uiItem
{
    
    protected:
        
        bool fDelete;
        
    public:
    
        using uiItem::modifyZone;
        
        uiTimedItem(GUI* ui, FAUSTFLOAT* zone):uiItem(ui, zone)
        {
            if (GUI::gTimedZoneMap.find(fZone) == GUI::gTimedZoneMap.end()) {
                GUI::gTimedZoneMap[fZone] = ringbuffer_create(8192);
                fDelete = true;
            } else {
                fDelete = false;
            }
        }
        
        virtual ~uiTimedItem()
        {
            ztimedmap::iterator it;
            if (fDelete && ((it = GUI::gTimedZoneMap.find(fZone)) != GUI::gTimedZoneMap.end())) {
                ringbuffer_free((*it).second);
                GUI::gTimedZoneMap.erase(it);
            }
        }
        
        virtual void modifyZone(double date, FAUSTFLOAT v)
        {
            size_t res;
            DatedControl dated_val(date, v);
            if ((res = ringbuffer_write(GUI::gTimedZoneMap[fZone], (const char*)&dated_val, sizeof(DatedControl))) != sizeof(DatedControl)) {
                std::cerr << "ringbuffer_write error DatedControl" << std::endl;
            }
        }
    
};

/**
 * Allows to group a set of zones
 */

class uiGroupItem : public uiItem
{
    protected:
    
        std::vector<FAUSTFLOAT*> fZoneMap;

    public:
    
        uiGroupItem(GUI* ui, FAUSTFLOAT* zone):uiItem(ui, zone)
        {}
        virtual ~uiGroupItem() 
        {}
        
        virtual void reflectZone() 
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            
            // Update all zones of the same group
            std::vector<FAUSTFLOAT*>::iterator it;
            for (it = fZoneMap.begin(); it != fZoneMap.end(); it++) {
                (*(*it)) = v;
            }
        }
        
        void addZone(FAUSTFLOAT* zone) { fZoneMap.push_back(zone); }

};

// Can not be defined as method in the classes

static void createUiCallbackItem(GUI* ui, FAUSTFLOAT* zone, uiCallback foo, void* data)
{
    new uiCallbackItem(ui, zone, foo, data);
}

static void deleteClist(clist* cl)
{
    std::list<uiItemBase*>::iterator it;
    for (it = cl->begin(); it != cl->end(); it++) {
        uiOwnedItem* owned = dynamic_cast<uiOwnedItem*>(*it);
        // owned items are deleted by external code
        if (!owned) {
            delete (*it);
        }
    }
}

#endif
/**************************  END  GUI.h **************************/
/************************** BEGIN JSONUI.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/
 
#ifndef FAUST_JSONUI_H
#define FAUST_JSONUI_H

#include <vector>
#include <map>
#include <string>
#include <iostream>
#include <sstream>
#include <algorithm>


/*******************************************************************************
 * JSONUI : Faust User Interface
 * This class produce a complete JSON decription of the DSP instance.
 ******************************************************************************/

template <typename REAL>
class JSONUIAux : public PathBuilder, public Meta, public UI
{

    protected:
    
        std::stringstream fUI;
        std::stringstream fMeta;
        std::vector<std::pair <std::string, std::string> > fMetaAux;
        std::string fVersion;           // Compiler version
        std::string fCompileOptions;    // Compilation options
        std::vector<std::string> fLibraryList;
        std::vector<std::string> fIncludePathnames;
        std::string fName;
        std::string fFileName;
        std::string fExpandedCode;
        std::string fSHAKey;
        std::string fDSPSize;           // In bytes
        std::map<std::string, int> fPathTable;
    
        char fCloseUIPar;
        char fCloseMetaPar;
        int fTab;
    
        int fInputs, fOutputs, fSRIndex;
         
        void tab(int n, std::ostream& fout)
        {
            fout << '\n';
            while (n-- > 0) {
                fout << '\t';
            }
        }
    
        std::string flatten(const std::string& src)
        {
            std::string dst;
            for (size_t i = 0; i < src.size(); i++) {
                switch (src[i]) {
                    case '\n':
                    case '\t':
                        break;
                    default:
                        dst += src[i];
                        break;
                }
            }
            return dst;
        }
    
        void addMeta(int tab_val, bool quote = true)
        {
            if (fMetaAux.size() > 0) {
                tab(tab_val, fUI); fUI << "\"meta\": [";
                std::string sep = "";
                for (size_t i = 0; i < fMetaAux.size(); i++) {
                    fUI << sep;
                    tab(tab_val + 1, fUI); fUI << "{ \"" << fMetaAux[i].first << "\": \"" << fMetaAux[i].second << "\" }";
                    sep = ",";
                }
                tab(tab_val, fUI); fUI << ((quote) ? "],": "]");
                fMetaAux.clear();
            }
        }
    
        std::string getAddressIndex(const std::string& path)
        {
            if (fPathTable.find(path) != fPathTable.end()) {
                std::stringstream num; num << fPathTable[path];
                return num.str();
            } else {
                return "-1";
            }
        }
      
     public:
     
        JSONUIAux(const std::string& name,
                  const std::string& filename,
                  int inputs,
                  int outputs,
                  int sr_index,
                  const std::string& sha_key,
                  const std::string& dsp_code,
                  const std::string& version,
                  const std::string& compile_options,
                  const std::vector<std::string>& library_list,
                  const std::vector<std::string>& include_pathnames,
                  const std::string& size,
                  const std::map<std::string, int>& path_table)
        {
            init(name, filename, inputs, outputs, sr_index, sha_key, dsp_code, version, compile_options, library_list, include_pathnames, size, path_table);
        }

        JSONUIAux(const std::string& name, const std::string& filename, int inputs, int outputs)
        {
            init(name, filename, inputs, outputs, -1, "", "", "", "", std::vector<std::string>(), std::vector<std::string>(), "", std::map<std::string, int>());
        }

        JSONUIAux(int inputs, int outputs)
        {
            init("", "", inputs, outputs, -1, "", "","", "", std::vector<std::string>(), std::vector<std::string>(), "", std::map<std::string, int>());
        }
        
        JSONUIAux()
        {
            init("", "", -1, -1, -1, "", "", "", "", std::vector<std::string>(), std::vector<std::string>(), "", std::map<std::string, int>());
        }
 
        virtual ~JSONUIAux() {}
        
        void setInputs(int inputs) { fInputs = inputs; }
        void setOutputs(int outputs) { fOutputs = outputs; }
    
        void setSRIndex(int sr_index) { fSRIndex = sr_index; }
    
        // Init may be called multiple times so fMeta and fUI are reinitialized
        void init(const std::string& name,
                  const std::string& filename,
                  int inputs,
                  int outputs,
                  int sr_index,
                  const std::string& sha_key,
                  const std::string& dsp_code,
                  const std::string& version,
                  const std::string& compile_options,
                  const std::vector<std::string>& library_list,
                  const std::vector<std::string>& include_pathnames,
                  const std::string& size,
                  const std::map<std::string, int>& path_table)
        {
            fTab = 1;
            
            // Start Meta generation
            fMeta.str("");
            tab(fTab, fMeta); fMeta << "\"meta\": [";
            fCloseMetaPar = ' ';
            
            // Start UI generation
            fUI.str("");
            tab(fTab, fUI); fUI << "\"ui\": [";
            fCloseUIPar = ' ';
            fTab += 1;
            
            fName = name;
            fFileName = filename;
            fInputs = inputs;
            fOutputs = outputs;
            fSRIndex = sr_index;
            fExpandedCode = dsp_code;
            fSHAKey = sha_key;
            fDSPSize = size;
            fPathTable = path_table;
            fVersion = version;
            fCompileOptions = compile_options;
            fLibraryList = library_list;
            fIncludePathnames = include_pathnames;
        }
   
        // -- widget's layouts
    
        virtual void openGenericGroup(const char* label, const char* name)
        {
            pushLabel(label);
            fUI << fCloseUIPar;
            tab(fTab, fUI); fUI << "{";
            fTab += 1;
            tab(fTab, fUI); fUI << "\"type\": \"" << name << "\",";
            tab(fTab, fUI); fUI << "\"label\": \"" << label << "\",";
            addMeta(fTab);
            tab(fTab, fUI); fUI << "\"items\": [";
            fCloseUIPar = ' ';
            fTab += 1;
        }

        virtual void openTabBox(const char* label)
        {
            openGenericGroup(label, "tgroup");
        }
    
        virtual void openHorizontalBox(const char* label)
        {
            openGenericGroup(label, "hgroup");
        }
    
        virtual void openVerticalBox(const char* label)
        {
            openGenericGroup(label, "vgroup");
        }
    
        virtual void closeBox()
        {
            popLabel();
            fTab -= 1;
            tab(fTab, fUI); fUI << "]";
            fTab -= 1;
            tab(fTab, fUI); fUI << "}";
            fCloseUIPar = ',';
        }
    
        // -- active widgets
  
        virtual void addGenericButton(const char* label, const char* name)
        {
            std::string path = buildPath(label);
            
            fUI << fCloseUIPar;
            tab(fTab, fUI); fUI << "{";
            fTab += 1;
            tab(fTab, fUI); fUI << "\"type\": \"" << name << "\",";
            tab(fTab, fUI); fUI << "\"label\": \"" << label << "\",";
            if (fPathTable.size() > 0) {
                tab(fTab, fUI); fUI << "\"address\": \"" << path << "\",";
                tab(fTab, fUI); fUI << "\"index\": \"" << getAddressIndex(path) << "\"" << ((fMetaAux.size() > 0) ? "," : "");
            } else {
                tab(fTab, fUI); fUI << "\"address\": \"" << path << "\"" << ((fMetaAux.size() > 0) ? "," : "");
            }
            addMeta(fTab, false);
            fTab -= 1;
            tab(fTab, fUI); fUI << "}";
            fCloseUIPar = ',';
        }

        virtual void addButton(const char* label, REAL* zone)
        {
            addGenericButton(label, "button");
        }
    
        virtual void addCheckButton(const char* label, REAL* zone)
        {
            addGenericButton(label, "checkbox");
        }

        virtual void addGenericEntry(const char* label, const char* name, REAL init, REAL min, REAL max, REAL step)
        {
            std::string path = buildPath(label);
            
            fUI << fCloseUIPar;
            tab(fTab, fUI); fUI << "{";
            fTab += 1;
            tab(fTab, fUI); fUI << "\"type\": \"" << name << "\",";
            tab(fTab, fUI); fUI << "\"label\": \"" << label << "\",";
            tab(fTab, fUI); fUI << "\"address\": \"" << path << "\",";
            if (fPathTable.size() > 0) {
                tab(fTab, fUI); fUI << "\"index\": \"" << getAddressIndex(path) << "\",";
            }
            addMeta(fTab);
            tab(fTab, fUI); fUI << "\"init\": \"" << init << "\",";
            tab(fTab, fUI); fUI << "\"min\": \"" << min << "\",";
            tab(fTab, fUI); fUI << "\"max\": \"" << max << "\",";
            tab(fTab, fUI); fUI << "\"step\": \"" << step << "\"";
            fTab -= 1;
            tab(fTab, fUI); fUI << "}";
            fCloseUIPar = ',';
        }
    
        virtual void addVerticalSlider(const char* label, REAL* zone, REAL init, REAL min, REAL max, REAL step)
        {
            addGenericEntry(label, "vslider", init, min, max, step);
        }
    
        virtual void addHorizontalSlider(const char* label, REAL* zone, REAL init, REAL min, REAL max, REAL step)
        {
            addGenericEntry(label, "hslider", init, min, max, step);
        }
    
        virtual void addNumEntry(const char* label, REAL* zone, REAL init, REAL min, REAL max, REAL step)
        {
            addGenericEntry(label, "nentry", init, min, max, step);
        }

        // -- passive widgets
    
        virtual void addGenericBargraph(const char* label, const char* name, REAL min, REAL max) 
        {
            std::string path = buildPath(label);
            
            fUI << fCloseUIPar;
            tab(fTab, fUI); fUI << "{";
            fTab += 1;
            tab(fTab, fUI); fUI << "\"type\": \"" << name << "\",";
            tab(fTab, fUI); fUI << "\"label\": \"" << label << "\",";
            tab(fTab, fUI); fUI << "\"address\": \"" << path << "\",";
            if (fPathTable.size() > 0) {
                tab(fTab, fUI); fUI << "\"index\": \"" << getAddressIndex(path) << "\",";
            }
            addMeta(fTab);
            tab(fTab, fUI); fUI << "\"min\": \"" << min << "\",";
            tab(fTab, fUI); fUI << "\"max\": \"" << max << "\"";
            fTab -= 1;
            tab(fTab, fUI); fUI << "}";
            fCloseUIPar = ',';
        }

        virtual void addHorizontalBargraph(const char* label, REAL* zone, REAL min, REAL max) 
        {
            addGenericBargraph(label, "hbargraph", min, max);
        }
    
        virtual void addVerticalBargraph(const char* label, REAL* zone, REAL min, REAL max)
        {
            addGenericBargraph(label, "vbargraph", min, max);
        }
    
        virtual void addSoundfile(const char* label, const char* url, Soundfile** zone)
        {
            std::string path = buildPath(label);
            
            fUI << fCloseUIPar;
            tab(fTab, fUI); fUI << "{";
            fTab += 1;
            tab(fTab, fUI); fUI << "\"type\": \"" << "soundfile" << "\",";
            tab(fTab, fUI); fUI << "\"label\": \"" << label << "\"" << ",";
            tab(fTab, fUI); fUI << "\"url\": \"" << url << "\"" << ",";
            tab(fTab, fUI); fUI << "\"address\": \"" << path << "\"" << ((fPathTable.size() > 0) ? "," : "");
            if (fPathTable.size() > 0) {
                tab(fTab, fUI); fUI << "\"index\": \"" << getAddressIndex(path) << "\"";
            }
            fTab -= 1;
            tab(fTab, fUI); fUI << "}";
            fCloseUIPar = ',';
        }

        // -- metadata declarations

        virtual void declare(REAL* zone, const char* key, const char* val)
        {
            fMetaAux.push_back(std::make_pair(key, val));
        }
    
        // Meta interface
        virtual void declare(const char* key, const char* value)
        {
            fMeta << fCloseMetaPar;
            // fName found in metadata
            if ((strcmp(key, "name") == 0) && (fName == "")) fName = value;
            // fFileName found in metadata
            if ((strcmp(key, "filename") == 0) && (fFileName == "")) fFileName = value;
            tab(fTab, fMeta); fMeta << "{ " << "\"" << key << "\"" << ": " << "\"" << value << "\" }";
            fCloseMetaPar = ',';
        }
    
        std::string JSON(bool flat = false)
        {
            fTab = 0;
            std::stringstream JSON;
            JSON << "{";
            fTab += 1;
            tab(fTab, JSON); JSON << "\"name\": \"" << fName << "\",";
            tab(fTab, JSON); JSON << "\"filename\": \"" << fFileName << "\",";
            if (fVersion != "") { tab(fTab, JSON); JSON << "\"version\": \"" << fVersion << "\","; }
            if (fCompileOptions != "") { tab(fTab, JSON); JSON << "\"compile_options\": \"" <<  fCompileOptions << "\","; }
            if (fLibraryList.size() > 0) {
                tab(fTab, JSON);
                JSON << "\"library_list\": [";
                for (size_t i = 0; i < fLibraryList.size(); i++) {
                    JSON << "\"" << fLibraryList[i] << "\"";
                    if (i < (fLibraryList.size() - 1)) JSON << ",";
                }
                JSON << "],";
            }
            if (fIncludePathnames.size() > 0) {
                tab(fTab, JSON);
                JSON << "\"include_pathnames\": [";
                for (size_t i = 0; i < fIncludePathnames.size(); i++) {
                    JSON << "\"" << fIncludePathnames[i] << "\"";
                    if (i < (fIncludePathnames.size() - 1)) JSON << ",";
                }
                JSON << "],";
            }
            if (fDSPSize != "") { tab(fTab, JSON); JSON << "\"size\": \"" << fDSPSize << "\","; }
            if (fSHAKey != "") { tab(fTab, JSON); JSON << "\"sha_key\": \"" << fSHAKey << "\","; }
            if (fExpandedCode != "") { tab(fTab, JSON); JSON << "\"code\": \"" << fExpandedCode << "\","; }
            tab(fTab, JSON); JSON << "\"inputs\": \"" << fInputs << "\","; 
            tab(fTab, JSON); JSON << "\"outputs\": \"" << fOutputs << "\",";
            if (fSRIndex != -1) { tab(fTab, JSON); JSON << "\"sr_index\": \"" << fSRIndex << "\","; }
            tab(fTab, fMeta); fMeta << "],";
            tab(fTab, fUI); fUI << "]";
            fTab -= 1;
            if (fCloseMetaPar == ',') { // If "declare" has been called, fCloseMetaPar state is now ','
                JSON << fMeta.str() << fUI.str();
            } else {
                JSON << fUI.str();
            }
            tab(fTab, JSON); JSON << "}";
            return (flat) ? flatten(JSON.str()) : JSON.str();
        }
    
};

// Externally available class using FAUSTFLOAT

class JSONUI : public JSONUIAux<FAUSTFLOAT>
{
    public :
    
        JSONUI(const std::string& name,
               const std::string& filename,
               int inputs,
               int outputs,
               int sr_index,
               const std::string& sha_key,
               const std::string& dsp_code,
               const std::string& version,
               const std::string& compile_options,
               const std::vector<std::string>& library_list,
               const std::vector<std::string>& include_pathnames,
               const std::string& size,
               const std::map<std::string, int>& path_table):
        JSONUIAux<FAUSTFLOAT>(name, filename,
                              inputs, outputs,
                              sr_index,
                              sha_key, dsp_code,
                              version, compile_options,
                              library_list, include_pathnames,
                              size, path_table)
        {}
        
        JSONUI(const std::string& name, const std::string& filename, int inputs, int outputs):
        JSONUIAux<FAUSTFLOAT>(name, filename, inputs, outputs)
        {}
        
        JSONUI(int inputs, int outputs):JSONUIAux<FAUSTFLOAT>(inputs, outputs)
        {}
        
        JSONUI():JSONUIAux<FAUSTFLOAT>()
        {}
    
        virtual ~JSONUI() {}
    
};

#endif // FAUST_JSONUI_H
/**************************  END  JSONUI.h **************************/
/************************** BEGIN MetaDataUI.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef MetaData_UI_H
#define MetaData_UI_H

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif

#include <map>
#include <set>
#include <string>
#include <assert.h>

/************************** BEGIN SimpleParser.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef SIMPLEPARSER_H
#define SIMPLEPARSER_H

// ---------------------------------------------------------------------
//                          Simple Parser
// A parser returns true if it was able to parse what it is
// supposed to parse and advance the pointer. Otherwise it returns false
// and the pointer is not advanced so that another parser can be tried.
// ---------------------------------------------------------------------

#include <vector>
#include <map>
#include <string>
#include <fstream>
#include <iostream>
#include <ctype.h>

#ifndef _WIN32
# pragma GCC diagnostic ignored "-Wunused-function"
#endif

struct itemInfo {
    std::string type;
    std::string label;
    std::string url;
    std::string address;
    std::string index;
    std::string init;
    std::string min;
    std::string max;
    std::string step;
    std::vector<std::pair<std::string, std::string> > meta;
};

// ---------------------------------------------------------------------
//                          Elementary parsers
// ---------------------------------------------------------------------

// Report a parsing error
static bool parseError(const char*& p, const char* errmsg)
{
    std::cerr << "Parse error : " << errmsg << " here : " << p << std::endl;
    return true;
}

/**
 * @brief skipBlank : advance pointer p to the first non blank character
 * @param p the string to parse, then the remaining string
 */
static void skipBlank(const char*& p)
{
    while (isspace(*p)) { p++; }
}

// Parse character x, but don't report error if fails
static bool tryChar(const char*& p, char x)
{
    skipBlank(p);
    if (x == *p) {
        p++;
        return true;
    } else {
        return false;
    }
}

/**
 * @brief parseChar : parse a specific character x
 * @param p the string to parse, then the remaining string
 * @param x the character to recognize
 * @return true if x was found at the begin of p
 */
static bool parseChar(const char*& p, char x)
{
    skipBlank(p);
    if (x == *p) {
        p++;
        return true;
    } else {
        return false;
    }
}

/**
 * @brief parseWord : parse a specific string w
 * @param p the string to parse, then the remaining string
 * @param w the string to recognize
 * @return true if string w was found at the begin of p
 */
static bool parseWord(const char*& p, const char* w)
{
    skipBlank(p);
    const char* saved = p;  // to restore position if we fail
    while ((*w == *p) && (*w)) {++w; ++p;}
    if (*w) {
        p = saved;
        return false;
    } else {
        return true;
    }
}

/**
 * @brief parseDouble : parse number [s]dddd[.dddd] and store the result in x
 * @param p the string to parse, then the remaining string
 * @param x the float number found if any
 * @return true if a float number was found at the begin of p
 */
static bool parseDouble(const char*& p, double& x)
{
    double sign = +1.0;    // sign of the number
    double ipart = 0;      // integral part of the number
    double dpart = 0;      // decimal part of the number before division
    double dcoef = 1.0;    // division factor for the decimal part
    
    bool valid = false;    // true if the number contains at least one digit
    skipBlank(p);
    const char* saved = p; // to restore position if we fail
    
    if (parseChar(p, '+')) {
        sign = 1.0;
    } else if (parseChar(p, '-')) {
        sign = -1.0;
    }
    while (isdigit(*p)) {
        valid = true;
        ipart = ipart*10 + (*p - '0');
        p++;
    }
    if (parseChar(p, '.')) {
        while (isdigit(*p)) {
            valid = true;
            dpart = dpart*10 + (*p - '0');
            dcoef *= 10.0;
            p++;
        }
    }
    if (valid)  {
        x = sign*(ipart + dpart/dcoef);
    } else {
        p = saved;
    }
    return valid;
}

/**
 * @brief parseString, parse an arbitrary quoted string q...q and store the result in s
 * @param p the string to parse, then the remaining string
 * @param quote the character used to quote the string
 * @param s the (unquoted) string found if any
 * @return true if a string was found at the begin of p
 */
static bool parseString(const char*& p, char quote, std::string& s)
{
    std::string str;
    skipBlank(p);
    
    const char* saved = p;  // to restore position if we fail
    if (*p++ == quote) {
        while ((*p != 0) && (*p != quote)) {
            str += *p++;
        }
        if (*p++ == quote) {
            s = str;
            return true;
        }
    }
    p = saved;
    return false;
}

/**
 * @brief parseSQString, parse a single quoted string '...' and store the result in s
 * @param p the string to parse, then the remaining string
 * @param s the (unquoted) string found if any
 * @return true if a string was found at the begin of p
 */
static bool parseSQString(const char*& p, std::string& s)
{
    return parseString(p, '\'', s);
}

/**
 * @brief parseDQString, parse a double quoted string "..." and store the result in s
 * @param p the string to parse, then the remaining string
 * @param s the (unquoted) string found if any
 * @return true if a string was found at the begin of p
 */
static bool parseDQString(const char*& p, std::string& s)
{
    return parseString(p, '"', s);
}

// ---------------------------------------------------------------------
//
//                          IMPLEMENTATION
// 
// ---------------------------------------------------------------------

/**
 * @brief parseMenuItem, parse a menu item ...'low':440.0...
 * @param p the string to parse, then the remaining string
 * @param name the name found
 * @param value the value found
 * @return true if a nemu item was found
 */
static bool parseMenuItem(const char*& p, std::string& name, double& value)
{
    const char* saved = p;  // to restore position if we fail
    if (parseSQString(p, name) && parseChar(p, ':') && parseDouble(p, value)) {
        return true;
    } else {
        p = saved;
        return false;
    }
}

static bool parseMenuItem2(const char*& p, std::string& name)
{
    const char* saved = p;  // to restore position if we fail
    
    // single quoted
    if (parseSQString(p, name)) {
        return true;
    } else {
        p = saved;
        return false;
    }
}

/**
 * @brief parseMenuList, parse a menu list {'low' : 440.0; 'mid' : 880.0; 'hi' : 1760.0}...
 * @param p the string to parse, then the remaining string
 * @param names the vector of names found
 * @param values the vector of values found
 * @return true if a menu list was found
 */
static bool parseMenuList(const char*& p, std::vector<std::string>& names, std::vector<double>& values)
{
    std::vector<std::string> tmpnames;
    std::vector<double> tmpvalues;
    const char* saved = p; // to restore position if we fail

    if (parseChar(p, '{')) {
        do {
            std::string n;
            double v;
            if (parseMenuItem(p, n, v)) {
                tmpnames.push_back(n);
                tmpvalues.push_back(v);
            } else {
                p = saved;
                return false;
            }
        } while (parseChar(p, ';'));
        if (parseChar(p, '}')) {
            // we suceeded
            names = tmpnames;
            values = tmpvalues;
            return true;
        }
    }
    p = saved;
    return false;
}

static bool parseMenuList2(const char*& p, std::vector<std::string>& names, bool debug)
{
    std::vector<std::string> tmpnames;
    const char* saved = p;  // to restore position if we fail
    
    if (parseChar(p, '{')) {
        do {
            std::string n;
            if (parseMenuItem2(p, n)) {
                tmpnames.push_back(n);
            } else {
                goto error;
            }
        } while (parseChar(p, ';'));
        if (parseChar(p, '}')) {
            // we suceeded
            names = tmpnames;
            return true;
        }
    }
    
error:
    if (debug) { std::cerr << "parseMenuList2 : (" << saved << ") is not a valid list !\n"; }
    p = saved;
    return false;
}

/// ---------------------------------------------------------------------
// Parse list of strings
/// ---------------------------------------------------------------------
static bool parseList(const char*& p, std::vector<std::string>& items)
{
    const char* saved = p;  // to restore position if we fail
    if (parseChar(p, '[')) {
        do {
            std::string item;
            if (!parseDQString(p, item)) {
                p = saved;
                return false;
            }
            items.push_back(item);
        } while (tryChar(p, ','));
        return parseChar(p, ']');
    } else {
        p = saved;
        return false;
    }
}

static bool parseMetaData(const char*& p, std::map<std::string, std::string>& metadatas)
{
    std::string metaKey, metaValue;
    if (parseChar(p, ':') && parseChar(p, '[')) {
        do { 
            if (parseChar(p, '{') && parseDQString(p, metaKey) && parseChar(p, ':') && parseDQString(p, metaValue) && parseChar(p, '}')) {
                metadatas[metaKey] = metaValue;
            }
        } while (tryChar(p, ','));
        return parseChar(p, ']');
    } else {
        return false;
    }
}

static bool parseItemMetaData(const char*& p, std::vector<std::pair<std::string, std::string> >& metadatas)
{
    std::string metaKey, metaValue;
    if (parseChar(p, ':') && parseChar(p, '[')) {
        do { 
            if (parseChar(p, '{') && parseDQString(p, metaKey) && parseChar(p, ':') && parseDQString(p, metaValue) && parseChar(p, '}')) {
                metadatas.push_back(std::make_pair(metaKey, metaValue));
            }
        } while (tryChar(p, ','));
        return parseChar(p, ']');
    } else {
        return false;
    }
}

// ---------------------------------------------------------------------
// Parse metadatas of the interface:
// "name" : "...", "inputs" : "...", "outputs" : "...", ...
// and store the result as key/value
/// ---------------------------------------------------------------------
static bool parseGlobalMetaData(const char*& p, std::string& key, std::string& value, std::map<std::string, std::string>& metadatas, std::vector<std::string>& items)
{
    if (parseDQString(p, key)) {
        if (key == "meta") {
            return parseMetaData(p, metadatas);
        } else {
            return parseChar(p, ':') && (parseDQString(p, value) || parseList(p, items));
        }
    } else {
        return false;
    }
}

// ---------------------------------------------------------------------
// Parse gui:
// "type" : "...", "label" : "...", "address" : "...", ...
// and store the result in uiItems Vector
/// ---------------------------------------------------------------------
static bool parseUI(const char*& p, std::vector<itemInfo>& uiItems, int& numItems)
{
    if (parseChar(p, '{')) {
   
        std::string label;
        std::string value;
        
        do {
            if (parseDQString(p, label)) {
                if (label == "type") {
                    if (uiItems.size() != 0) {
                        numItems++;
                    }
                    if (parseChar(p, ':') && parseDQString(p, value)) {   
                        itemInfo item;
                        item.type = value;
                        uiItems.push_back(item);
                    }
                }
                
                else if (label == "label") {
                    if (parseChar(p, ':') && parseDQString(p, value)) {
                        uiItems[numItems].label = value;
                    }
                }
                
                else if (label == "url") {
                    if (parseChar(p, ':') && parseDQString(p, value)) {
                        uiItems[numItems].url = value;
                    }
                }
                
                else if (label == "address") {
                    if (parseChar(p, ':') && parseDQString(p, value)) {
                        uiItems[numItems].address = value;
                    }
                }
                
                else if (label == "index") {
                    if (parseChar(p, ':') && parseDQString(p, value)) {
                        uiItems[numItems].index = value;
                    }
                }
                
                else if (label == "meta") {
                    if (!parseItemMetaData(p, uiItems[numItems].meta)) {
                        return false;
                    }
                }
                
                else if (label == "init") {
                    if (parseChar(p, ':') && parseDQString(p, value)) {
                        uiItems[numItems].init = value;
                    }
                }
                
                else if (label == "min") {
                    if (parseChar(p, ':') && parseDQString(p, value)) {
                        uiItems[numItems].min = value;
                    }
                }
                
                else if (label == "max") {
                    if (parseChar(p, ':') && parseDQString(p, value)) {
                        uiItems[numItems].max = value;
                    }
                }
                
                else if (label == "step"){
                    if (parseChar(p, ':') && parseDQString(p, value)) {
                        uiItems[numItems].step = value;
                    }
                }
                
                else if (label == "items") {
                    if (parseChar(p, ':') && parseChar(p, '[')) {
                        do { 
                            if (!parseUI(p, uiItems, numItems)) {
                                return false;
                            }
                        } while (tryChar(p, ','));
                        if (parseChar(p, ']')) {
                            itemInfo item;
                            item.type = "close";
                            uiItems.push_back(item);
                            numItems++;
                        }
                    }
                }
            } else {
                return false;
            }
            
        } while (tryChar(p, ','));
        
        return parseChar(p, '}');
    } else {
        return false;
    }
}

// ---------------------------------------------------------------------
// Parse full JSON record describing a JSON/Faust interface :
// {"metadatas": "...", "ui": [{ "type": "...", "label": "...", "items": [...], "address": "...","init": "...", "min": "...", "max": "...","step": "..."}]}
//
// and store the result in map Metadatas and vector containing the items of the interface. Returns true if parsing was successfull.
/// ---------------------------------------------------------------------
static bool parseJson(const char*& p,
                      std::map<std::string, std::string>& metaDatas0,
                      std::map<std::string, std::string>& metaDatas1,
                      std::map<std::string, std::vector<std::string> >& metaDatas2,
                      std::vector<itemInfo>& uiItems)
{
    parseChar(p, '{');
    
    do {
        std::string key;
        std::string value;
        std::vector<std::string> items;
        if (parseGlobalMetaData(p, key, value, metaDatas1, items)) {
            if (key != "meta") {
                // keep "name", "inputs", "outputs" key/value pairs
                if (items.size() > 0) {
                    metaDatas2[key] = items;
                    items.clear();
                } else {
                    metaDatas0[key] = value;
                }
            }
        } else if (key == "ui") {
            int numItems = 0;
            parseChar(p, '[') && parseUI(p, uiItems, numItems);
        }
    } while (tryChar(p, ','));
    
    return parseChar(p, '}');
}

#endif // SIMPLEPARSER_H
/**************************  END  SimpleParser.h **************************/

static bool startWith(const std::string& str, const std::string& prefix)
{
    return (str.substr(0, prefix.size()) == prefix);
}

/**
 * Convert a dB value into a scale between 0 and 1 (following IEC standard ?)
 */
static FAUSTFLOAT dB2Scale(FAUSTFLOAT dB)
{
    FAUSTFLOAT scale = FAUSTFLOAT(1.0);
    
    /*if (dB < -70.0f)
     scale = 0.0f;
     else*/
    if (dB < FAUSTFLOAT(-60.0))
        scale = (dB + FAUSTFLOAT(70.0)) * FAUSTFLOAT(0.0025);
    else if (dB < FAUSTFLOAT(-50.0))
        scale = (dB + FAUSTFLOAT(60.0)) * FAUSTFLOAT(0.005) + FAUSTFLOAT(0.025);
    else if (dB < FAUSTFLOAT(-40.0))
        scale = (dB + FAUSTFLOAT(50.0)) * FAUSTFLOAT(0.0075) + FAUSTFLOAT(0.075);
    else if (dB < FAUSTFLOAT(-30.0))
        scale = (dB + FAUSTFLOAT(40.0)) * FAUSTFLOAT(0.015) + FAUSTFLOAT(0.15);
    else if (dB < FAUSTFLOAT(-20.0))
        scale = (dB + FAUSTFLOAT(30.0)) * FAUSTFLOAT(0.02) + FAUSTFLOAT(0.3);
    else if (dB < FAUSTFLOAT(-0.001) || dB > FAUSTFLOAT(0.001))  /* if (dB < 0.0) */
        scale = (dB + FAUSTFLOAT(20.0)) * FAUSTFLOAT(0.025) + FAUSTFLOAT(0.5);
    
    return scale;
}

/*******************************************************************************
 * MetaDataUI : Common class for MetaData handling
 ******************************************************************************/

//============================= BEGIN GROUP LABEL METADATA===========================
// Unlike widget's label, metadata inside group's label are not extracted directly by
// the Faust compiler. Therefore they must be extracted within the architecture file
//-----------------------------------------------------------------------------------

class MetaDataUI {
    
    protected:
        
        std::string                         fGroupTooltip;
        std::map<FAUSTFLOAT*, FAUSTFLOAT>   fGuiSize;            // map widget zone with widget size coef
        std::map<FAUSTFLOAT*, std::string>  fTooltip;            // map widget zone with tooltip strings
        std::map<FAUSTFLOAT*, std::string>  fUnit;               // map widget zone to unit string (i.e. "dB")
        std::map<FAUSTFLOAT*, std::string>  fRadioDescription;   // map zone to {'low':440; ...; 'hi':1000.0}
        std::map<FAUSTFLOAT*, std::string>  fMenuDescription;    // map zone to {'low':440; ...; 'hi':1000.0}
        std::set<FAUSTFLOAT*>               fKnobSet;            // set of widget zone to be knobs
        std::set<FAUSTFLOAT*>               fLedSet;             // set of widget zone to be LEDs
        std::set<FAUSTFLOAT*>               fNumSet;             // set of widget zone to be numerical bargraphs
        std::set<FAUSTFLOAT*>               fLogSet;             // set of widget zone having a log UI scale
        std::set<FAUSTFLOAT*>               fExpSet;             // set of widget zone having an exp UI scale
        std::set<FAUSTFLOAT*>               fHiddenSet;          // set of hidden widget zone
        
        void clearMetadata()
        {
            fGuiSize.clear();
            fTooltip.clear();
            fUnit.clear();
            fRadioDescription.clear();
            fMenuDescription.clear();
            fKnobSet.clear();
            fLedSet.clear();
            fNumSet.clear();
            fLogSet.clear();
            fExpSet.clear();
            fHiddenSet.clear();
        }
        
        /**
         * rmWhiteSpaces(): Remove the leading and trailing white spaces of a string
         * (but not those in the middle of the string)
         */
        static std::string rmWhiteSpaces(const std::string& s)
        {
            size_t i = s.find_first_not_of(" \t");
            size_t j = s.find_last_not_of(" \t");
            if ((i != std::string::npos) && (j != std::string::npos)) {
                return s.substr(i, 1+j-i);
            } else {
                return "";
            }
        }
        
        /**
         * Format tooltip string by replacing some white spaces by
         * return characters so that line width doesn't exceed n.
         * Limitation : long words exceeding n are not cut
         */
        std::string formatTooltip(int n, const std::string& tt)
        {
            std::string ss = tt;  // ss string we are going to format
            int lws = 0;          // last white space encountered
            int lri = 0;          // last return inserted
            for (int i = 0; i < (int)tt.size(); i++) {
                if (tt[i] == ' ') lws = i;
                if (((i-lri) >= n) && (lws > lri)) {
                    // insert return here
                    ss[lws] = '\n';
                    lri = lws;
                }
            }
            return ss;
        }
        
    public:
        
        virtual ~MetaDataUI()
        {}
        
        enum Scale {
            kLin,
            kLog,
            kExp
        };
        
        Scale getScale(FAUSTFLOAT* zone)
        {
            if (fLogSet.count(zone) > 0) return kLog;
            if (fExpSet.count(zone) > 0) return kExp;
            return kLin;
        }
        
        bool isKnob(FAUSTFLOAT* zone)
        {
            return fKnobSet.count(zone) > 0;
        }
        
        bool isRadio(FAUSTFLOAT* zone)
        {
            return fRadioDescription.count(zone) > 0;
        }
        
        bool isMenu(FAUSTFLOAT* zone)
        {
            return fMenuDescription.count(zone) > 0;
        }
        
        bool isLed(FAUSTFLOAT* zone)
        {
            return fLedSet.count(zone) > 0;
        }
        
        bool isNumerical(FAUSTFLOAT* zone)
        {
            return fNumSet.count(zone) > 0;
        }
        
        bool isHidden(FAUSTFLOAT* zone)
        {
            return fHiddenSet.count(zone) > 0;
        }
        
        /**
         * Extracts metadata from a label : 'vol [unit: dB]' -> 'vol' + metadata(unit=dB)
         */
        static void extractMetadata(const std::string& fulllabel, std::string& label, std::map<std::string, std::string>& metadata)
        {
            enum {kLabel, kEscape1, kEscape2, kEscape3, kKey, kValue};
            int state = kLabel; int deep = 0;
            std::string key, value;
            
            for (unsigned int i = 0; i < fulllabel.size(); i++) {
                char c = fulllabel[i];
                switch (state) {
                    case kLabel :
                        assert(deep == 0);
                        switch (c) {
                            case '\\' : state = kEscape1; break;
                            case '[' : state = kKey; deep++; break;
                            default : label += c;
                        }
                        break;
                        
                    case kEscape1:
                        label += c;
                        state = kLabel;
                        break;
                        
                    case kEscape2:
                        key += c;
                        state = kKey;
                        break;
                        
                    case kEscape3:
                        value += c;
                        state = kValue;
                        break;
                        
                    case kKey:
                        assert(deep > 0);
                        switch (c) {
                            case '\\':
                                state = kEscape2;
                                break;
                                
                            case '[':
                                deep++;
                                key += c;
                                break;
                                
                            case ':':
                                if (deep == 1) {
                                    state = kValue;
                                } else {
                                    key += c;
                                }
                                break;
                            case ']':
                                deep--;
                                if (deep < 1) {
                                    metadata[rmWhiteSpaces(key)] = "";
                                    state = kLabel;
                                    key="";
                                    value="";
                                } else {
                                    key += c;
                                }
                                break;
                            default : key += c;
                        }
                        break;
                        
                    case kValue:
                        assert(deep > 0);
                        switch (c) {
                            case '\\':
                                state = kEscape3;
                                break;
                                
                            case '[':
                                deep++;
                                value += c;
                                break;
                                
                            case ']':
                                deep--;
                                if (deep < 1) {
                                    metadata[rmWhiteSpaces(key)] = rmWhiteSpaces(value);
                                    state = kLabel;
                                    key = "";
                                    value = "";
                                } else {
                                    value += c;
                                }
                                break;
                            default : value += c;
                        }
                        break;
                        
                    default:
                        std::cerr << "ERROR unrecognized state " << state << std::endl;
                }
            }
            label = rmWhiteSpaces(label);
        }
        
        /**
         * Analyses the widget zone metadata declarations and takes appropriate actions
         */
        void declare(FAUSTFLOAT* zone, const char* key, const char* value)
        {
            if (zone == 0) {
                // special zone 0 means group metadata
                if (strcmp(key, "tooltip") == 0) {
                    // only group tooltip are currently implemented
                    fGroupTooltip = formatTooltip(30, value);
                } else if (strcmp(key, "hidden") == 0) {
                    fHiddenSet.insert(zone);
                }
            } else {
                if (strcmp(key, "size") == 0) {
                    fGuiSize[zone] = atof(value);
                }
                else if (strcmp(key, "tooltip") == 0) {
                    fTooltip[zone] = formatTooltip(30, value);
                }
                else if (strcmp(key, "unit") == 0) {
                    fUnit[zone] = value;
                }
                else if (strcmp(key, "hidden") == 0) {
                    fHiddenSet.insert(zone);
                }
                else if (strcmp(key, "scale") == 0) {
                    if (strcmp(value, "log") == 0) {
                        fLogSet.insert(zone);
                    } else if (strcmp(value, "exp") == 0) {
                        fExpSet.insert(zone);
                    }
                }
                else if (strcmp(key, "style") == 0) {
                    if (strcmp(value, "knob") == 0) {
                        fKnobSet.insert(zone);
                    } else if (strcmp(value, "led") == 0) {
                        fLedSet.insert(zone);
                    } else if (strcmp(value, "numerical") == 0) {
                        fNumSet.insert(zone);
                    } else {
                        const char* p = value;
                        if (parseWord(p, "radio")) {
                            fRadioDescription[zone] = std::string(p);
                        } else if (parseWord(p, "menu")) {
                            fMenuDescription[zone] = std::string(p);
                        }
                    }
                }
            }
        }
    
};

#endif
/**************************  END  MetaDataUI.h **************************/
/************************** BEGIN midi.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __midi__
#define __midi__

#include <vector>
#include <string>
#include <algorithm>
#include <assert.h>

class MapUI;

/*************************************
 A time-stamped short MIDI message
**************************************/

#pragma pack (push, 1)
struct MIDIMessage
{
    uint32_t frameIndex;
    uint8_t byte0, byte1, byte2;
};
#pragma pack (pop)

/*******************************************************************************
 * MIDI processor definition.
 *
 * MIDI input or output handling classes will implement this interface,
 * so the same method names (keyOn, ctrlChange...) will be used either
 * when decoding MIDI input or encoding MIDI output events.
 *******************************************************************************/

class midi {

    public:

        midi() {}
        virtual ~midi() {}

        // Additional time-stamped API for MIDI input
        virtual MapUI* keyOn(double, int channel, int pitch, int velocity)
        {
            return keyOn(channel, pitch, velocity);
        }
        
        virtual void keyOff(double, int channel, int pitch, int velocity = 127)
        {
            keyOff(channel, pitch, velocity);
        }
    
        virtual void keyPress(double, int channel, int pitch, int press)
        {
            keyPress(channel, pitch, press);
        }
        
        virtual void chanPress(double date, int channel, int press)
        {
            chanPress(channel, press);
        }
    
        virtual void pitchWheel(double, int channel, int wheel)
        {
            pitchWheel(channel, wheel);
        }
           
        virtual void ctrlChange(double, int channel, int ctrl, int value)
        {
            ctrlChange(channel, ctrl, value);
        }
    
        virtual void ctrlChange14bits(double, int channel, int ctrl, int value)
        {
            ctrlChange14bits(channel, ctrl, value);
        }

        virtual void progChange(double, int channel, int pgm)
        {
            progChange(channel, pgm);
        }
    
        virtual void sysEx(double, std::vector<unsigned char>& message)
        {
            sysEx(message);
        }

        // MIDI sync
        virtual void startSync(double date)  {}
        virtual void stopSync(double date)   {}
        virtual void clock(double date)  {}

        // Standard MIDI API
        virtual MapUI* keyOn(int channel, int pitch, int velocity)      { return 0; }
        virtual void keyOff(int channel, int pitch, int velocity)       {}
        virtual void keyPress(int channel, int pitch, int press)        {}
        virtual void chanPress(int channel, int press)                  {}
        virtual void ctrlChange(int channel, int ctrl, int value)       {}
        virtual void ctrlChange14bits(int channel, int ctrl, int value) {}
        virtual void pitchWheel(int channel, int wheel)                 {}
        virtual void progChange(int channel, int pgm)                   {}
        virtual void sysEx(std::vector<unsigned char>& message)         {}

        enum MidiStatus {

            // channel voice messages
            MIDI_NOTE_OFF = 0x80,
            MIDI_NOTE_ON = 0x90,
            MIDI_CONTROL_CHANGE = 0xB0,
            MIDI_PROGRAM_CHANGE = 0xC0,
            MIDI_PITCH_BEND = 0xE0,
            MIDI_AFTERTOUCH = 0xD0,         // aka channel pressure
            MIDI_POLY_AFTERTOUCH = 0xA0,    // aka key pressure
            MIDI_CLOCK = 0xF8,
            MIDI_START = 0xFA,
            MIDI_CONT = 0xFB,
            MIDI_STOP = 0xFC,
            MIDI_SYSEX_START = 0xF0,
            MIDI_SYSEX_STOP = 0xF7

        };

        enum MidiCtrl {

            ALL_NOTES_OFF = 123,
            ALL_SOUND_OFF = 120

        };
};

/****************************************************
 * Base class for MIDI input handling.
 *
 * Shared common code used for input handling:
 * - decoding Real-Time messages: handleSync
 * - decoding one data byte messages: handleData1
 * - decoding two data byte messages: handleData2
 * - getting ready messages in polling mode
 ****************************************************/

class midi_handler : public midi {

    protected:

        std::vector<midi*> fMidiInputs;
        std::string fName;
    
        int range(int min, int max, int val) { return (val < min) ? min : ((val >= max) ? max : val); }
  
    public:

        midi_handler(const std::string& name = "MIDIHandler"):fName(name) {}
        virtual ~midi_handler() {}

        void addMidiIn(midi* midi_dsp) { if (midi_dsp) fMidiInputs.push_back(midi_dsp); }
        void removeMidiIn(midi* midi_dsp)
        {
            std::vector<midi*>::iterator it = std::find(fMidiInputs.begin(), fMidiInputs.end(), midi_dsp);
            if (it != fMidiInputs.end()) {
                fMidiInputs.erase(it);
            }
        }

        virtual bool startMidi() { return true; }
        virtual void stopMidi() {}
    
        void setName(const std::string& name) { fName = name; }
        std::string getName() { return fName; }
    
        // To be used in polling mode
        virtual int getMessages(std::vector<MIDIMessage>* message) { return 0; }
    
        void handleSync(double time, int type)
        {
            if (type == MIDI_CLOCK) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->clock(time);
                }
            } else if (type == MIDI_START) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->startSync(time);
                }
            } else if (type == MIDI_STOP) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->stopSync(time);
                }
            }
        }

        void handleData1(double time, int type, int channel, int data1)
        {
            if (type == MIDI_PROGRAM_CHANGE) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->progChange(time, channel, data1);
                }
            } else if (type == MIDI_AFTERTOUCH) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->chanPress(time, channel, data1);
                }
            }
        }

        void handleData2(double time, int type, int channel, int data1, int data2)
        {
            if (type == MIDI_NOTE_OFF || ((type == MIDI_NOTE_ON) && (data2 == 0))) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->keyOff(time, channel, data1, data2);
                }
            } else if (type == MIDI_NOTE_ON) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->keyOn(time, channel, data1, data2);
                }
            } else if (type == MIDI_CONTROL_CHANGE) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->ctrlChange(time, channel, data1, data2);
                }
            } else if (type == MIDI_PITCH_BEND) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->pitchWheel(time, channel, (data2 << 7) + data1);
                }
            } else if (type == MIDI_POLY_AFTERTOUCH) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->keyPress(time, channel, data1, data2);
                }
            }
        }
    
        void handleMessage(double time, int type, std::vector<unsigned char>& message)
        {
            if (type == MIDI_SYSEX_START) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->sysEx(time, message);
                }
            }
        }

};

//-------------------------------
// For timestamped MIDI messages
//-------------------------------

struct DatedMessage {
    
    double fDate;
    unsigned char fBuffer[3];
    size_t fSize;
    
    DatedMessage(double date, unsigned char* buffer, size_t size)
    :fDate(date), fSize(size)
    {
        assert(size <= 3);
        memcpy(fBuffer, buffer, size);
    }
    
    DatedMessage():fDate(0.0), fSize(0)
    {}
    
};

#endif // __midi__
/**************************  END  midi.h **************************/
/************************** BEGIN ValueConverter.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __ValueConverter__
#define __ValueConverter__

/***************************************************************************************
								ValueConverter.h
							    (GRAME,  2015)

Set of conversion objects used to map user interface values (for example a gui slider
delivering values between 0 and 1) to faust values (for example a vslider between
20 and 20000) using a log scale.

-- Utilities

Range(lo,hi) : clip a value x between lo and hi
Interpolator(lo,hi,v1,v2) : Maps a value x between lo and hi to a value y between v1 and v2
Interpolator3pt(lo,mi,hi,v1,vm,v2) : Map values between lo mid hi to values between v1 vm v2

-- Value Converters

ValueConverter::ui2faust(x)
ValueConverter::faust2ui(x)

-- ValueConverters used for sliders depending of the scale

LinearValueConverter(umin, umax, fmin, fmax)
LogValueConverter(umin, umax, fmin, fmax)
ExpValueConverter(umin, umax, fmin, fmax)

-- ValueConverters used for accelerometers based on 3 points

AccUpConverter(amin, amid, amax, fmin, fmid, fmax)		-- curve 0
AccDownConverter(amin, amid, amax, fmin, fmid, fmax)	-- curve 1
AccUpDownConverter(amin, amid, amax, fmin, fmid, fmax)	-- curve 2
AccDownUpConverter(amin, amid, amax, fmin, fmid, fmax)	-- curve 3

-- lists of ZoneControl are used to implement accelerometers metadata for each axes

ZoneControl(zone, valueConverter) : a zone with an accelerometer data converter

-- ZoneReader are used to implement screencolor metadata

ZoneReader(zone, valueConverter) : a zone with a data converter

****************************************************************************************/

#include <float.h>
#include <algorithm>    // std::max
#include <cmath>
#include <vector>
#include <assert.h>

//--------------------------------------------------------------------------------------
// Interpolator(lo,hi,v1,v2)
// Maps a value x between lo and hi to a value y between v1 and v2
// y = v1 + (x-lo)/(hi-lo)*(v2-v1)
// y = v1 + (x-lo) * coef   		with coef = (v2-v1)/(hi-lo)
// y = v1 + x*coef - lo*coef
// y = v1 - lo*coef + x*coef
// y = offset + x*coef				with offset = v1 - lo*coef
//--------------------------------------------------------------------------------------
class Interpolator
{
    private:

        //--------------------------------------------------------------------------------------
        // Range(lo,hi) clip a value between lo and hi
        //--------------------------------------------------------------------------------------
        struct Range
        {
            double fLo;
            double fHi;

            Range(double x, double y) : fLo(std::min<double>(x,y)), fHi(std::max<double>(x,y)) {}
            double operator()(double x) { return (x<fLo) ? fLo : (x>fHi) ? fHi : x; }
        };


        Range fRange;
        double fCoef;
        double fOffset;

    public:

        Interpolator(double lo, double hi, double v1, double v2) : fRange(lo,hi)
        {
            if (hi != lo) {
                // regular case
                fCoef = (v2-v1)/(hi-lo);
                fOffset = v1 - lo*fCoef;
            } else {
                // degenerate case, avoids division by zero
                fCoef = 0;
                fOffset = (v1+v2)/2;
            }
        }
        double operator()(double v)
        {
            double x = fRange(v);
            return  fOffset + x*fCoef;
        }

        void getLowHigh(double& amin, double& amax)
        {
            amin = fRange.fLo;
            amax = fRange.fHi;
        }
};

//--------------------------------------------------------------------------------------
// Interpolator3pt(lo,mi,hi,v1,vm,v2)
// Map values between lo mid hi to values between v1 vm v2
//--------------------------------------------------------------------------------------
class Interpolator3pt
{

    private:

        Interpolator fSegment1;
        Interpolator fSegment2;
        double fMid;

    public:

        Interpolator3pt(double lo, double mi, double hi, double v1, double vm, double v2) :
            fSegment1(lo, mi, v1, vm),
            fSegment2(mi, hi, vm, v2),
            fMid(mi) {}
        double operator()(double x) { return  (x < fMid) ? fSegment1(x) : fSegment2(x); }

        void getMappingValues(double& amin, double& amid, double& amax)
        {
            fSegment1.getLowHigh(amin, amid);
            fSegment2.getLowHigh(amid, amax);
        }
};

//--------------------------------------------------------------------------------------
// Abstract ValueConverter class. Converts values between UI and Faust representations
//--------------------------------------------------------------------------------------
class ValueConverter
{

    public:

        virtual ~ValueConverter() {}
        virtual double ui2faust(double x) = 0;
        virtual double faust2ui(double x) = 0;
};

//--------------------------------------------------------------------------------------
// Linear conversion between ui and Faust values
//--------------------------------------------------------------------------------------
class LinearValueConverter : public ValueConverter
{

    private:

        Interpolator fUI2F;
        Interpolator fF2UI;

    public:

        LinearValueConverter(double umin, double umax, double fmin, double fmax) :
            fUI2F(umin,umax,fmin,fmax), fF2UI(fmin,fmax,umin,umax)
        {}

        LinearValueConverter() :
            fUI2F(0.,0.,0.,0.), fF2UI(0.,0.,0.,0.)
        {}
        virtual double ui2faust(double x) {	return fUI2F(x); }
        virtual double faust2ui(double x) {	return fF2UI(x); }

};

//--------------------------------------------------------------------------------------
// Logarithmic conversion between ui and Faust values
//--------------------------------------------------------------------------------------
class LogValueConverter : public LinearValueConverter
{

    public:

        LogValueConverter(double umin, double umax, double fmin, double fmax) :
        LinearValueConverter(umin, umax, log(std::max<double>(DBL_MIN, fmin)), std::log(std::max<double>(DBL_MIN, fmax)))
        {}

        virtual double ui2faust(double x) 	{ return std::exp(LinearValueConverter::ui2faust(x)); }
        virtual double faust2ui(double x)	{ return LinearValueConverter::faust2ui(std::log(std::max<double>(x, DBL_MIN))); }

};

//--------------------------------------------------------------------------------------
// Exponential conversion between ui and Faust values
//--------------------------------------------------------------------------------------
class ExpValueConverter : public LinearValueConverter
{

    public:

        ExpValueConverter(double umin, double umax, double fmin, double fmax) :
            LinearValueConverter(umin, umax, exp(fmin), exp(fmax))
        {}

        virtual double ui2faust(double x) { return std::log(LinearValueConverter::ui2faust(x)); }
        virtual double faust2ui(double x) { return LinearValueConverter::faust2ui(std::exp(x)); }

};

//--------------------------------------------------------------------------------------
// A converter than can be updated
//--------------------------------------------------------------------------------------

class UpdatableValueConverter : public ValueConverter {

    protected:

        bool fActive;

    public:

        UpdatableValueConverter():fActive(true)
        {}
        virtual ~UpdatableValueConverter()
        {}

        virtual void setMappingValues(double amin, double amid, double amax, double min, double init, double max) = 0;
        virtual void getMappingValues(double& amin, double& amid, double& amax) = 0;

        void setActive(bool on_off) { fActive = on_off; }
        bool getActive() { return fActive; }

};

//--------------------------------------------------------------------------------------
// Convert accelerometer or gyroscope values to Faust values
// Using an Up curve (curve 0)
//--------------------------------------------------------------------------------------
class AccUpConverter : public UpdatableValueConverter
{

    private:

        Interpolator3pt fA2F;
        Interpolator3pt fF2A;

    public:

        AccUpConverter(double amin, double amid, double amax, double fmin, double fmid, double fmax) :
            fA2F(amin,amid,amax,fmin,fmid,fmax),
            fF2A(fmin,fmid,fmax,amin,amid,amax)
        {}

        virtual double ui2faust(double x)	{ return fA2F(x); }
        virtual double faust2ui(double x)	{ return fF2A(x); }

        virtual void setMappingValues(double amin, double amid, double amax, double fmin, double fmid, double fmax)
        {
            //__android_log_print(ANDROID_LOG_ERROR, "Faust", "AccUpConverter update %f %f %f %f %f %f", amin,amid,amax,fmin,fmid,fmax);
            fA2F = Interpolator3pt(amin,amid,amax,fmin,fmid,fmax);
            fF2A = Interpolator3pt(fmin,fmid,fmax,amin,amid,amax);
        }

        virtual void getMappingValues(double& amin, double& amid, double& amax)
        {
            fA2F.getMappingValues(amin, amid, amax);
        }

};

//--------------------------------------------------------------------------------------
// Convert accelerometer or gyroscope values to Faust values
// Using a Down curve (curve 1)
//--------------------------------------------------------------------------------------
class AccDownConverter : public UpdatableValueConverter
{

    private:

        Interpolator3pt	fA2F;
        Interpolator3pt	fF2A;

    public:

        AccDownConverter(double amin, double amid, double amax, double fmin, double fmid, double fmax) :
            fA2F(amin,amid,amax,fmax,fmid,fmin),
            fF2A(fmin,fmid,fmax,amax,amid,amin)
        {}

        virtual double ui2faust(double x)	{ return fA2F(x); }
        virtual double faust2ui(double x)	{ return fF2A(x); }

        virtual void setMappingValues(double amin, double amid, double amax, double fmin, double fmid, double fmax)
        {
             //__android_log_print(ANDROID_LOG_ERROR, "Faust", "AccDownConverter update %f %f %f %f %f %f", amin,amid,amax,fmin,fmid,fmax);
            fA2F = Interpolator3pt(amin,amid,amax,fmax,fmid,fmin);
            fF2A = Interpolator3pt(fmin,fmid,fmax,amax,amid,amin);
        }

        virtual void getMappingValues(double& amin, double& amid, double& amax)
        {
            fA2F.getMappingValues(amin, amid, amax);
        }
};

//--------------------------------------------------------------------------------------
// Convert accelerometer or gyroscope values to Faust values
// Using an Up-Down curve (curve 2)
//--------------------------------------------------------------------------------------
class AccUpDownConverter : public UpdatableValueConverter
{

    private:

        Interpolator3pt	fA2F;
        Interpolator fF2A;

    public:

        AccUpDownConverter(double amin, double amid, double amax, double fmin, double fmid, double fmax) :
            fA2F(amin,amid,amax,fmin,fmax,fmin),
            fF2A(fmin,fmax,amin,amax)				// Special, pseudo inverse of a non monotone function
        {}

        virtual double ui2faust(double x)	{ return fA2F(x); }
        virtual double faust2ui(double x)	{ return fF2A(x); }

        virtual void setMappingValues(double amin, double amid, double amax, double fmin, double fmid, double fmax)
        {
             //__android_log_print(ANDROID_LOG_ERROR, "Faust", "AccUpDownConverter update %f %f %f %f %f %f", amin,amid,amax,fmin,fmid,fmax);
            fA2F = Interpolator3pt(amin,amid,amax,fmin,fmax,fmin);
            fF2A = Interpolator(fmin,fmax,amin,amax);
        }

        virtual void getMappingValues(double& amin, double& amid, double& amax)
        {
            fA2F.getMappingValues(amin, amid, amax);
        }
};

//--------------------------------------------------------------------------------------
// Convert accelerometer or gyroscope values to Faust values
// Using a Down-Up curve (curve 3)
//--------------------------------------------------------------------------------------
class AccDownUpConverter : public UpdatableValueConverter
{

    private:

        Interpolator3pt	fA2F;
        Interpolator fF2A;

    public:

        AccDownUpConverter(double amin, double amid, double amax, double fmin, double fmid, double fmax) :
            fA2F(amin,amid,amax,fmax,fmin,fmax),
            fF2A(fmin,fmax,amin,amax)				// Special, pseudo inverse of a non monotone function
        {}

        virtual double ui2faust(double x)	{ return fA2F(x); }
        virtual double faust2ui(double x)	{ return fF2A(x); }

        virtual void setMappingValues(double amin, double amid, double amax, double fmin, double fmid, double fmax)
        {
            //__android_log_print(ANDROID_LOG_ERROR, "Faust", "AccDownUpConverter update %f %f %f %f %f %f", amin,amid,amax,fmin,fmid,fmax);
            fA2F = Interpolator3pt(amin,amid,amax,fmax,fmin,fmax);
            fF2A = Interpolator(fmin,fmax,amin,amax);
        }

        virtual void getMappingValues(double& amin, double& amid, double& amax)
        {
            fA2F.getMappingValues(amin, amid, amax);
        }
};

//--------------------------------------------------------------------------------------
// Base class for ZoneControl
//--------------------------------------------------------------------------------------
class ZoneControl
{

    protected:

        FAUSTFLOAT*	fZone;

    public:

        ZoneControl(FAUSTFLOAT* zone) : fZone(zone) {}
        virtual ~ZoneControl() {}

        virtual void update(double v) {}

        virtual void setMappingValues(int curve, double amin, double amid, double amax, double min, double init, double max) {}
        virtual void getMappingValues(double& amin, double& amid, double& amax) {}

        FAUSTFLOAT* getZone() { return fZone; }

        virtual void setActive(bool on_off) {}
        virtual bool getActive() { return false; }

        virtual int getCurve() { return -1; }

};

//--------------------------------------------------------------------------------------
//  Useful to implement accelerometers metadata as a list of ZoneControl for each axes
//--------------------------------------------------------------------------------------
class ConverterZoneControl : public ZoneControl
{

    private:

        ValueConverter* fValueConverter;

    public:

        ConverterZoneControl(FAUSTFLOAT* zone, ValueConverter* valueConverter) : ZoneControl(zone), fValueConverter(valueConverter) {}
        virtual ~ConverterZoneControl() { delete fValueConverter; } // Assuming fValueConverter is not kept elsewhere...

        void update(double v) { *fZone = fValueConverter->ui2faust(v); }

        ValueConverter* getConverter() { return fValueConverter; }

};

//--------------------------------------------------------------------------------------
// Association of a zone and a four value converter, each one for each possible curve.
// Useful to implement accelerometers metadata as a list of ZoneControl for each axes
//--------------------------------------------------------------------------------------
class CurveZoneControl : public ZoneControl
{

    private:

        std::vector<UpdatableValueConverter*> fValueConverters;
        int fCurve;

    public:

        CurveZoneControl(FAUSTFLOAT* zone, int curve, double amin, double amid, double amax, double min, double init, double max) : ZoneControl(zone), fCurve(0)
        {
            assert(curve >= 0 && curve <= 3);
            fValueConverters.push_back(new AccUpConverter(amin, amid, amax, min, init, max));
            fValueConverters.push_back(new AccDownConverter(amin, amid, amax, min, init, max));
            fValueConverters.push_back(new AccUpDownConverter(amin, amid, amax, min, init, max));
            fValueConverters.push_back(new AccDownUpConverter(amin, amid, amax, min, init, max));
            fCurve = curve;
        }
        virtual ~CurveZoneControl()
        {
            std::vector<UpdatableValueConverter*>::iterator it;
            for (it = fValueConverters.begin(); it != fValueConverters.end(); it++) {
                delete(*it);
            }
        }
        void update(double v) { if (fValueConverters[fCurve]->getActive()) *fZone = fValueConverters[fCurve]->ui2faust(v); }

        void setMappingValues(int curve, double amin, double amid, double amax, double min, double init, double max)
        {
            fValueConverters[curve]->setMappingValues(amin, amid, amax, min, init, max);
            fCurve = curve;
        }

        void getMappingValues(double& amin, double& amid, double& amax)
        {
            fValueConverters[fCurve]->getMappingValues(amin, amid, amax);
        }

        void setActive(bool on_off)
        {
            std::vector<UpdatableValueConverter*>::iterator it;
            for (it = fValueConverters.begin(); it != fValueConverters.end(); it++) {
                (*it)->setActive(on_off);
            }
        }

        int getCurve() { return fCurve; }
};

class ZoneReader
{

    private:

        FAUSTFLOAT* fZone;
        Interpolator fInterpolator;

    public:

        ZoneReader(FAUSTFLOAT* zone, double lo, double hi) : fZone(zone), fInterpolator(lo, hi, 0, 255) {}

        virtual ~ZoneReader() {}

        int getValue()
        {
            if (fZone != 0) {
                return (int)fInterpolator(*fZone);
            } else {
                return 127;
            }
        }

};

#endif
/**************************  END  ValueConverter.h **************************/

#ifdef _MSC_VER
#define gsscanf sscanf_s
#else
#define gsscanf sscanf
#endif

/*****************************************************************************
* Helper code for MIDI meta and polyphonic 'nvoices' parsing
******************************************************************************/

struct MidiMeta : public Meta, public std::map<std::string, std::string>
{
    void declare(const char* key, const char* value)
    {
        (*this)[key] = value;
    }
    
    const std::string get(const char* key, const char* def)
    {
        if (this->find(key) != this->end()) {
            return (*this)[key];
        } else {
            return def;
        }
    }
    
    static void analyse(dsp* mono_dsp, bool& midi_sync, int& nvoices)
    {
        JSONUI jsonui;
        mono_dsp->buildUserInterface(&jsonui);
        std::string json = jsonui.JSON();
        midi_sync = ((json.find("midi") != std::string::npos) &&
                     ((json.find("start") != std::string::npos) ||
                      (json.find("stop") != std::string::npos) ||
                      (json.find("clock") != std::string::npos) ||
                      (json.find("timestamp") != std::string::npos)));
    
    #if defined(NVOICES) && NVOICES!=NUM_VOICES
        nvoices = NVOICES;
    #else
        MidiMeta meta;
        mono_dsp->metadata(&meta);
        bool found_voices = false;
        // If "options" metadata is used
        std::string options = meta.get("options", "");
        if (options != "") {
            std::map<std::string, std::string> metadata;
            std::string res;
            MetaDataUI::extractMetadata(options, res, metadata);
            if (metadata.find("nvoices") != metadata.end()) {
                nvoices = std::atoi(metadata["nvoices"].c_str());
                found_voices = true;
            }
        }
        // Otherwise test for "nvoices" metadata
        if (!found_voices) {
            std::string numVoices = meta.get("nvoices", "0");
            nvoices = std::atoi(numVoices.c_str());
        }
        nvoices = std::max<int>(0, nvoices);
    #endif
    }
    
    static bool checkPolyphony(dsp* mono_dsp)
    {
        MapUI map_ui;
        mono_dsp->buildUserInterface(&map_ui);
        bool has_freq = false;
        bool has_gate = false;
        bool has_gain = false;
        for (int i = 0; i < map_ui.getParamsCount(); i++) {
            std::string path = map_ui.getParamAddress(i);
            has_freq |= MapUI::endsWith(path, "/freq");
            has_gate |= MapUI::endsWith(path, "/gate");
            has_gain |= MapUI::endsWith(path, "/gain");
        }
        return (has_freq && has_gate && has_gain);
    }
    
};

/*******************************************************************************
 * MidiUI : Faust User Interface
 * This class decodes MIDI meta data and maps incoming MIDI messages to them.
 * Currently ctrl, keyon/keyoff, keypress, pgm, chanpress, pitchwheel/pitchbend
 * start/stop/clock meta data is handled.
 ******************************************************************************/

class uiMidi {
    
    protected:
        
        midi* fMidiOut;
        bool fInputCtrl;
        
    public:
        
        uiMidi(midi* midi_out, bool input):fMidiOut(midi_out), fInputCtrl(input)
        {}
        virtual ~uiMidi()
        {}
    
};

/*****************************************************************************
 * Base class for MIDI aware UI items
 ******************************************************************************/

class uiMidiItem : public uiMidi, public uiItem {
    
    public:
        
        uiMidiItem(midi* midi_out, GUI* ui, FAUSTFLOAT* zone, bool input = true)
            :uiMidi(midi_out, input), uiItem(ui, zone)
        {}
        virtual ~uiMidiItem()
        {}
    
        virtual void reflectZone() {}
    
};

/*****************************************************************************
 * Base class for MIDI aware UI items with timestamp support
 ******************************************************************************/

class uiMidiTimedItem : public uiMidi, public uiTimedItem {
    
    public:
        
        uiMidiTimedItem(midi* midi_out, GUI* ui, FAUSTFLOAT* zone, bool input = true)
            :uiMidi(midi_out, input), uiTimedItem(ui, zone)
        {}
        virtual ~uiMidiTimedItem()
        {}
    
        virtual void reflectZone() {}
    
};

//-------------
// MIDI sync
//-------------

class uiMidiStart : public uiMidiTimedItem
{
  
    public:
    
        uiMidiStart(midi* midi_out, GUI* ui, FAUSTFLOAT* zone, bool input = true)
            :uiMidiTimedItem(midi_out, ui, zone, input)
        {}
        virtual ~uiMidiStart()
        {}
        
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            if (v != FAUSTFLOAT(0)) {
                fMidiOut->startSync(0);
            }
        }
        void modifyZone(double date, FAUSTFLOAT v)
        {
            if (fInputCtrl) {
                uiItem::modifyZone(FAUSTFLOAT(v));
            }
        }
        
};

class uiMidiStop : public uiMidiTimedItem
{
  
    public:
    
        uiMidiStop(midi* midi_out, GUI* ui, FAUSTFLOAT* zone, bool input = true)
            :uiMidiTimedItem(midi_out, ui, zone, input)
        {}
        virtual ~uiMidiStop()
        {}
        
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            if (v != FAUSTFLOAT(1)) {
                fMidiOut->stopSync(0);
            }
        }
    
        void modifyZone(double date, FAUSTFLOAT v)
        {
            if (fInputCtrl) {
                uiItem::modifyZone(FAUSTFLOAT(v));
            }
        }
};

class uiMidiClock : public uiMidiTimedItem
{

    private:
        
        bool fState;
  
    public:
    
        uiMidiClock(midi* midi_out, GUI* ui, FAUSTFLOAT* zone, bool input = true)
            :uiMidiTimedItem(midi_out, ui, zone, input), fState(false)
        {}
        virtual ~uiMidiClock()
        {}
    
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            fMidiOut->clock(0);
        }
    
        void modifyZone(double date, FAUSTFLOAT v)
        {
            if (fInputCtrl) {
                fState = !fState;
                uiMidiTimedItem::modifyZone(date, FAUSTFLOAT(fState));
            }
        }

};

//----------------------
// Standard MIDI events
//----------------------

class uiMidiProgChange : public uiMidiTimedItem
{
    
    private:
        
        int fPgm;
  
    public:
    
        uiMidiProgChange(midi* midi_out, int pgm, GUI* ui, FAUSTFLOAT* zone, bool input = true)
            :uiMidiTimedItem(midi_out, ui, zone, input), fPgm(pgm)
        {}
        virtual ~uiMidiProgChange()
        {}
        
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            if (v != FAUSTFLOAT(0)) {
                fMidiOut->progChange(0, fPgm);
            }
        }
        
};

class uiMidiChanPress : public uiMidiTimedItem
{
    private:
        
        int fPress;
  
    public:
    
        uiMidiChanPress(midi* midi_out, int press, GUI* ui, FAUSTFLOAT* zone, bool input = true)
            :uiMidiTimedItem(midi_out, ui, zone, input), fPress(press)
        {}
        virtual ~uiMidiChanPress()
        {}
        
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            if (v != FAUSTFLOAT(0)) {
                fMidiOut->chanPress(0, fPress);
            }
        }
        
};

class uiMidiCtrlChange : public uiMidiTimedItem
{
    private:
    
        int fCtrl;
        LinearValueConverter fConverter;
 
    public:
    
        uiMidiCtrlChange(midi* midi_out, int ctrl, GUI* ui, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max, bool input = true)
            :uiMidiTimedItem(midi_out, ui, zone, input), fCtrl(ctrl), fConverter(0., 127., double(min), double(max))
        {}
        virtual ~uiMidiCtrlChange()
        {}
        
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            fMidiOut->ctrlChange(0, fCtrl, fConverter.faust2ui(v));
        }
        
        void modifyZone(FAUSTFLOAT v)
        { 
            if (fInputCtrl) {
                uiItem::modifyZone(FAUSTFLOAT(fConverter.ui2faust(v)));
            }
        }
    
        void modifyZone(double date, FAUSTFLOAT v)
        {
            if (fInputCtrl) {
                uiMidiTimedItem::modifyZone(date, FAUSTFLOAT(fConverter.ui2faust(v)));
            }
        }
 
};

class uiMidiPitchWheel : public uiMidiTimedItem
{

    private:
    	
		// currently, the range is of pitchwheel if fixed (-2/2 semitones)
        FAUSTFLOAT wheel2bend(float v)
        {
            return std::pow(2.0,(v/16383.0*4-2)/12);
        }

        int bend2wheel(float v)
        {
            return (int)((12*std::log(v)/std::log(2.0)+2)/4*16383);
        }
 
    public:
    
        uiMidiPitchWheel(midi* midi_out, GUI* ui, FAUSTFLOAT* zone, bool input = true)
            :uiMidiTimedItem(midi_out, ui, zone, input)
        {}
        virtual ~uiMidiPitchWheel()
        {}
        
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            fMidiOut->pitchWheel(0, bend2wheel(v));
        }
        
        void modifyZone(FAUSTFLOAT v)
        { 
            if (fInputCtrl) {
                uiItem::modifyZone(wheel2bend(v));
            }
        }
    
        void modifyZone(double date, FAUSTFLOAT v)
        {
            if (fInputCtrl) {
                uiMidiTimedItem::modifyZone(date, wheel2bend(v));
            }
        }
 
};

class uiMidiKeyOn : public uiMidiTimedItem
{

    private:
        
        int fKeyOn;
        LinearValueConverter fConverter;
  
    public:
    
        uiMidiKeyOn(midi* midi_out, int key, GUI* ui, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max, bool input = true)
            :uiMidiTimedItem(midi_out, ui, zone, input), fKeyOn(key), fConverter(0., 127., double(min), double(max))
        {}
        virtual ~uiMidiKeyOn()
        {}
        
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            fMidiOut->keyOn(0, fKeyOn, fConverter.faust2ui(v));
        }
        
        void modifyZone(FAUSTFLOAT v)
        { 
            if (fInputCtrl) {
                uiItem::modifyZone(FAUSTFLOAT(fConverter.ui2faust(v)));
            }
        }
    
        void modifyZone(double date, FAUSTFLOAT v)
        {
            if (fInputCtrl) {
                uiMidiTimedItem::modifyZone(date, FAUSTFLOAT(fConverter.ui2faust(v)));
            }
        }
    
};

class uiMidiKeyOff : public uiMidiTimedItem
{

    private:
        
        int fKeyOff;
        LinearValueConverter fConverter;
  
    public:
    
        uiMidiKeyOff(midi* midi_out, int key, GUI* ui, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max, bool input = true)
            :uiMidiTimedItem(midi_out, ui, zone, input), fKeyOff(key), fConverter(0., 127., double(min), double(max))
        {}
        virtual ~uiMidiKeyOff()
        {}
        
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            fMidiOut->keyOff(0, fKeyOff, fConverter.faust2ui(v));
        }
        
        void modifyZone(FAUSTFLOAT v)
        { 
            if (fInputCtrl) {
                uiItem::modifyZone(FAUSTFLOAT(fConverter.ui2faust(v)));
            }
        }
    
        void modifyZone(double date, FAUSTFLOAT v)
        {
            if (fInputCtrl) {
                uiMidiTimedItem::modifyZone(date, FAUSTFLOAT(fConverter.ui2faust(v)));
            }
        }
    
};

class uiMidiKeyPress : public uiMidiTimedItem
{

    private:
    
        int fKey;
        LinearValueConverter fConverter;
  
    public:
    
        uiMidiKeyPress(midi* midi_out, int key, GUI* ui, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max, bool input = true)
            :uiMidiTimedItem(midi_out, ui, zone, input), fKey(key), fConverter(0., 127., double(min), double(max))
        {}
        virtual ~uiMidiKeyPress()
        {}
        
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            fMidiOut->keyPress(0, fKey, fConverter.faust2ui(v));
        }
        
        void modifyZone(FAUSTFLOAT v)
        { 
            if (fInputCtrl) {
                uiItem::modifyZone(FAUSTFLOAT(fConverter.ui2faust(v)));
            }
        }
    
        void modifyZone(double date, FAUSTFLOAT v)
        {
            if (fInputCtrl) {
                uiMidiTimedItem::modifyZone(date, FAUSTFLOAT(fConverter.ui2faust(v)));
            }
        }
    
};

class MapUI;

/******************************************************************************************
 * MidiUI : Faust User Interface
 * This class decodes MIDI metadata and maps incoming MIDI messages to them.
 * Currently ctrl, keyon/keyoff, keypress, pgm, chanpress, pitchwheel/pitchbend
 * start/stop/clock meta data are handled.
 *
 * Maps associating MIDI event ID (like each ctrl number) with all MIDI aware UI items
 * are defined and progressively filled when decoding MIDI related metadata.
 * MIDI aware UI items are used in both directions:
 *  - modifying their internal state when receving MIDI input events
 *  - sending their internal state as MIDI output events
 *******************************************************************************************/

class MidiUI : public GUI, public midi
{

    protected:
    
        std::map <int, std::vector<uiMidiCtrlChange*> > fCtrlChangeTable;
        std::map <int, std::vector<uiMidiProgChange*> > fProgChangeTable;
        std::map <int, std::vector<uiMidiChanPress*> >  fChanPressTable;
        std::map <int, std::vector<uiMidiKeyOn*> >      fKeyOnTable;
        std::map <int, std::vector<uiMidiKeyOff*> >     fKeyOffTable;
        std::map <int, std::vector<uiMidiKeyOn*> >      fKeyTable;
        std::map <int, std::vector<uiMidiKeyPress*> >   fKeyPressTable;
        std::vector<uiMidiPitchWheel*>                  fPitchWheelTable;
        
        std::vector<uiMidiStart*>   fStartTable;
        std::vector<uiMidiStop*>    fStopTable;
        std::vector<uiMidiClock*>   fClockTable;
        
        std::vector<std::pair <std::string, std::string> > fMetaAux;
        
        midi_handler* fMidiHandler;
        bool fDelete;
        bool fTimeStamp;
    
        void addGenericZone(FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max, bool input = true)
        {
            if (fMetaAux.size() > 0) {
                for (size_t i = 0; i < fMetaAux.size(); i++) {
                    unsigned num;
                    if (fMetaAux[i].first == "midi") {
                        if (gsscanf(fMetaAux[i].second.c_str(), "ctrl %u", &num) == 1) {
                            fCtrlChangeTable[num].push_back(new uiMidiCtrlChange(fMidiHandler, num, this, zone, min, max, input));
                        } else if (gsscanf(fMetaAux[i].second.c_str(), "keyon %u", &num) == 1) {
                            fKeyOnTable[num].push_back(new uiMidiKeyOn(fMidiHandler, num, this, zone, min, max, input));
                        } else if (gsscanf(fMetaAux[i].second.c_str(), "keyoff %u", &num) == 1) {
                            fKeyOffTable[num].push_back(new uiMidiKeyOff(fMidiHandler, num, this, zone, min, max, input));
                        } else if (gsscanf(fMetaAux[i].second.c_str(), "key %u", &num) == 1) {
                            fKeyTable[num].push_back(new uiMidiKeyOn(fMidiHandler, num, this, zone, min, max, input));
                        } else if (gsscanf(fMetaAux[i].second.c_str(), "keypress %u", &num) == 1) {
                            fKeyPressTable[num].push_back(new uiMidiKeyPress(fMidiHandler, num, this, zone, min, max, input));
                        } else if (gsscanf(fMetaAux[i].second.c_str(), "pgm %u", &num) == 1) {
                            fProgChangeTable[num].push_back(new uiMidiProgChange(fMidiHandler, num, this, zone, input));
                        } else if (gsscanf(fMetaAux[i].second.c_str(), "chanpress %u", &num) == 1) {
                            fChanPressTable[num].push_back(new uiMidiChanPress(fMidiHandler, num, this, zone, input));
                        } else if (fMetaAux[i].second == "pitchwheel" || fMetaAux[i].second == "pitchbend") {
                            fPitchWheelTable.push_back(new uiMidiPitchWheel(fMidiHandler, this, zone, input));
                        // MIDI sync
                        } else if (fMetaAux[i].second == "start") {
                            fStartTable.push_back(new uiMidiStart(fMidiHandler, this, zone, input));
                        } else if (fMetaAux[i].second == "stop") {
                            fStopTable.push_back(new uiMidiStop(fMidiHandler, this, zone, input));
                        } else if (fMetaAux[i].second == "clock") {
                            fClockTable.push_back(new uiMidiClock(fMidiHandler, this, zone, input));
                        // Explicit metadata to activate 'timestamp' mode
                        } else if (fMetaAux[i].second == "timestamp") {
                            fTimeStamp = true;
                        }
                    }
                }
            }
            fMetaAux.clear();
        }

    public:
    
        MidiUI():fMidiHandler(NULL), fDelete(false), fTimeStamp(false)
        {}

        MidiUI(midi_handler* midi_handler, bool delete_handler = false)
        {
            fMidiHandler = midi_handler;
            fMidiHandler->addMidiIn(this);
            fDelete = delete_handler;
            fTimeStamp = false;
        }
 
        virtual ~MidiUI() 
        { 
            fMidiHandler->removeMidiIn(this);
            if (fDelete) delete fMidiHandler;
        }
        
        bool run() { return fMidiHandler->startMidi(); }
        void stop() { fMidiHandler->stopMidi(); }
        
        void addMidiIn(midi* midi_dsp) { fMidiHandler->addMidiIn(midi_dsp); }
        void removeMidiIn(midi* midi_dsp) { fMidiHandler->removeMidiIn(midi_dsp); }
      
        // -- active widgets
        
        virtual void addButton(const char* label, FAUSTFLOAT* zone)
        {
            addGenericZone(zone, FAUSTFLOAT(0), FAUSTFLOAT(1));
        }
        virtual void addCheckButton(const char* label, FAUSTFLOAT* zone)
        {
            addGenericZone(zone, FAUSTFLOAT(0), FAUSTFLOAT(1));
        }
        
        virtual void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        {
            addGenericZone(zone, min, max);
        }
        virtual void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        {
            addGenericZone(zone, min, max);
        }
        virtual void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        {
            addGenericZone(zone, min, max);
        }

        // -- passive widgets

        virtual void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) 
        {
            addGenericZone(zone, min, max, false);
        }
        virtual void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
        {
            addGenericZone(zone, min, max, false);
        }

        // -- metadata declarations

        virtual void declare(FAUSTFLOAT* zone, const char* key, const char* val)
        {
            fMetaAux.push_back(std::make_pair(key, val));
        }
        
        // -- MIDI API 
        
        MapUI* keyOn(double date, int channel, int note, int velocity)
        {
            if (fKeyOnTable.find(note) != fKeyOnTable.end()) {
                if (fTimeStamp) {
                    for (unsigned int i = 0; i < fKeyOnTable[note].size(); i++) {
                        fKeyOnTable[note][i]->modifyZone(date, FAUSTFLOAT(velocity));
                    }
                } else {
                    for (unsigned int i = 0; i < fKeyOnTable[note].size(); i++) {
                        fKeyOnTable[note][i]->modifyZone(FAUSTFLOAT(velocity));
                    }
                }
            }
            // If note is in fKeyTable, handle it as a keyOn
            if (fKeyTable.find(note) != fKeyTable.end()) {
                if (fTimeStamp) {
                    for (unsigned int i = 0; i < fKeyTable[note].size(); i++) {
                        fKeyTable[note][i]->modifyZone(date, FAUSTFLOAT(velocity));
                    }
                } else {
                    for (unsigned int i = 0; i < fKeyTable[note].size(); i++) {
                        fKeyTable[note][i]->modifyZone(FAUSTFLOAT(velocity));
                    }
                }
            }
            return 0;
        }
        
        void keyOff(double date, int channel, int note, int velocity)
        {
            if (fKeyOffTable.find(note) != fKeyOffTable.end()) {
                if (fTimeStamp) {
                    for (unsigned int i = 0; i < fKeyOffTable[note].size(); i++) {
                        fKeyOffTable[note][i]->modifyZone(date, FAUSTFLOAT(velocity));
                    }
                } else {
                    for (unsigned int i = 0; i < fKeyOffTable[note].size(); i++) {
                        fKeyOffTable[note][i]->modifyZone(FAUSTFLOAT(velocity));
                    }
                }
            }
            // If note is in fKeyTable, handle it as a keyOff with a 0 velocity
            if (fKeyTable.find(note) != fKeyTable.end()) {
                if (fTimeStamp) {
                    for (unsigned int i = 0; i < fKeyTable[note].size(); i++) {
                        fKeyTable[note][i]->modifyZone(date, 0);
                    }
                } else {
                    for (unsigned int i = 0; i < fKeyTable[note].size(); i++) {
                        fKeyTable[note][i]->modifyZone(0);
                    }
                }
            }
        }
           
        void ctrlChange(double date, int channel, int ctrl, int value)
        {
            if (fCtrlChangeTable.find(ctrl) != fCtrlChangeTable.end()) {
                if (fTimeStamp) {
                    for (unsigned int i = 0; i < fCtrlChangeTable[ctrl].size(); i++) {
                        fCtrlChangeTable[ctrl][i]->modifyZone(date, FAUSTFLOAT(value));
                    }
                } else {
                    for (unsigned int i = 0; i < fCtrlChangeTable[ctrl].size(); i++) {
                        fCtrlChangeTable[ctrl][i]->modifyZone(FAUSTFLOAT(value));
                    }
                }
            }
        }
        
        void progChange(double date, int channel, int pgm)
        {
            if (fProgChangeTable.find(pgm) != fProgChangeTable.end()) {
                if (fTimeStamp) {
                    for (unsigned int i = 0; i < fProgChangeTable[pgm].size(); i++) {
                        fProgChangeTable[pgm][i]->modifyZone(date, FAUSTFLOAT(1));
                    }
                } else {
                    for (unsigned int i = 0; i < fProgChangeTable[pgm].size(); i++) {
                        fProgChangeTable[pgm][i]->modifyZone(FAUSTFLOAT(1));
                    }
                }
            }
        }
        
        void pitchWheel(double date, int channel, int wheel) 
        {
            if (fTimeStamp) {
                for (unsigned int i = 0; i < fPitchWheelTable.size(); i++) {
                    fPitchWheelTable[i]->modifyZone(date, FAUSTFLOAT(wheel));
                }
            } else {
                for (unsigned int i = 0; i < fPitchWheelTable.size(); i++) {
                    fPitchWheelTable[i]->modifyZone(FAUSTFLOAT(wheel));
                }
            }
        }
        
        void keyPress(double date, int channel, int pitch, int press) 
        {
            if (fKeyPressTable.find(pitch) != fKeyPressTable.end()) {
                if (fTimeStamp) {
                    for (unsigned int i = 0; i < fKeyPressTable[pitch].size(); i++) {
                        fKeyPressTable[pitch][i]->modifyZone(date, FAUSTFLOAT(press));
                    }
                } else {
                    for (unsigned int i = 0; i < fKeyPressTable[pitch].size(); i++) {
                        fKeyPressTable[pitch][i]->modifyZone(FAUSTFLOAT(press));
                    }
                }
            }
        }
        
        void chanPress(double date, int channel, int press)
        {
            if (fChanPressTable.find(press) != fChanPressTable.end()) {
                if (fTimeStamp) {
                    for (unsigned int i = 0; i < fChanPressTable[press].size(); i++) {
                        fChanPressTable[press][i]->modifyZone(date, FAUSTFLOAT(1));
                    }
                } else {
                    for (unsigned int i = 0; i < fChanPressTable[press].size(); i++) {
                        fChanPressTable[press][i]->modifyZone(FAUSTFLOAT(1));
                    }
                }
            } 
        }
        
        void ctrlChange14bits(double date, int channel, int ctrl, int value) {}
        
        // MIDI sync
        
        void startSync(double date)
        {
            for (unsigned int i = 0; i < fStartTable.size(); i++) {
                fStartTable[i]->modifyZone(date, FAUSTFLOAT(1));
            }
        }
        
        void stopSync(double date)
        {
            for (unsigned int i = 0; i < fStopTable.size(); i++) {
                fStopTable[i]->modifyZone(date, FAUSTFLOAT(0));
            }
        }
        
        void clock(double date)
        {
            for (unsigned int i = 0; i < fClockTable.size(); i++) {
                fClockTable[i]->modifyZone(date, FAUSTFLOAT(1));
            }
        }
};

#endif // FAUST_MIDIUI_H
/**************************  END  MidiUI.h **************************/
/************************** BEGIN poly-dsp.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __poly_dsp__
#define __poly_dsp__

#include <stdio.h>
#include <string>
#include <cmath>
#include <algorithm>
#include <ostream>
#include <sstream>
#include <vector>
#include <limits.h>
#include <float.h>
#include <assert.h>

/************************** BEGIN dsp-combiner.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2019 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.

 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __dsp_combiner__
#define __dsp_combiner__

#include <string.h>
#include <string>
#include <assert.h>
#include <sstream>


// Base class and common code for binary combiners

class dsp_binary_combiner : public dsp {

    protected:

        dsp* fDSP1;
        dsp* fDSP2;

        void buildUserInterfaceAux(UI* ui_interface, const char* name)
        {
            ui_interface->openTabBox(name);
            ui_interface->openVerticalBox("DSP1");
            fDSP1->buildUserInterface(ui_interface);
            ui_interface->closeBox();
            ui_interface->openVerticalBox("DSP2");
            fDSP2->buildUserInterface(ui_interface);
            ui_interface->closeBox();
            ui_interface->closeBox();
        }

        FAUSTFLOAT** allocateChannels(int num, int buffer_size)
        {
            FAUSTFLOAT** channels = new FAUSTFLOAT*[num];
            for (int chan = 0; chan < num; chan++) {
                channels[chan] = new FAUSTFLOAT[buffer_size];
                memset(channels[chan], 0, sizeof(FAUSTFLOAT) * buffer_size);
            }
            return channels;
        }

        void deleteChannels(FAUSTFLOAT** channels, int num)
        {
            for (int chan = 0; chan < num; chan++) {
                delete [] channels[chan];
            }
            delete [] channels;
        }

     public:

        dsp_binary_combiner(dsp* dsp1, dsp* dsp2):fDSP1(dsp1), fDSP2(dsp2)
        {}

        virtual ~dsp_binary_combiner()
        {
            delete fDSP1;
            delete fDSP2;
        }

        virtual int getSampleRate()
        {
            return fDSP1->getSampleRate();
        }
        virtual void init(int sample_rate)
        {
            fDSP1->init(sample_rate);
            fDSP2->init(sample_rate);
        }
        virtual void instanceInit(int sample_rate)
        {
            fDSP1->instanceInit(sample_rate);
            fDSP2->instanceInit(sample_rate);
        }
        virtual void instanceConstants(int sample_rate)
        {
            fDSP1->instanceConstants(sample_rate);
            fDSP2->instanceConstants(sample_rate);
        }

        virtual void instanceResetUserInterface()
        {
            fDSP1->instanceResetUserInterface();
            fDSP2->instanceResetUserInterface();
        }

        virtual void instanceClear()
        {
            fDSP1->instanceClear();
            fDSP2->instanceClear();
        }

        virtual void metadata(Meta* m)
        {
            fDSP1->metadata(m);
            fDSP2->metadata(m);
        }

};

// Combine two 'compatible' DSP in sequence

class dsp_sequencer : public dsp_binary_combiner {

    private:

        FAUSTFLOAT** fDSP1Outputs;

    public:

        dsp_sequencer(dsp* dsp1, dsp* dsp2, int buffer_size = 4096):dsp_binary_combiner(dsp1, dsp2)
        {
            fDSP1Outputs = allocateChannels(fDSP1->getNumOutputs(), buffer_size);
        }

        virtual ~dsp_sequencer()
        {
            deleteChannels(fDSP1Outputs, fDSP1->getNumOutputs());
        }

        virtual int getNumInputs() { return fDSP1->getNumInputs(); }
        virtual int getNumOutputs() { return fDSP2->getNumOutputs(); }

        virtual void buildUserInterface(UI* ui_interface)
        {
            buildUserInterfaceAux(ui_interface, "Sequencer");
        }

        virtual dsp* clone()
        {
            return new dsp_sequencer(fDSP1->clone(), fDSP2->clone());
        }

        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            fDSP1->compute(count, inputs, fDSP1Outputs);
            fDSP2->compute(count, fDSP1Outputs, outputs);
        }

        virtual void compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { compute(count, inputs, outputs); }

};

// Combine two DSP in parallel

class dsp_parallelizer : public dsp_binary_combiner {

    private:

        FAUSTFLOAT** fDSP2Inputs;
        FAUSTFLOAT** fDSP2Outputs;

    public:

        dsp_parallelizer(dsp* dsp1, dsp* dsp2, int buffer_size = 4096):dsp_binary_combiner(dsp1, dsp2)
        {
            fDSP2Inputs = new FAUSTFLOAT*[fDSP2->getNumInputs()];
            fDSP2Outputs = new FAUSTFLOAT*[fDSP2->getNumOutputs()];
        }

        virtual ~dsp_parallelizer()
        {
            delete [] fDSP2Inputs;
            delete [] fDSP2Outputs;
        }

        virtual int getNumInputs() { return fDSP1->getNumInputs() + fDSP2->getNumInputs(); }
        virtual int getNumOutputs() { return fDSP1->getNumOutputs() + fDSP2->getNumOutputs(); }

        virtual void buildUserInterface(UI* ui_interface)
        {
            buildUserInterfaceAux(ui_interface, "Parallelizer");
        }

        virtual dsp* clone()
        {
            return new dsp_parallelizer(fDSP1->clone(), fDSP2->clone());
        }

        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            fDSP1->compute(count, inputs, outputs);

            // Shift inputs/outputs channels for fDSP2
            for (int chan = 0; chan < fDSP2->getNumInputs(); chan++) {
                fDSP2Inputs[chan] = inputs[fDSP1->getNumInputs() + chan];
            }
            for (int chan = 0; chan < fDSP2->getNumOutputs(); chan++) {
                fDSP2Outputs[chan] = outputs[fDSP1->getNumOutputs() + chan];
            }

            fDSP2->compute(count, fDSP2Inputs, fDSP2Outputs);
        }

        virtual void compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { compute(count, inputs, outputs); }

};

// Combine two 'compatible' DSP in splitter

class dsp_splitter : public dsp_binary_combiner {

    private:

        FAUSTFLOAT** fDSP1Outputs;
        FAUSTFLOAT** fDSP2Inputs;

    public:

        dsp_splitter(dsp* dsp1, dsp* dsp2, int buffer_size = 4096):dsp_binary_combiner(dsp1, dsp2)
        {
            fDSP1Outputs = allocateChannels(fDSP1->getNumOutputs(), buffer_size);
            fDSP2Inputs = new FAUSTFLOAT*[fDSP2->getNumInputs()];
        }

        virtual ~dsp_splitter()
        {
            deleteChannels(fDSP1Outputs, fDSP1->getNumOutputs());
            delete [] fDSP2Inputs;
        }

        virtual int getNumInputs() { return fDSP1->getNumInputs(); }
        virtual int getNumOutputs() { return fDSP2->getNumOutputs(); }

        virtual void buildUserInterface(UI* ui_interface)
        {
            buildUserInterfaceAux(ui_interface, "Splitter");
        }

        virtual dsp* clone()
        {
            return new dsp_splitter(fDSP1->clone(), fDSP2->clone());
        }

        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            fDSP1->compute(count, inputs, fDSP1Outputs);

            for (int chan = 0; chan < fDSP2->getNumInputs(); chan++) {
                 fDSP2Inputs[chan] = fDSP1Outputs[chan % fDSP1->getNumOutputs()];
            }

            fDSP2->compute(count, fDSP2Inputs, outputs);
        }
};

// Combine two 'compatible' DSP in merger

class dsp_merger : public dsp_binary_combiner {

    private:

        FAUSTFLOAT** fDSP1Inputs;
        FAUSTFLOAT** fDSP1Outputs;
        FAUSTFLOAT** fDSP2Inputs;

        void mix(int count, FAUSTFLOAT* dst, FAUSTFLOAT* src)
        {
            for (int frame = 0; frame < count; frame++) {
                dst[frame] += src[frame];
            }
        }

    public:

        dsp_merger(dsp* dsp1, dsp* dsp2, int buffer_size = 4096):dsp_binary_combiner(dsp1, dsp2)
        {
            fDSP1Inputs = allocateChannels(fDSP1->getNumInputs(), buffer_size);
            fDSP1Outputs = allocateChannels(fDSP1->getNumOutputs(), buffer_size);
            fDSP2Inputs = new FAUSTFLOAT*[fDSP2->getNumInputs()];
        }

        virtual ~dsp_merger()
        {
            deleteChannels(fDSP1Inputs, fDSP1->getNumInputs());
            deleteChannels(fDSP1Outputs, fDSP1->getNumOutputs());
            delete [] fDSP2Inputs;
        }

        virtual int getNumInputs() { return fDSP1->getNumInputs(); }
        virtual int getNumOutputs() { return fDSP2->getNumOutputs(); }

        virtual void buildUserInterface(UI* ui_interface)
        {
            buildUserInterfaceAux(ui_interface, "Merge");
        }

        virtual dsp* clone()
        {
            return new dsp_merger(fDSP1->clone(), fDSP2->clone());
        }

        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            fDSP1->compute(count, fDSP1Inputs, fDSP1Outputs);

            memset(fDSP2Inputs, 0, sizeof(FAUSTFLOAT*) * fDSP2->getNumInputs());

            for (int chan = 0; chan < fDSP1->getNumOutputs(); chan++) {
                int mchan = chan % fDSP2->getNumInputs();
                if (fDSP2Inputs[mchan]) {
                    mix(count, fDSP2Inputs[mchan], fDSP1Outputs[chan]);
                } else {
                    fDSP2Inputs[mchan] = fDSP1Outputs[chan];
                }
            }

            fDSP2->compute(count, fDSP2Inputs, outputs);
        }
};

// Combine two 'compatible' DSP in a recursive way

class dsp_recursiver : public dsp_binary_combiner {

    private:

        FAUSTFLOAT** fDSP1Inputs;
        FAUSTFLOAT** fDSP1Outputs;

        FAUSTFLOAT** fDSP2Inputs;
        FAUSTFLOAT** fDSP2Outputs;

    public:

        dsp_recursiver(dsp* dsp1, dsp* dsp2):dsp_binary_combiner(dsp1, dsp2)
        {
            fDSP1Inputs = allocateChannels(fDSP1->getNumInputs(), 1);
            fDSP1Outputs = allocateChannels(fDSP1->getNumOutputs(), 1);
            fDSP2Inputs = allocateChannels(fDSP2->getNumInputs(), 1);
            fDSP2Outputs = allocateChannels(fDSP2->getNumOutputs(), 1);
        }

        virtual ~dsp_recursiver()
        {
            deleteChannels(fDSP1Inputs, fDSP1->getNumInputs());
            deleteChannels(fDSP1Outputs, fDSP1->getNumOutputs());
            deleteChannels(fDSP2Inputs, fDSP2->getNumInputs());
            deleteChannels(fDSP2Outputs, fDSP2->getNumOutputs());
        }

        virtual int getNumInputs() { return fDSP1->getNumInputs() - fDSP2->getNumOutputs(); }
        virtual int getNumOutputs() { return fDSP1->getNumOutputs(); }

        virtual void buildUserInterface(UI* ui_interface)
        {
            buildUserInterfaceAux(ui_interface, "Recursiver");
        }

        virtual dsp* clone()
        {
            return new dsp_recursiver(fDSP1->clone(), fDSP2->clone());
        }

        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            for (int frame = 0; (frame < count); frame++) {

                for (int chan = 0; chan < fDSP2->getNumOutputs(); chan++) {
                    fDSP1Inputs[chan][0] = fDSP2Outputs[chan][0];
                }

                for (int chan = 0; chan < fDSP1->getNumInputs() - fDSP2->getNumOutputs(); chan++) {
                    fDSP1Inputs[chan + fDSP2->getNumOutputs()][0] = inputs[chan][frame];
                }

                fDSP1->compute(1, fDSP1Inputs, fDSP1Outputs);

                for (int chan = 0; chan < fDSP1->getNumOutputs(); chan++) {
                    outputs[chan][frame] = fDSP1Outputs[chan][0];
                }

                for (int chan = 0; chan < fDSP2->getNumInputs(); chan++) {
                    fDSP2Inputs[chan][0] = fDSP1Outputs[chan][0];
                }

                fDSP2->compute(1, fDSP2Inputs, fDSP2Outputs);
            }
        }

        virtual void compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { compute(count, inputs, outputs); }

};

#ifndef __dsp_algebra_api__
#define __dsp_algebra_api__
// DSP algebra API
/*
 Each operation takes two DSP as parameters, returns the combined DSPs, or null if failure with an error message.
 */

static dsp* createDSPSequencer(dsp* dsp1, dsp* dsp2, std::string& error)
{
    if (dsp1->getNumOutputs() != dsp2->getNumInputs()) {
        std::stringstream error_aux;
        error_aux << "Connection error int dsp_sequencer : the number of outputs ("
                  << dsp1->getNumOutputs() << ") of A "
                  << "must be equal to the number of inputs (" << dsp2->getNumInputs() << ") of B" << std::endl;
        error = error_aux.str();
        return nullptr;
    } else {
        return new dsp_sequencer(dsp1, dsp2);
    }
}

static dsp* createDSPParallelize(dsp* dsp1, dsp* dsp2, std::string& error)
{
    return new dsp_parallelizer(dsp1, dsp2);
}

static dsp* createDSPSplitter(dsp* dsp1, dsp* dsp2, std::string& error)
{
    if (dsp1->getNumOutputs() == 0) {
        error = "Connection error in dsp_splitter : the first expression has no outputs\n";
        return nullptr;
    } else if (dsp2->getNumInputs() == 0) {
        error = "Connection error in dsp_splitter : the second expression has no inputs\n";
        return nullptr;
    } else if (dsp2->getNumInputs() % dsp1->getNumOutputs() != 0) {
        std::stringstream error_aux;
        error_aux << "Connection error in dsp_splitter : the number of outputs (" << dsp1->getNumOutputs()
                  << ") of the first expression should be a divisor of the number of inputs ("
                  << dsp2->getNumInputs()
                  << ") of the second expression" << std::endl;
        error = error_aux.str();
        return nullptr;
    } else if (dsp2->getNumInputs() == dsp1->getNumOutputs()) {
        return new dsp_sequencer(dsp1, dsp2);
    } else {
        return new dsp_splitter(dsp1, dsp2);
    }
}

static dsp* createDSPMerger(dsp* dsp1, dsp* dsp2, std::string& error)
{
    if (dsp1->getNumOutputs() == 0) {
        error = "Connection error in dsp_merger : the first expression has no outputs\n";
        return nullptr;
    } else if (dsp2->getNumInputs() == 0) {
        error = "Connection error in dsp_merger : the second expression has no inputs\n";
        return nullptr;
    } else if (dsp1->getNumOutputs() % dsp2->getNumInputs() != 0) {
        std::stringstream error_aux;
        error_aux << "Connection error in dsp_merger : the number of outputs (" << dsp1->getNumOutputs()
                  << ") of the first expression should be a multiple of the number of inputs ("
                  << dsp2->getNumInputs()
                  << ") of the second expression" << std::endl;
        error = error_aux.str();
        return nullptr;
    } else if (dsp2->getNumInputs() == dsp1->getNumOutputs()) {
        return new dsp_sequencer(dsp1, dsp2);
    } else {
        return new dsp_merger(dsp1, dsp2);
    }
}

static dsp* createDSPRecursiver(dsp* dsp1, dsp* dsp2, std::string& error)
{
    if ((dsp2->getNumInputs() > dsp1->getNumOutputs()) || (dsp2->getNumOutputs() > dsp1->getNumInputs())) {
        std::stringstream error_aux;
        error_aux << "Connection error in : dsp_recursiver" << std::endl;
        if (dsp2->getNumInputs() > dsp1->getNumOutputs()) {
            error_aux << "The number of outputs " << dsp1->getNumOutputs()
                      << " of the first expression should be greater or equal to the number of inputs ("
                      << dsp2->getNumInputs()
                      << ") of the second expression" << std::endl;
        }
        if (dsp2->getNumOutputs() > dsp1->getNumInputs()) {
            error_aux << "The number of inputs " << dsp1->getNumInputs()
                      << " of the first expression should be greater or equal to the number of outputs ("
                      << dsp2->getNumOutputs()
                      << ") of the second expression" << std::endl;
        }
        error = error_aux.str();
        return nullptr;
    } else {
        return new dsp_recursiver(dsp1, dsp2);
    }
}
#endif

#endif
/**************************  END  dsp-combiner.h **************************/
/************************** BEGIN proxy-dsp.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __proxy_dsp__
#define __proxy_dsp__

#include <vector>
#include <map>

/************************** BEGIN JSONUIDecoder.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __JSONUIDecoder__
#define __JSONUIDecoder__

#include <vector>
#include <map>
#include <utility>
#include <cstdlib>
#include <sstream>
#include <functional>

/************************** BEGIN CGlue.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2018 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef CGLUE_H
#define CGLUE_H

/************************** BEGIN CInterface.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2018 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef CINTERFACE_H
#define CINTERFACE_H

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif
    
struct Soundfile;

/*******************************************************************************
 * UI and Meta classes for C or LLVM generated code.
 ******************************************************************************/

// -- widget's layouts

typedef void (* openTabBoxFun) (void* ui_interface, const char* label);
typedef void (* openHorizontalBoxFun) (void* ui_interface, const char* label);
typedef void (* openVerticalBoxFun) (void* ui_interface, const char* label);
typedef void (*closeBoxFun) (void* ui_interface);

// -- active widgets

typedef void (* addButtonFun) (void* ui_interface, const char* label, FAUSTFLOAT* zone);
typedef void (* addCheckButtonFun) (void* ui_interface, const char* label, FAUSTFLOAT* zone);
typedef void (* addVerticalSliderFun) (void* ui_interface, const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step);
typedef void (* addHorizontalSliderFun) (void* ui_interface, const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step);
typedef void (* addNumEntryFun) (void* ui_interface, const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step);

// -- passive widgets

typedef void (* addHorizontalBargraphFun) (void* ui_interface, const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max);
typedef void (* addVerticalBargraphFun) (void* ui_interface, const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max);

// -- soundfiles
    
typedef void (* addSoundfileFun) (void* ui_interface, const char* label, const char* url, struct Soundfile** sf_zone);

typedef void (* declareFun) (void* ui_interface, FAUSTFLOAT* zone, const char* key, const char* value);

typedef struct {

    void* uiInterface;

    openTabBoxFun openTabBox;
    openHorizontalBoxFun openHorizontalBox;
    openVerticalBoxFun openVerticalBox;
    closeBoxFun closeBox;
    addButtonFun addButton;
    addCheckButtonFun addCheckButton;
    addVerticalSliderFun addVerticalSlider;
    addHorizontalSliderFun addHorizontalSlider;
    addNumEntryFun addNumEntry;
    addHorizontalBargraphFun addHorizontalBargraph;
    addVerticalBargraphFun addVerticalBargraph;
    addSoundfileFun addSoundfile;
    declareFun declare;

} UIGlue;

typedef void (* metaDeclareFun) (void* ui_interface, const char* key, const char* value);

typedef struct {

    void* metaInterface;
    
    metaDeclareFun declare;

} MetaGlue;

/***************************************
 *  Interface for the DSP object
 ***************************************/

typedef char dsp_imp;
    
typedef dsp_imp* (* newDspFun) ();
typedef void (* deleteDspFun) (dsp_imp* dsp);
typedef void (* allocateDspFun) (dsp_imp* dsp);
typedef void (* destroyDspFun) (dsp_imp* dsp);
typedef int (* getNumInputsFun) (dsp_imp* dsp);
typedef int (* getNumOutputsFun) (dsp_imp* dsp);
typedef void (* buildUserInterfaceFun) (dsp_imp* dsp, UIGlue* ui);
typedef void (* initFun) (dsp_imp* dsp, int sample_rate);
typedef void (* clearFun) (dsp_imp* dsp);
typedef int (* getSampleRateFun) (dsp_imp* dsp);
typedef void (* computeFun) (dsp_imp* dsp, int len, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs);
typedef void (* metadataFun) (MetaGlue* meta);
typedef void (* classInitFun) (int sample_rate);
typedef const char* (* getJSONFun) ();
    
/***************************************
 * DSP memory manager functions
 ***************************************/

typedef void* (* allocateFun) (void* manager_interface, size_t size);
typedef void (* destroyFun) (void* manager_interface, void* ptr);

typedef struct {
    
    void* managerInterface;
    
    allocateFun allocate;
    destroyFun destroy;
    
} ManagerGlue;

#ifdef __cplusplus
}
#endif

#endif
/**************************  END  CInterface.h **************************/

#ifdef __cplusplus
extern "C" {
#endif

/*******************************************************************************
 * UI glue code
 ******************************************************************************/
 
class UIFloat
{

    public:

        UIFloat() {}

        virtual ~UIFloat() {}

        // -- widget's layouts

        virtual void openTabBox(const char* label) = 0;
        virtual void openHorizontalBox(const char* label) = 0;
        virtual void openVerticalBox(const char* label) = 0;
        virtual void closeBox() = 0;

        // -- active widgets

        virtual void addButton(const char* label, float* zone) = 0;
        virtual void addCheckButton(const char* label, float* zone) = 0;
        virtual void addVerticalSlider(const char* label, float* zone, float init, float min, float max, float step) = 0;
        virtual void addHorizontalSlider(const char* label, float* zone, float init, float min, float max, float step) = 0;
        virtual void addNumEntry(const char* label, float* zone, float init, float min, float max, float step) = 0;

        // -- passive widgets

        virtual void addHorizontalBargraph(const char* label, float* zone, float min, float max) = 0;
        virtual void addVerticalBargraph(const char* label, float* zone, float min, float max) = 0;
    
        // -- soundfiles
    
        virtual void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone) = 0;

        // -- metadata declarations

        virtual void declare(float* zone, const char* key, const char* val) {}
};

static void openTabBoxGlueFloat(void* cpp_interface, const char* label)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->openTabBox(label);
}

static void openHorizontalBoxGlueFloat(void* cpp_interface, const char* label)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->openHorizontalBox(label);
}

static void openVerticalBoxGlueFloat(void* cpp_interface, const char* label)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->openVerticalBox(label);
}

static void closeBoxGlueFloat(void* cpp_interface)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->closeBox();
}

static void addButtonGlueFloat(void* cpp_interface, const char* label, float* zone)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->addButton(label, zone);
}

static void addCheckButtonGlueFloat(void* cpp_interface, const char* label, float* zone)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->addCheckButton(label, zone);
}

static void addVerticalSliderGlueFloat(void* cpp_interface, const char* label, float* zone, float init, float min, float max, float step)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->addVerticalSlider(label, zone, init, min, max, step);
}

static void addHorizontalSliderGlueFloat(void* cpp_interface, const char* label, float* zone, float init, float min, float max, float step)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->addHorizontalSlider(label, zone, init, min, max, step);
}

static void addNumEntryGlueFloat(void* cpp_interface, const char* label, float* zone, float init, float min, float max, float step)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->addNumEntry(label, zone, init, min, max, step);
}

static void addHorizontalBargraphGlueFloat(void* cpp_interface, const char* label, float* zone, float min, float max)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->addHorizontalBargraph(label, zone, min, max);
}

static void addVerticalBargraphGlueFloat(void* cpp_interface, const char* label, float* zone, float min, float max)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->addVerticalBargraph(label, zone, min, max);
}
    
static void addSoundfileGlueFloat(void* cpp_interface, const char* label, const char* url, Soundfile** sf_zone)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->addSoundfile(label, url, sf_zone);
}

static void declareGlueFloat(void* cpp_interface, float* zone, const char* key, const char* value)
{
    UIFloat* ui_interface = static_cast<UIFloat*>(cpp_interface);
    ui_interface->declare(zone, key, value);
}

class UIDouble
{

    public:

        UIDouble() {}

        virtual ~UIDouble() {}

        // -- widget's layouts

        virtual void openTabBox(const char* label) = 0;
        virtual void openHorizontalBox(const char* label) = 0;
        virtual void openVerticalBox(const char* label) = 0;
        virtual void closeBox() = 0;

        // -- active widgets

        virtual void addButton(const char* label, double* zone) = 0;
        virtual void addCheckButton(const char* label, double* zone) = 0;
        virtual void addVerticalSlider(const char* label, double* zone, double init, double min, double max, double step) = 0;
        virtual void addHorizontalSlider(const char* label, double* zone, double init, double min, double max, double step) = 0;
        virtual void addNumEntry(const char* label, double* zone, double init, double min, double max, double step) = 0;

        // -- passive widgets

        virtual void addHorizontalBargraph(const char* label, double* zone, double min, double max) = 0;
        virtual void addVerticalBargraph(const char* label, double* zone, double min, double max) = 0;
    
        // -- soundfiles
    
        virtual void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone) = 0;

        // -- metadata declarations

        virtual void declare(double* zone, const char* key, const char* val) {}
};

static void openTabBoxGlueDouble(void* cpp_interface, const char* label)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->openTabBox(label);
}

static void openHorizontalBoxGlueDouble(void* cpp_interface, const char* label)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->openHorizontalBox(label);
}

static void openVerticalBoxGlueDouble(void* cpp_interface, const char* label)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->openVerticalBox(label);
}

static void closeBoxGlueDouble(void* cpp_interface)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->closeBox();
}

static void addButtonGlueDouble(void* cpp_interface, const char* label, double* zone)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->addButton(label, zone);
}

static void addCheckButtonGlueDouble(void* cpp_interface, const char* label, double* zone)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->addCheckButton(label, zone);
}

static void addVerticalSliderGlueDouble(void* cpp_interface, const char* label, double* zone, double init, double min, double max, double step)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->addVerticalSlider(label, zone, init, min, max, step);
}

static void addHorizontalSliderGlueDouble(void* cpp_interface, const char* label, double* zone, double init, double min, double max, double step)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->addHorizontalSlider(label, zone, init, min, max, step);
}

static void addNumEntryGlueDouble(void* cpp_interface, const char* label, double* zone, double init, double min, double max, double step)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->addNumEntry(label, zone, init, min, max, step);
}

static void addHorizontalBargraphGlueDouble(void* cpp_interface, const char* label, double* zone, double min, double max)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->addHorizontalBargraph(label, zone, min, max);
}

static void addVerticalBargraphGlueDouble(void* cpp_interface, const char* label, double* zone, double min, double max)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->addVerticalBargraph(label, zone, min, max);
}
    
static void addSoundfileGlueDouble(void* cpp_interface, const char* label, const char* url, Soundfile** sf_zone)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->addSoundfile(label, url, sf_zone);
}

static void declareGlueDouble(void* cpp_interface, double* zone, const char* key, const char* value)
{
    UIDouble* ui_interface = static_cast<UIDouble*>(cpp_interface);
    ui_interface->declare(zone, key, value);
}

static void buildUIGlue(UIGlue* glue, UI* ui_interface, bool is_double)
{
    glue->uiInterface = ui_interface;
    
    if (is_double) {
        glue->openTabBox = reinterpret_cast<openTabBoxFun>(openTabBoxGlueDouble);
        glue->openHorizontalBox = reinterpret_cast<openHorizontalBoxFun>(openHorizontalBoxGlueDouble);
        glue->openVerticalBox = reinterpret_cast<openVerticalBoxFun>(openVerticalBoxGlueDouble);
        glue->closeBox = reinterpret_cast<closeBoxFun>(closeBoxGlueDouble);
        glue->addButton = reinterpret_cast<addButtonFun>(addButtonGlueDouble);
        glue->addCheckButton = reinterpret_cast<addCheckButtonFun>(addCheckButtonGlueDouble);
        glue->addVerticalSlider = reinterpret_cast<addVerticalSliderFun>(addVerticalSliderGlueDouble);
        glue->addHorizontalSlider = reinterpret_cast<addHorizontalSliderFun>(addHorizontalSliderGlueDouble);
        glue->addNumEntry = reinterpret_cast<addNumEntryFun>(addNumEntryGlueDouble);
        glue->addHorizontalBargraph = reinterpret_cast<addHorizontalBargraphFun>(addHorizontalBargraphGlueDouble);
        glue->addVerticalBargraph = reinterpret_cast<addVerticalBargraphFun>(addVerticalBargraphGlueDouble);
        glue->addSoundfile = reinterpret_cast<addSoundfileFun>(addSoundfileGlueDouble);
        glue->declare = reinterpret_cast<declareFun>(declareGlueDouble);
    } else {
        glue->openTabBox = reinterpret_cast<openTabBoxFun>(openTabBoxGlueFloat);
        glue->openHorizontalBox = reinterpret_cast<openHorizontalBoxFun>(openHorizontalBoxGlueFloat);
        glue->openVerticalBox = reinterpret_cast<openVerticalBoxFun>(openVerticalBoxGlueFloat);
        glue->closeBox = reinterpret_cast<closeBoxFun>(closeBoxGlueFloat);
        glue->addButton = reinterpret_cast<addButtonFun>(addButtonGlueFloat);
        glue->addCheckButton = reinterpret_cast<addCheckButtonFun>(addCheckButtonGlueFloat);
        glue->addVerticalSlider = reinterpret_cast<addVerticalSliderFun>(addVerticalSliderGlueFloat);
        glue->addHorizontalSlider = reinterpret_cast<addHorizontalSliderFun>(addHorizontalSliderGlueFloat);
        glue->addNumEntry = reinterpret_cast<addNumEntryFun>(addNumEntryGlueFloat);
        glue->addHorizontalBargraph = reinterpret_cast<addHorizontalBargraphFun>(addHorizontalBargraphGlueFloat);
        glue->addVerticalBargraph = reinterpret_cast<addVerticalBargraphFun>(addVerticalBargraphGlueFloat);
        glue->addSoundfile = reinterpret_cast<addSoundfileFun>(addSoundfileGlueFloat);
        glue->declare = reinterpret_cast<declareFun>(declareGlueFloat);
    }
}
    
class UITemplate
{
    
    private:
        
        void* fCPPInterface;
        
    public:
        
        UITemplate(void* cpp_interface):fCPPInterface(cpp_interface)
        {}
        
        virtual ~UITemplate() {}
        
        // -- widget's layouts
        
        virtual void openTabBox(const char* label)
        {
            openTabBoxGlueFloat(fCPPInterface, label);
        }
        virtual void openHorizontalBox(const char* label)
        {
            openHorizontalBoxGlueFloat(fCPPInterface, label);
        }
        virtual void openVerticalBox(const char* label)
        {
            openVerticalBoxGlueFloat(fCPPInterface, label);
        }
        virtual void closeBox()
        {
            closeBoxGlueFloat(fCPPInterface);
        }
        
        // float version
        
        // -- active widgets
        
        virtual void addButton(const char* label, float* zone)
        {
            addButtonGlueFloat(fCPPInterface, label, zone);
        }
        virtual void addCheckButton(const char* label, float* zone)
        {
            addCheckButtonGlueFloat(fCPPInterface, label, zone);
        }
        
        virtual void addVerticalSlider(const char* label, float* zone, float init, float min, float max, float step)
        {
            addVerticalSliderGlueFloat(fCPPInterface, label, zone, init, min, max, step);
        }
        
        virtual void addHorizontalSlider(const char* label, float* zone, float init, float min, float max, float step)
        {
            addHorizontalSliderGlueFloat(fCPPInterface, label, zone, init, min, max, step);
        }
        
        virtual void addNumEntry(const char* label, float* zone, float init, float min, float max, float step)
        {
            addNumEntryGlueFloat(fCPPInterface, label, zone, init, min, max, step);
        }
        
        // -- passive widgets
        
        virtual void addHorizontalBargraph(const char* label, float* zone, float min, float max)
        {
            addHorizontalBargraphGlueFloat(fCPPInterface, label, zone, min, max);
        }
        
        virtual void addVerticalBargraph(const char* label, float* zone, float min, float max)
        {
            addVerticalBargraphGlueFloat(fCPPInterface, label, zone, min, max);
        }
    
        // -- metadata declarations
        
        virtual void declare(float* zone, const char* key, const char* val)
        {
            declareGlueFloat(fCPPInterface, zone, key, val);
        }
        
        // double version
        
        virtual void addButton(const char* label, double* zone)
        {
            addButtonGlueDouble(fCPPInterface, label, zone);
        }
        virtual void addCheckButton(const char* label, double* zone)
        {
            addCheckButtonGlueDouble(fCPPInterface, label, zone);
        }
        
        virtual void addVerticalSlider(const char* label, double* zone, double init, double min, double max, double step)
        {
            addVerticalSliderGlueDouble(fCPPInterface, label, zone, init, min, max, step);
        }
        
        virtual void addHorizontalSlider(const char* label, double* zone, double init, double min, double max, double step)
        {
            addHorizontalSliderGlueDouble(fCPPInterface, label, zone, init, min, max, step);
        }
        
        virtual void addNumEntry(const char* label, double* zone, double init, double min, double max, double step)
        {
            addNumEntryGlueDouble(fCPPInterface, label, zone, init, min, max, step);
        }
    
        // -- soundfiles
        
        virtual void addSoundfile(const char* label, const char* url, Soundfile** sf_zone)
        {
            addSoundfileGlueFloat(fCPPInterface, label, url, sf_zone);
        }
    
        // -- passive widgets
        
        virtual void addHorizontalBargraph(const char* label, double* zone, double min, double max)
        {
            addHorizontalBargraphGlueDouble(fCPPInterface, label, zone, min, max);
        }
        
        virtual void addVerticalBargraph(const char* label, double* zone, double min, double max)
        {
            addVerticalBargraphGlueDouble(fCPPInterface, label, zone, min, max);
        }
    
        // -- metadata declarations
        
        virtual void declare(double* zone, const char* key, const char* val)
        {
            declareGlueDouble(fCPPInterface, zone, key, val);
        }

};

/*******************************************************************************
 * Meta glue code
 ******************************************************************************/

static void declareMetaGlue(void* cpp_interface, const char* key, const char* value)
{
    Meta* meta_interface = static_cast<Meta*>(cpp_interface);
    meta_interface->declare(key, value);
}

static void buildMetaGlue(MetaGlue* glue, Meta* meta)
{
    glue->metaInterface = meta;
    glue->declare = declareMetaGlue;
}
    
/*******************************************************************************
 * Memory manager glue code
 ******************************************************************************/

static void* allocateManagerGlue(void* cpp_interface, size_t size)
{
    dsp_memory_manager* manager_interface = static_cast<dsp_memory_manager*>(cpp_interface);
    return manager_interface->allocate(size);
}
    
static void destroyManagerGlue(void* cpp_interface, void* ptr)
{
    dsp_memory_manager* manager_interface = static_cast<dsp_memory_manager*>(cpp_interface);
    manager_interface->destroy(ptr);
}

static void buildManagerGlue(ManagerGlue* glue, dsp_memory_manager* manager)
{
    glue->managerInterface = manager;
    glue->allocate = allocateManagerGlue;
    glue->destroy = destroyManagerGlue;
}

#ifdef __cplusplus
}
#endif

#endif
/**************************  END  CGlue.h **************************/

#ifdef _WIN32
#include <windows.h>
#define snprintf _snprintf
#endif

//-------------------------------------------------------------------
//  Decode a dsp JSON description and implement 'buildUserInterface'
//-------------------------------------------------------------------

#define REAL_UI(ui_interface)  reinterpret_cast<UIReal<REAL>*>(ui_interface)
#define REAL_ADR(offset)       reinterpret_cast<REAL*>(&memory_block[offset])
#define SOUNDFILE_ADR(offset)  reinterpret_cast<Soundfile**>(&memory_block[offset])

typedef std::function<void(double)> ReflectFunction;
typedef std::function<double()> ModifyFunction;

struct ExtZoneParam {

    virtual void reflectZone() = 0;
    virtual void modifyZone() = 0;
    
    virtual void setReflectZoneFun(ReflectFunction reflect) = 0;
    virtual void setModifyZoneFun(ModifyFunction modify) = 0;
    
};

template <typename REAL>
struct JSONUIDecoderAux {
    
    struct ZoneParam : public ExtZoneParam {
        
        REAL fZone;
        int fIndex;
        ReflectFunction fReflect;
        ModifyFunction fModify;
        
    #if defined(TARGET_OS_IPHONE) || defined(WIN32)
        ZoneParam(int index, ReflectFunction reflect = nullptr, ModifyFunction modify = nullptr)
        :fIndex(index), fReflect(reflect), fModify(modify)
        {}
        void reflectZone() { if (fReflect) fReflect(fZone); }
        void modifyZone() { if (fModify) fZone = fModify(); }
    #else
        ZoneParam(int index, ReflectFunction reflect = [](REAL value) {}, ModifyFunction modify = []() { return REAL(-1); })
        :fIndex(index), fReflect(reflect), fModify(modify)
        {}
        void reflectZone() { fReflect(fZone); }
        void modifyZone() { fZone = fModify(); }
    #endif
        
        void setReflectZoneFun(ReflectFunction reflect) { fReflect = reflect; }
        void setModifyZoneFun(ModifyFunction modify) { fModify = modify; }
        
    };

    typedef std::vector<ExtZoneParam*> controlMap;
    
    REAL STR2REAL(const std::string& str) { return REAL(std::strtod(str.c_str(), nullptr)); }
 
    std::string fName;
    std::string fFileName;
    std::string fJSON;
    std::string fVersion;
    std::string fCompileOptions;
    
    std::map<std::string, std::string> fMetadata;
    std::vector<itemInfo> fUiItems;
    
    std::vector<std::string> fLibraryList;
    std::vector<std::string> fIncludePathnames;
    
    Soundfile** fSoundfiles;
    
    int fNumInputs, fNumOutputs, fSRIndex;
    int fInputItems, fOutputItems, fSoundfileItems;
    int fDSPSize;
    
    controlMap fPathInputTable;     // [path, ZoneParam]
    controlMap fPathOutputTable;    // [path, ZoneParam]

    bool isInput(const std::string& type)
    {
        return (type == "vslider" || type == "hslider" || type == "nentry" || type == "button" || type == "checkbox");
    }
    bool isOutput(const std::string& type) { return (type == "hbargraph" || type == "vbargraph"); }
    bool isSoundfile(const std::string& type) { return (type == "soundfile"); }
    
    std::string getString(std::map<std::string, std::string >& map, const std::string& key)
    {
        return (map.find(key) != map.end()) ? map[key] : "";
    }
    
    int getInt(std::map<std::string, std::string >& map, const std::string& key)
    {
        return (map.find(key) != map.end()) ? std::atoi(map[key].c_str()) : -1;
    }
    
    void setReflectZoneFun(int index, ReflectFunction fun)
    {
        fPathInputTable[index]->setReflectZoneFun(fun);
    }
    
    void setModifyZoneFun(int index, ModifyFunction fun)
    {
        fPathOutputTable[index]->setModifyZoneFun(fun);
    }

    JSONUIDecoderAux(const std::string& json)
    {
        fJSON = json;
        const char* p = fJSON.c_str();
        std::map<std::string, std::string > meta_data0;
        std::map<std::string, std::vector<std::string> > meta_data2;
        parseJson(p, meta_data0, fMetadata, meta_data2, fUiItems);
        
        // meta_data0 contains <name : val>, <inputs : val>, <ouputs : val> pairs etc...
        fName = getString(meta_data0, "name");
        fFileName = getString(meta_data0, "filename");
        fVersion = getString(meta_data0, "version");
        fCompileOptions = getString(meta_data0, "compile_options");
        
        if (meta_data2.find("library_list") != meta_data2.end()) {
            fLibraryList = meta_data2["library_list"];
        }
        if (meta_data2.find("include_pathnames") != meta_data2.end()) {
            fIncludePathnames = meta_data2["include_pathnames"];
        }
        
        fDSPSize = getInt(meta_data0, "size");
        fNumInputs = getInt(meta_data0, "inputs");
        fNumOutputs = getInt(meta_data0, "outputs");
        fSRIndex = getInt(meta_data0, "sr_index");
       
        fInputItems = 0;
        fOutputItems = 0;
        fSoundfileItems = 0;
        
        for (auto& it : fUiItems) {
            std::string type = it.type;
            if (isInput(type)) {
                fInputItems++;
            } else if (isOutput(type)) {
                fOutputItems++;          
            } else if (isSoundfile(type)) {
                fSoundfileItems++;
            }
        }
        
        fSoundfiles = new Soundfile*[fSoundfileItems];
        
        // Prepare the fPathTable and init zone
        for (auto& it : fUiItems) {
            std::string type = it.type;
            // Meta data declaration for input items
            if (isInput(type)) {
                ZoneParam* param = new ZoneParam(std::atoi(it.index.c_str()));
                fPathInputTable.push_back(param);
                param->fZone = STR2REAL(it.init);
            }
            // Meta data declaration for output items
            else if (isOutput(type)) {
                ZoneParam* param = new ZoneParam(std::atoi(it.index.c_str()));
                fPathOutputTable.push_back(param);
                param->fZone = REAL(0);
            }
        }
    }
    
    virtual ~JSONUIDecoderAux()
    {
        delete [] fSoundfiles;
    }
    
    void metadata(Meta* m)
    {
        for (auto& it : fMetadata) {
            m->declare(it.first.c_str(), it.second.c_str());
        }
    }
    
    void metadata(MetaGlue* m)
    {
        for (auto& it : fMetadata) {
            m->declare(m->metaInterface, it.first.c_str(), it.second.c_str());
        }
    }
    
    void resetUserInterface()
    {
        int item = 0;
        for (auto& it : fUiItems) {
            if (isInput(it.type)) {
                static_cast<ZoneParam*>(fPathInputTable[item++])->fZone = STR2REAL(it.init);
            }
        }
    }
    
    void resetUserInterface(char* memory_block, Soundfile* defaultsound = nullptr)
    {
        for (auto& it : fUiItems) {
            int offset = std::atoi(it.index.c_str());
            if (isInput(it.type)) {
                *REAL_ADR(offset) = STR2REAL(it.init);
            } else if (isSoundfile(it.type)) {
                if (*SOUNDFILE_ADR(offset) == nullptr) {
                    *SOUNDFILE_ADR(offset) = defaultsound;
                }
            }
        }
    }
    
    int getSampleRate(char* memory_block)
    {
        return *reinterpret_cast<int*>(&memory_block[fSRIndex]);
    }
   
    void buildUserInterface(UI* ui_interface)
    {
        // MANDATORY: to be sure floats or double are correctly parsed
        char* tmp_local = setlocale(LC_ALL, nullptr);
        setlocale(LC_ALL, "C");
        
        int countIn = 0;
        int countOut = 0;
        int countSound = 0;
        
        for (auto& it : fUiItems) {
            
            std::string type = it.type;
            REAL init = STR2REAL(it.init);
            REAL min = STR2REAL(it.min);
            REAL max = STR2REAL(it.max);
            REAL step = STR2REAL(it.step);
            
            // Meta data declaration for input items
            if (isInput(type)) {
                for (size_t i = 0; i < it.meta.size(); i++) {
                    REAL_UI(ui_interface)->declare(&static_cast<ZoneParam*>(fPathInputTable[countIn])->fZone, it.meta[i].first.c_str(), it.meta[i].second.c_str());
                }
            }
            // Meta data declaration for output items
            else if (isOutput(type)) {
                for (size_t i = 0; i < it.meta.size(); i++) {
                    REAL_UI(ui_interface)->declare(&static_cast<ZoneParam*>(fPathOutputTable[countOut])->fZone, it.meta[i].first.c_str(), it.meta[i].second.c_str());
                }
            }
            // Meta data declaration for group opening or closing
            else {
                for (size_t i = 0; i < it.meta.size(); i++) {
                    REAL_UI(ui_interface)->declare(0, it.meta[i].first.c_str(), it.meta[i].second.c_str());
                }
            }
            
            if (type == "hgroup") {
                REAL_UI(ui_interface)->openHorizontalBox(it.label.c_str());
            } else if (type == "vgroup") { 
                REAL_UI(ui_interface)->openVerticalBox(it.label.c_str());
            } else if (type == "tgroup") {
                REAL_UI(ui_interface)->openTabBox(it.label.c_str());
            } else if (type == "vslider") {
                REAL_UI(ui_interface)->addVerticalSlider(it.label.c_str(), &static_cast<ZoneParam*>(fPathInputTable[countIn])->fZone, init, min, max, step);
            } else if (type == "hslider") {
                REAL_UI(ui_interface)->addHorizontalSlider(it.label.c_str(), &static_cast<ZoneParam*>(fPathInputTable[countIn])->fZone, init, min, max, step);
            } else if (type == "checkbox") {
                REAL_UI(ui_interface)->addCheckButton(it.label.c_str(), &static_cast<ZoneParam*>(fPathInputTable[countIn])->fZone);
            } else if (type == "soundfile") {
                REAL_UI(ui_interface)->addSoundfile(it.label.c_str(), it.url.c_str(), &fSoundfiles[countSound]);
            } else if (type == "hbargraph") {
                 REAL_UI(ui_interface)->addHorizontalBargraph(it.label.c_str(), &static_cast<ZoneParam*>(fPathOutputTable[countOut])->fZone, min, max);
            } else if (type == "vbargraph") {
                REAL_UI(ui_interface)->addVerticalBargraph(it.label.c_str(), &static_cast<ZoneParam*>(fPathOutputTable[countOut])->fZone, min, max);
            } else if (type == "nentry") {
                REAL_UI(ui_interface)->addNumEntry(it.label.c_str(), &static_cast<ZoneParam*>(fPathInputTable[countIn])->fZone, init, min, max, step);
            } else if (type == "button") {
                REAL_UI(ui_interface)->addButton(it.label.c_str(), &static_cast<ZoneParam*>(fPathInputTable[countIn])->fZone);
            } else if (type == "close") {
                REAL_UI(ui_interface)->closeBox();
            }
            
            if (isInput(type)) {
                countIn++;
            } else if (isOutput(type)) {
                countOut++;
            } else if (isSoundfile(type)) {
                countSound++;
            }
        }
        setlocale(LC_ALL, tmp_local);
    }
    
    void buildUserInterface(UI* ui_interface, char* memory_block)
    {
        // MANDATORY: to be sure floats or double are correctly parsed
        char* tmp_local = setlocale(LC_ALL, nullptr);
        setlocale(LC_ALL, "C");
        
        int countSound = 0;
        
        for (auto& it : fUiItems) {
            
            std::string type = it.type;
            int offset = std::atoi(it.index.c_str());
            REAL init = STR2REAL(it.init);
            REAL min = STR2REAL(it.min);
            REAL max = STR2REAL(it.max);
            REAL step = STR2REAL(it.step);
            
            // Meta data declaration for input items
            if (isInput(type)) {
                for (size_t i = 0; i < it.meta.size(); i++) {
                    REAL_UI(ui_interface)->declare(REAL_ADR(offset), it.meta[i].first.c_str(), it.meta[i].second.c_str());
                }
            }
            // Meta data declaration for output items
            else if (isOutput(type)) {
                for (size_t i = 0; i < it.meta.size(); i++) {
                    REAL_UI(ui_interface)->declare(REAL_ADR(offset), it.meta[i].first.c_str(), it.meta[i].second.c_str());
                }
            }
            // Meta data declaration for group opening or closing
            else {
                for (size_t i = 0; i < it.meta.size(); i++) {
                    REAL_UI(ui_interface)->declare(0, it.meta[i].first.c_str(), it.meta[i].second.c_str());
                }
            }
            
            if (type == "hgroup") {
                REAL_UI(ui_interface)->openHorizontalBox(it.label.c_str());
            } else if (type == "vgroup") {
                REAL_UI(ui_interface)->openVerticalBox(it.label.c_str());
            } else if (type == "tgroup") {
                REAL_UI(ui_interface)->openTabBox(it.label.c_str());
            } else if (type == "vslider") {
                REAL_UI(ui_interface)->addVerticalSlider(it.label.c_str(), REAL_ADR(offset), init, min, max, step);
            } else if (type == "hslider") {
                REAL_UI(ui_interface)->addHorizontalSlider(it.label.c_str(), REAL_ADR(offset), init, min, max, step);
            } else if (type == "checkbox") {
                REAL_UI(ui_interface)->addCheckButton(it.label.c_str(), REAL_ADR(offset));
            } else if (type == "soundfile") {
                REAL_UI(ui_interface)->addSoundfile(it.label.c_str(), it.url.c_str(), SOUNDFILE_ADR(offset));
            } else if (type == "hbargraph") {
                REAL_UI(ui_interface)->addHorizontalBargraph(it.label.c_str(), REAL_ADR(offset), min, max);
            } else if (type == "vbargraph") {
                REAL_UI(ui_interface)->addVerticalBargraph(it.label.c_str(), REAL_ADR(offset), min, max);
            } else if (type == "nentry") {
                REAL_UI(ui_interface)->addNumEntry(it.label.c_str(), REAL_ADR(offset), init, min, max, step);
            } else if (type == "button") {
                REAL_UI(ui_interface)->addButton(it.label.c_str(), REAL_ADR(offset));
            } else if (type == "close") {
                REAL_UI(ui_interface)->closeBox();
            }
            
            if (isSoundfile(type)) {
                countSound++;
            }
        }
        setlocale(LC_ALL, tmp_local);
    }
    
    void buildUserInterface(UIGlue* ui_interface, char* memory_block)
    {
        // TODO
    }
    
    bool hasCompileOption(const std::string& option)
    {
        std::istringstream iss(fCompileOptions);
        std::string token;
        while (std::getline(iss, token, ' ')) {
            if (token == option) return true;
        }
        return false;
    }
    
};

// Templated decoder

struct JSONUITemplatedDecoder
{

    virtual ~JSONUITemplatedDecoder()
    {}
    
    virtual void metadata(Meta* m) = 0;
    virtual void metadata(MetaGlue* glue) = 0;
    virtual int getDSPSize() = 0;
    virtual std::string getName() = 0;
    virtual std::string getLibVersion() = 0;
    virtual std::string getCompileOptions() = 0;
    virtual std::vector<std::string> getLibraryList() = 0;
    virtual std::vector<std::string> getIncludePathnames() = 0;
    virtual int getNumInputs() = 0;
    virtual int getNumOutputs() = 0;
    virtual int getSampleRate(char* memory_block) = 0;
    virtual void setReflectZoneFun(int index, ReflectFunction fun) = 0;
    virtual void setModifyZoneFun(int index, ModifyFunction fun) = 0;
    virtual std::vector<ExtZoneParam*>& getInputControls() = 0;
    virtual std::vector<ExtZoneParam*>& getOutputControls() = 0;
    virtual void resetUserInterface(char* memory_block, Soundfile* defaultsound = nullptr) = 0;
    virtual void buildUserInterface(UI* ui_interface) = 0;
    virtual void buildUserInterface(UI* ui_interface, char* memory_block) = 0;
    virtual void buildUserInterface(UIGlue* ui_interface, char* memory_block) = 0;
    virtual bool hasCompileOption(const std::string& option) = 0;
};

struct JSONUIFloatDecoder : public JSONUIDecoderAux<float>, public JSONUITemplatedDecoder
{
    JSONUIFloatDecoder(const std::string& json):JSONUIDecoderAux<float>(json)
    {}
    
    void metadata(Meta* m) { JSONUIDecoderAux<float>::metadata(m); }
    void metadata(MetaGlue* glue) { JSONUIDecoderAux<float>::metadata(glue); }
    int getDSPSize() { return fDSPSize; }
    std::string getName() { return fName; }
    std::string getLibVersion() { return fVersion; }
    std::string getCompileOptions() { return fCompileOptions; }
    std::vector<std::string> getLibraryList() { return fLibraryList; }
    std::vector<std::string> getIncludePathnames() { return fIncludePathnames; }
    int getNumInputs() { return fNumInputs; }
    int getNumOutputs() { return fNumOutputs; }
    int getSampleRate(char* memory_block)  { return JSONUIDecoderAux<float>::getSampleRate(memory_block); }
    void setReflectZoneFun(int index, ReflectFunction fun)
    {
        JSONUIDecoderAux<float>::setReflectZoneFun(index, fun);
    }
    void setModifyZoneFun(int index, ModifyFunction fun)
    {
        JSONUIDecoderAux<float>::setModifyZoneFun(index, fun);
    }
    std::vector<ExtZoneParam*>& getInputControls()
    {
        return fPathInputTable;
    }
    std::vector<ExtZoneParam*>& getOutputControls()
    {
        return fPathOutputTable;
    }
    void resetUserInterface(char* memory_block, Soundfile* defaultsound = nullptr)
    {
        JSONUIDecoderAux<float>::resetUserInterface(memory_block, defaultsound);
    }
    void buildUserInterface(UI* ui_interface)
    {
        JSONUIDecoderAux<float>::buildUserInterface(ui_interface);
    }
    void buildUserInterface(UI* ui_interface, char* memory_block)
    {
        JSONUIDecoderAux<float>::buildUserInterface(ui_interface, memory_block);
    }
    void buildUserInterface(UIGlue* ui_interface, char* memory_block)
    {
        JSONUIDecoderAux<float>::buildUserInterface(ui_interface, memory_block);
    }
    bool hasCompileOption(const std::string& option) { return JSONUIDecoderAux<float>::hasCompileOption(option); }
};

struct JSONUIDoubleDecoder : public JSONUIDecoderAux<double>, public JSONUITemplatedDecoder
{
    JSONUIDoubleDecoder(const std::string& json):JSONUIDecoderAux<double>(json)
    {}
    
    void metadata(Meta* m) { JSONUIDecoderAux<double>::metadata(m); }
    void metadata(MetaGlue* glue) { JSONUIDecoderAux<double>::metadata(glue); }
    int getDSPSize() { return fDSPSize; }
    std::string getName() { return fName; }
    std::string getLibVersion() { return fVersion; }
    std::string getCompileOptions() { return fCompileOptions; }
    std::vector<std::string> getLibraryList() { return fLibraryList; }
    std::vector<std::string> getIncludePathnames() { return fIncludePathnames; }
    int getNumInputs() { return fNumInputs; }
    int getNumOutputs() { return fNumOutputs; }
    int getSampleRate(char* memory_block) { return JSONUIDecoderAux<double>::getSampleRate(memory_block); }
    void setReflectZoneFun(int index, ReflectFunction fun)
    {
        JSONUIDecoderAux<double>::setReflectZoneFun(index, fun);
    }
    void setModifyZoneFun(int index, ModifyFunction fun)
    {
        JSONUIDecoderAux<double>::setModifyZoneFun(index, fun);
    }
    std::vector<ExtZoneParam*>& getInputControls()
    {
        return fPathInputTable;
    }
    std::vector<ExtZoneParam*>& getOutputControls()
    {
        return fPathOutputTable;
    }
    void resetUserInterface(char* memory_block, Soundfile* defaultsound = nullptr)
    {
        JSONUIDecoderAux<double>::resetUserInterface(memory_block, defaultsound);
    }
    void buildUserInterface(UI* ui_interface)
    {
        JSONUIDecoderAux<double>::buildUserInterface(ui_interface);
    }
    void buildUserInterface(UI* ui_interface, char* memory_block)
    {
        JSONUIDecoderAux<double>::buildUserInterface(ui_interface, memory_block);
    }
    void buildUserInterface(UIGlue* ui_interface, char* memory_block)
    {
        JSONUIDecoderAux<double>::buildUserInterface(ui_interface, memory_block);
    }
    bool hasCompileOption(const std::string& option) { return JSONUIDecoderAux<double>::hasCompileOption(option); }
};

// FAUSTFLOAT decoder

struct JSONUIDecoder : public JSONUIDecoderAux<FAUSTFLOAT>
{
    JSONUIDecoder(const std::string& json):JSONUIDecoderAux<FAUSTFLOAT>(json)
    {}
};

static JSONUITemplatedDecoder* createJSONUIDecoder(const std::string& json)
{
    JSONUIDecoder decoder(json);
    if (decoder.hasCompileOption("-double")) {
        return new JSONUIDoubleDecoder(json);
    } else {
        return new JSONUIFloatDecoder(json);
    }
}

#endif
/**************************  END  JSONUIDecoder.h **************************/

//----------------------------------------------------------------
//  Proxy dsp definition created from the DSP JSON description
//  This class allows a 'proxy' dsp to control a real dsp 
//  possibly running somewhere else.
//----------------------------------------------------------------

class proxy_dsp : public dsp {

    private:
    
        JSONUIDecoder* fDecoder;
        int fSampleRate;
        
    public:
    
        proxy_dsp():fDecoder(nullptr), fSampleRate(-1)
        {}
    
        proxy_dsp(const std::string& json)
        {
            init(json);
        }
    
        void init(const std::string& json)
        {
            fDecoder = new JSONUIDecoder(json);
            fSampleRate = -1;
        }
          
        proxy_dsp(dsp* dsp)
        {
            JSONUI builder(dsp->getNumInputs(), dsp->getNumOutputs());
            dsp->metadata(&builder);
            dsp->buildUserInterface(&builder);
            fSampleRate = dsp->getSampleRate();
            fDecoder = new JSONUIDecoder(builder.JSON());
        }
      
        virtual ~proxy_dsp()
        {
            delete fDecoder;
        }
       
        virtual int getNumInputs() { return fDecoder->fNumInputs; }
        virtual int getNumOutputs() { return fDecoder->fNumOutputs; }
        
        virtual void buildUserInterface(UI* ui) { fDecoder->buildUserInterface(ui); }
        
        // To possibly implement in a concrete proxy dsp 
        virtual void init(int sample_rate)
        {
            instanceInit(sample_rate);
        }
        virtual void instanceInit(int sample_rate)
        {
            instanceConstants(sample_rate);
            instanceResetUserInterface();
            instanceClear();
        }
        virtual void instanceConstants(int sample_rate) { fSampleRate = sample_rate; }
        virtual void instanceResetUserInterface() { fDecoder->resetUserInterface(); }
        virtual void instanceClear() {}
    
        virtual int getSampleRate() { return fSampleRate; }
    
        virtual proxy_dsp* clone() { return new proxy_dsp(fDecoder->fJSON); }
        virtual void metadata(Meta* m) { fDecoder->metadata(m); }
    
        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {}
        virtual void compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {} 
        
};

#endif
/**************************  END  proxy-dsp.h **************************/
/************************** BEGIN JSONControl.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2019 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __JSON_CONTROL__
#define __JSON_CONTROL__

#include <string>

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif

struct JSONControl {
    
    virtual std::string getJSON() { return ""; }

    virtual void setParamValue(const std::string& path, FAUSTFLOAT value) {}

    virtual FAUSTFLOAT getParamValue(const std::string& path) { return 0; }
    
};

#endif
/**************************  END  JSONControl.h **************************/

#define kActiveVoice      0
#define kFreeVoice        -1
#define kReleaseVoice     -2
#define kNoVoice          -3

#define VOICE_STOP_LEVEL  0.0005    // -70 db
#define MIX_BUFFER_SIZE   4096

// endsWith(<str>,<end>) : returns true if <str> ends with <end>

static double midiToFreq(double note)
{
    return 440.0 * std::pow(2.0, (note-69.0)/12.0);
}

/**
 * Allows to control zones in a grouped manner.
 */

class GroupUI : public GUI, public PathBuilder
{

    private:

        std::map<std::string, uiGroupItem*> fLabelZoneMap;

        void insertMap(std::string label, FAUSTFLOAT* zone)
        {
            if (!MapUI::endsWith(label, "/gate")
                && !MapUI::endsWith(label, "/freq")
                && !MapUI::endsWith(label, "/gain")) {

                // Groups all controller except 'freq', 'gate', and 'gain'
                if (fLabelZoneMap.find(label) != fLabelZoneMap.end()) {
                    fLabelZoneMap[label]->addZone(zone);
                } else {
                    fLabelZoneMap[label] = new uiGroupItem(this, zone);
                }
            }
        }

        uiCallbackItem* fPanic;

    public:

        GroupUI(FAUSTFLOAT* zone, uiCallback cb, void* arg)
        {
            fPanic = new uiCallbackItem(this, zone, cb, arg);
        }
    
        virtual ~GroupUI()
        {
            // 'fPanic' is kept and deleted in GUI, so do not delete here
        }

        // -- widget's layouts
        void openTabBox(const char* label)
        {
            pushLabel(label);
        }
        void openHorizontalBox(const char* label)
        {
            pushLabel(label);
        }
        void openVerticalBox(const char* label)
        {
            pushLabel(label);
        }
        void closeBox()
        {
            popLabel();
        }

        // -- active widgets
        void addButton(const char* label, FAUSTFLOAT* zone)
        {
            insertMap(buildPath(label), zone);
        }
        void addCheckButton(const char* label, FAUSTFLOAT* zone)
        {
            insertMap(buildPath(label), zone);
        }
        void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT fmin, FAUSTFLOAT fmax, FAUSTFLOAT step)
        {
            insertMap(buildPath(label), zone);
        }
        void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT fmin, FAUSTFLOAT fmax, FAUSTFLOAT step)
        {
            insertMap(buildPath(label), zone);
        }
        void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT fmin, FAUSTFLOAT fmax, FAUSTFLOAT step)
        {
            insertMap(buildPath(label), zone);
        }

        // -- passive widgets
        void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT fmin, FAUSTFLOAT fmax)
        {
            insertMap(buildPath(label), zone);
        }
        void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT fmin, FAUSTFLOAT fmax)
        {
            insertMap(buildPath(label), zone);
        }

};

/**
 * One voice of polyphony.
 */

struct dsp_voice : public MapUI, public decorator_dsp {

    int fNote;                          // Playing note actual pitch
    int fDate;                          // KeyOn date
    int fRelease;                       // Current number of samples used in release mode to detect end of note
    int fMinRelease;                    // Max of samples used in release mode to detect end of note
    FAUSTFLOAT fLevel;                  // Last audio block level
    std::vector<std::string> fGatePath; // Paths of 'gate' control
    std::vector<std::string> fGainPath; // Paths of 'gain' control
    std::vector<std::string> fFreqPath; // Paths of 'freq' control
 
    dsp_voice(dsp* dsp):decorator_dsp(dsp)
    {
        dsp->buildUserInterface(this);
        fNote = kFreeVoice;
        fLevel = FAUSTFLOAT(0);
        fDate = 0;
        fMinRelease = dsp->getSampleRate()/2; // One 1/2 sec used in release mode to detect end of note
        extractPaths(fGatePath, fFreqPath, fGainPath);
    }
    virtual ~dsp_voice()
    {}

    void extractPaths(std::vector<std::string>& gate, std::vector<std::string>& freq, std::vector<std::string>& gain)
    {
        // Keep gain, freq and gate labels
        std::map<std::string, FAUSTFLOAT*>::iterator it;
        for (it = getMap().begin(); it != getMap().end(); it++) {
            std::string path = (*it).first;
            if (endsWith(path, "/gate")) {
                gate.push_back(path);
            } else if (endsWith(path, "/freq")) {
                freq.push_back(path);
            } else if (endsWith(path, "/gain")) {
                gain.push_back(path);
            }
        }
    }

    // MIDI velocity [0..127]
    void keyOn(int pitch, int velocity, bool trigger)
    {
        keyOn(pitch, float(velocity)/127.f, trigger);
    }

    // Normalized MIDI velocity [0..1]
    void keyOn(int pitch, float velocity, bool trigger)
    {
        for (size_t i = 0; i < fFreqPath.size(); i++) {
            setParamValue(fFreqPath[i], midiToFreq(pitch));
        }
        for (size_t i = 0; i < fGatePath.size(); i++) {
            setParamValue(fGatePath[i], FAUSTFLOAT(1));
        }
        for (size_t i = 0; i < fGainPath.size(); i++) {
            setParamValue(fGainPath[i], velocity);
        }
        
        fNote = pitch;
    }

    void keyOff(bool hard = false)
    {
        // No use of velocity for now...
        for (size_t i = 0; i < fGatePath.size(); i++) {
            setParamValue(fGatePath[i], FAUSTFLOAT(0));
        }
        
        if (hard) {
            // Immediately stop voice
            fNote = kFreeVoice;
        } else {
            // Release voice
            fRelease = fMinRelease;
            fNote = kReleaseVoice;
        }
    }

};

/**
 * A group of voices.
 */

struct dsp_voice_group {

    GroupUI fGroups;

    std::vector<dsp_voice*> fVoiceTable; // Individual voices
    dsp* fVoiceGroup;                    // Voices group to be used for GUI grouped control

    FAUSTFLOAT fPanic;

    bool fVoiceControl;
    bool fGroupControl;

    dsp_voice_group(uiCallback cb, void* arg, bool control, bool group)
        :fGroups(&fPanic, cb, arg),
        fVoiceGroup(0), fPanic(FAUSTFLOAT(0)),
        fVoiceControl(control), fGroupControl(group)
    {}

    virtual ~dsp_voice_group()
    {
        for (size_t i = 0; i < fVoiceTable.size(); i++) {
            delete fVoiceTable[i];
        }
        delete fVoiceGroup;
    }

    void addVoice(dsp_voice* voice)
    {
        fVoiceTable.push_back(voice);
    }

    void clearVoices()
    {
        fVoiceTable.clear();
    }

    void init()
    {
        // Groups all uiItem for a given path
        fVoiceGroup = new proxy_dsp(fVoiceTable[0]);
        fVoiceGroup->buildUserInterface(&fGroups);
        for (size_t i = 0; i < fVoiceTable.size(); i++) {
            fVoiceTable[i]->buildUserInterface(&fGroups);
        }
    }

    void buildUserInterface(UI* ui_interface)
    {
        if (fVoiceTable.size() > 1) {
            ui_interface->openTabBox("Polyphonic");

            // Grouped voices UI
            ui_interface->openVerticalBox("Voices");
            ui_interface->addButton("Panic", &fPanic);
            fVoiceGroup->buildUserInterface(ui_interface);
            ui_interface->closeBox();

            // If not grouped, also add individual voices UI
            if (!fGroupControl) {
                for (size_t i = 0; i < fVoiceTable.size(); i++) {
                    char buffer[32];
                    snprintf(buffer, 32, ((fVoiceTable.size() < 8) ? "Voice%ld" : "V%ld"), long(i+1));
                    ui_interface->openHorizontalBox(buffer);
                    fVoiceTable[i]->buildUserInterface(ui_interface);
                    ui_interface->closeBox();
                }
            }

            ui_interface->closeBox();
        } else {
            fVoiceTable[0]->buildUserInterface(ui_interface);
        }
    }

};

/**
 * Base class for MIDI controllable DSP.
 */

#ifdef EMCC
#endif

class dsp_poly : public decorator_dsp, public midi, public JSONControl {

    protected:
    
    #ifdef EMCC
        MapUI fMapUI;
        std::string fJSON;
    #endif
    
    public:
    
        dsp_poly()
        {}
        dsp_poly(dsp* dsp):decorator_dsp(dsp)
        {
        #ifdef EMCC
            JSONUI jsonui(getNumInputs(), getNumOutputs());
            buildUserInterface(&jsonui);
            fJSON = jsonui.JSON(true);
            buildUserInterface(&fMapUI);
        #endif
        }
    
        virtual ~dsp_poly() {}
    
        // Reimplemented for EMCC
    #ifdef EMCC
        virtual int getNumInputs() { return decorator_dsp::getNumInputs(); }
        virtual int getNumOutputs() { return decorator_dsp::getNumOutputs(); }
        virtual void buildUserInterface(UI* ui_interface) { decorator_dsp::buildUserInterface(ui_interface); }
        virtual int getSampleRate() { return decorator_dsp::getSampleRate(); }
        virtual void init(int sample_rate) { decorator_dsp::init(sample_rate); }
        virtual void instanceInit(int sample_rate) { decorator_dsp::instanceInit(sample_rate); }
        virtual void instanceConstants(int sample_rate) { decorator_dsp::instanceConstants(sample_rate); }
        virtual void instanceResetUserInterface() { decorator_dsp::instanceResetUserInterface(); }
        virtual void instanceClear() { decorator_dsp::instanceClear(); }
        virtual dsp_poly* clone() { return new dsp_poly(fDSP->clone()); }
        virtual void metadata(Meta* m) { decorator_dsp::metadata(m); }
    
        // Additional API
        std::string getJSON() { return fJSON; }
    
        virtual void setParamValue(const std::string& path, FAUSTFLOAT value)
        {
            fMapUI.setParamValue(path, value);
            GUI::updateAllGuis();
        }
        
        virtual FAUSTFLOAT getParamValue(const std::string& path) { return fMapUI.getParamValue(path); }

        virtual void computeJS(int count, uintptr_t inputs, uintptr_t outputs)
        {
            decorator_dsp::compute(count, reinterpret_cast<FAUSTFLOAT**>(inputs),reinterpret_cast<FAUSTFLOAT**>(outputs));
        }
    #endif
    
        virtual  MapUI* keyOn(int channel, int pitch, int velocity)
        {
            return midi::keyOn(channel, pitch, velocity);
        }
        virtual  void keyOff(int channel, int pitch, int velocity)
        {
            midi::keyOff(channel, pitch, velocity);
        }
        virtual  void keyPress(int channel, int pitch, int press)
        {
            midi::keyPress(channel, pitch, press);
        }
        virtual void chanPress(int channel, int press)
        {
            midi::chanPress(channel, press);
        }
        virtual void ctrlChange(int channel, int ctrl, int value)
        {
            midi::ctrlChange(channel, ctrl, value);
        }
        virtual void ctrlChange14bits(int channel, int ctrl, int value)
        {
            midi::ctrlChange14bits(channel, ctrl, value);
        }
        virtual void pitchWheel(int channel, int wheel)
        {
            midi::pitchWheel(channel, wheel);
        }
        virtual void progChange(int channel, int pgm)
        {
            midi::progChange(channel, pgm);
        }
    
        // Group API
        virtual void setGroup(bool group) {}
        virtual bool getGroup() { return false; }

};

/**
 * Polyphonic DSP: groups a set of DSP to be played together or triggered by MIDI.
 *
 * All voices are preallocated by cloning the single DSP voice given at creation time.
 * Dynamic voice allocation is done in 'getFreeVoice'
 */

class mydsp_poly : public dsp_voice_group, public dsp_poly {

    private:

        FAUSTFLOAT** fMixBuffer;
        int fDate;

        FAUSTFLOAT mixCheckVoice(int count, FAUSTFLOAT** outputBuffer, FAUSTFLOAT** mixBuffer)
        {
            FAUSTFLOAT level = 0;
            for (int i = 0; i < getNumOutputs(); i++) {
                FAUSTFLOAT* mixChannel = mixBuffer[i];
                FAUSTFLOAT* outChannel = outputBuffer[i];
                for (int j = 0; j < count; j++) {
                    level = std::max<FAUSTFLOAT>(level, (FAUSTFLOAT)fabs(outChannel[j]));
                    mixChannel[j] += outChannel[j];
                }
            }
            return level;
        }
    
        void mixVoice(int count, FAUSTFLOAT** outputBuffer, FAUSTFLOAT** mixBuffer)
        {
            FAUSTFLOAT level = 0;
            for (int i = 0; i < getNumOutputs(); i++) {
                FAUSTFLOAT* mixChannel = mixBuffer[i];
                FAUSTFLOAT* outChannel = outputBuffer[i];
                for (int j = 0; j < count; j++) {
                    mixChannel[j] += outChannel[j];
                }
            }
        }

        void clearOutput(int count, FAUSTFLOAT** mixBuffer)
        {
            for (int i = 0; i < getNumOutputs(); i++) {
                memset(mixBuffer[i], 0, count * sizeof(FAUSTFLOAT));
            }
        }
    
        int getPlayingVoice(int pitch)
        {
            int voice_playing = kNoVoice;
            int oldest_date_playing = INT_MAX;
            
            for (size_t i = 0; i < fVoiceTable.size(); i++) {
                if (fVoiceTable[i]->fNote == pitch) {
                    // Keeps oldest playing voice
                    if (fVoiceTable[i]->fDate < oldest_date_playing) {
                        oldest_date_playing = fVoiceTable[i]->fDate;
                        voice_playing = int(i);
                    }
                }
            }
            
            return voice_playing;
        }
    
        // Always returns a voice
        int getFreeVoice()
        {
            int voice = kNoVoice;
            
            // Looks for the first available voice
            for (size_t i = 0; i < fVoiceTable.size(); i++) {
                if (fVoiceTable[i]->fNote == kFreeVoice) {
                    voice = int(i);
                    goto result;
                }
            }

            {
                // Otherwise steal one
                int voice_release = kNoVoice;
                int voice_playing = kNoVoice;
                
                int oldest_date_release = INT_MAX;
                int oldest_date_playing = INT_MAX;

                // Scan all voices
                for (size_t i = 0; i < fVoiceTable.size(); i++) {
                    if (fVoiceTable[i]->fNote == kReleaseVoice) {
                        // Keeps oldest release voice
                        if (fVoiceTable[i]->fDate < oldest_date_release) {
                            oldest_date_release = fVoiceTable[i]->fDate;
                            voice_release = int(i);
                        }
                    } else {
                        // Otherwise keeps oldest playing voice
                        if (fVoiceTable[i]->fDate < oldest_date_playing) {
                            oldest_date_playing = fVoiceTable[i]->fDate;
                            voice_playing = int(i);
                        }
                    }
                }
            
                // Then decide which one to steal
                if (oldest_date_release != INT_MAX) {
                    std::cout << "Steal release voice : voice_date " << fVoiceTable[voice_release]->fDate << " cur_date = " << fDate << " voice = " << voice_release << std::endl;
                    voice = voice_release;
                    goto result;
                } else if (oldest_date_playing != INT_MAX) {
                    std::cout << "Steal playing voice : voice_date " << fVoiceTable[voice_playing]->fDate << " cur_date = " << fDate << " voice = " << voice_playing << std::endl;
                    voice = voice_playing;
                    goto result;
                } else {
                    assert(false);
                    return kNoVoice;
                }
            }
            
        result:
            // So that envelop is always re-initialized
            fVoiceTable[voice]->instanceClear();
            fVoiceTable[voice]->fDate = fDate++;
            fVoiceTable[voice]->fNote = kActiveVoice;
            return voice;
        }

        static void panic(FAUSTFLOAT val, void* arg)
        {
            if (val == FAUSTFLOAT(1)) {
                static_cast<mydsp_poly*>(arg)->allNotesOff(true);
            }
        }

        bool checkPolyphony()
        {
            if (fVoiceTable.size() > 0) {
                return true;
            } else {
                std::cout << "DSP is not polyphonic...\n";
                return false;
            }
        }

    public:
    
        /**
         * Constructor.
         *
         * @param dsp - the dsp to be used for one voice. Beware: mydsp_poly will use and finally delete the pointer.
         * @param nvoices - number of polyphony voices, should be at least 1
         * @param control - whether voices will be dynamically allocated and controlled (typically by a MIDI controler).
         *                If false all voices are always running.
         * @param group - if true, voices are not individually accessible, a global "Voices" tab will automatically dispatch
         *                a given control on all voices, assuming GUI::updateAllGuis() is called.
         *                If false, all voices can be individually controlled.
         *                setGroup/getGroup methods can be used to set/get the group state.
         *
         */
        mydsp_poly(dsp* dsp,
                   int nvoices,
                   bool control = false,
                   bool group = true)
        : dsp_voice_group(panic, this, control, group), dsp_poly(dsp) // dsp parameter is deallocated by ~dsp_poly
        {
            fDate = 0;

            // Create voices
            assert(nvoices > 0);
            for (int i = 0; i < nvoices; i++) {
                addVoice(new dsp_voice(dsp->clone()));
            }

            // Init audio output buffers
            fMixBuffer = new FAUSTFLOAT*[getNumOutputs()];
            for (int i = 0; i < getNumOutputs(); i++) {
                fMixBuffer[i] = new FAUSTFLOAT[MIX_BUFFER_SIZE];
            }

            dsp_voice_group::init();
        }

        virtual ~mydsp_poly()
        {
            for (int i = 0; i < getNumOutputs(); i++) {
                delete[] fMixBuffer[i];
            }
            delete[] fMixBuffer;
        }

        // DSP API
    
        void buildUserInterface(UI* ui_interface)
        {
            dsp_voice_group::buildUserInterface(ui_interface);
        }

        void init(int sample_rate)
        {
            decorator_dsp::init(sample_rate);
            fVoiceGroup->init(sample_rate);
            fPanic = FAUSTFLOAT(0);
            
            // Init voices
            for (size_t i = 0; i < fVoiceTable.size(); i++) {
                fVoiceTable[i]->init(sample_rate);
            }
        }
    
        void instanceInit(int samplingFreq)
        {
            instanceConstants(samplingFreq);
            instanceResetUserInterface();
            instanceClear();
        }

        void instanceConstants(int sample_rate)
        {
            decorator_dsp::instanceConstants(sample_rate);
            fVoiceGroup->instanceConstants(sample_rate);
            
            // Init voices
            for (size_t i = 0; i < fVoiceTable.size(); i++) {
                fVoiceTable[i]->instanceConstants(sample_rate);
            }
        }

        void instanceResetUserInterface()
        {
            decorator_dsp::instanceResetUserInterface();
            fVoiceGroup->instanceResetUserInterface();
            fPanic = FAUSTFLOAT(0);
            
            for (size_t i = 0; i < fVoiceTable.size(); i++) {
                fVoiceTable[i]->instanceResetUserInterface();
            }
        }

        void instanceClear()
        {
            decorator_dsp::instanceClear();
            fVoiceGroup->instanceClear();
            
            for (size_t i = 0; i < fVoiceTable.size(); i++) {
                fVoiceTable[i]->instanceClear();
            }
        }

        virtual mydsp_poly* clone()
        {
            return new mydsp_poly(fDSP->clone(), int(fVoiceTable.size()), fVoiceControl, fGroupControl);
        }

        void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            assert(count <= MIX_BUFFER_SIZE);

            // First clear the outputs
            clearOutput(count, outputs);

            if (fVoiceControl) {
                // Mix all playing voices
                for (size_t i = 0; i < fVoiceTable.size(); i++) {
                    dsp_voice* voice = fVoiceTable[i];
                    if (voice->fNote != kFreeVoice) {
                        voice->compute(count, inputs, fMixBuffer);
                        // Mix it in result
                        voice->fLevel = mixCheckVoice(count, fMixBuffer, outputs);
                        // Check the level to possibly set the voice in kFreeVoice again
                        voice->fRelease -= count;
                        if ((voice->fNote == kReleaseVoice)
                            && (voice->fRelease < 0)
                            && (voice->fLevel < VOICE_STOP_LEVEL)) {
                            voice->fNote = kFreeVoice;
                        }
                    }
                }
            } else {
                // Mix all voices
                for (size_t i = 0; i < fVoiceTable.size(); i++) {
                    fVoiceTable[i]->compute(count, inputs, fMixBuffer);
                    mixVoice(count, fMixBuffer, outputs);
                }
            }
        }

        void compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            compute(count, inputs, outputs);
        }
    
        // Terminate all active voices, gently or immediately (depending of 'hard' value)
        void allNotesOff(bool hard = false)
        {
            for (size_t i = 0; i < fVoiceTable.size(); i++) {
                fVoiceTable[i]->keyOff(hard);
            }
        }

        // Additional polyphonic API
        MapUI* newVoice()
        {
            return fVoiceTable[getFreeVoice()];
        }

        void deleteVoice(MapUI* voice)
        {
            std::vector<dsp_voice*>::iterator it = find(fVoiceTable.begin(), fVoiceTable.end(), reinterpret_cast<dsp_voice*>(voice));
            if (it != fVoiceTable.end()) {
                (*it)->keyOff();
            } else {
                std::cout << "Voice not found\n";
            }
        }
    
        void setGroup(bool group) { fGroupControl = group; }
        bool getGroup() { return fGroupControl; }

        // MIDI API
        MapUI* keyOn(int channel, int pitch, int velocity)
        {
            if (checkPolyphony()) {
                int voice = getFreeVoice();
                fVoiceTable[voice]->keyOn(pitch, velocity, true);
                return fVoiceTable[voice];
            } else {
                return 0;
            }
        }

        void keyOff(int channel, int pitch, int velocity = 127)
        {
            if (checkPolyphony()) {
                int voice = getPlayingVoice(pitch);
                if (voice != kNoVoice) {
                    fVoiceTable[voice]->keyOff();
                } else {
                    std::cout << "Playing pitch = " << pitch << " not found\n";
                }
            }
        }

        void pitchWheel(int channel, int wheel)
        {}

        void ctrlChange(int channel, int ctrl, int value)
        {
            if (ctrl == ALL_NOTES_OFF || ctrl == ALL_SOUND_OFF) {
                allNotesOff();
            }
        }

        void progChange(int channel, int pgm)
        {}

        void keyPress(int channel, int pitch, int press)
        {}

        void chanPress(int channel, int press)
        {}

        void ctrlChange14bits(int channel, int ctrl, int value)
        {}

};

/**
 * Polyphonic DSP with an integrated effect. fPolyDSP will respond to MIDI messages.
 */
class dsp_poly_effect : public dsp_poly {
    
    private:
        
        dsp_poly* fPolyDSP;
        
    public:
        
        dsp_poly_effect(dsp_poly* dsp1, dsp* dsp2)
        :dsp_poly(dsp2), fPolyDSP(dsp1)
        {}
        
        virtual ~dsp_poly_effect()
        {
            // dsp_poly_effect is also a decorator_dsp, which will free fPolyDSP
        }
        
        // MIDI API
        MapUI* keyOn(int channel, int pitch, int velocity)
        {
            return fPolyDSP->keyOn(channel, pitch, velocity);
        }
        void keyOff(int channel, int pitch, int velocity)
        {
            fPolyDSP->keyOff(channel, pitch, velocity);
        }
        void keyPress(int channel, int pitch, int press)
        {
            fPolyDSP->keyPress(channel, pitch, press);
        }
        void chanPress(int channel, int press)
        {
            fPolyDSP->chanPress(channel, press);
        }
        void ctrlChange(int channel, int ctrl, int value)
        {
            fPolyDSP->ctrlChange(channel, ctrl, value);
        }
        void ctrlChange14bits(int channel, int ctrl, int value)
        {
            fPolyDSP->ctrlChange14bits(channel, ctrl, value);
        }
        void pitchWheel(int channel, int wheel)
        {
            fPolyDSP->pitchWheel(channel, wheel);
        }
        void progChange(int channel, int pgm)
        {
            fPolyDSP->progChange(channel, pgm);
        }
        
        // Group API
        void setGroup(bool group)
        {
            fPolyDSP->setGroup(group);
        }
        bool getGroup()
        {
            return fPolyDSP->getGroup();
        }
};

/**
 * Polyphonic DSP factory class. Helper code to support polyphonic DSP source with an integrated effect.
 */

struct dsp_poly_factory : public dsp_factory {
    
    dsp_factory* fProcessFactory;
    dsp_factory* fEffectFactory;
    
    std::string getEffectCode(const std::string& dsp_content)
    {
        std::stringstream effect_code;
        effect_code << "adapt(1,1) = _; adapt(2,2) = _,_; adapt(1,2) = _ <: _,_; adapt(2,1) = _,_ :> _;";
        effect_code << "adaptor(F,G) = adapt(outputs(F),inputs(G)); dsp_code = environment{ " << dsp_content << " };";
        effect_code << "process = adaptor(dsp_code.process, dsp_code.effect) : dsp_code.effect;";
        return effect_code.str();
    }

    dsp_poly_factory(dsp_factory* process_factory = NULL,
                     dsp_factory* effect_factory = NULL):
    fProcessFactory(process_factory)
    ,fEffectFactory(effect_factory)
    {}
    
    virtual ~dsp_poly_factory()
    {}
    
    virtual std::string getName() { return fProcessFactory->getName(); }
    virtual std::string getSHAKey() { return fProcessFactory->getSHAKey(); }
    virtual std::string getDSPCode() { return fProcessFactory->getDSPCode(); }
    virtual std::string getCompileOptions() { return fProcessFactory->getCompileOptions(); }
    virtual std::vector<std::string> getLibraryList() { return fProcessFactory->getLibraryList(); }
    virtual std::vector<std::string> getIncludePathnames() { return fProcessFactory->getIncludePathnames(); }
    
    virtual void setMemoryManager(dsp_memory_manager* manager)
    {
        fProcessFactory->setMemoryManager(manager);
        if (fEffectFactory) {
            fEffectFactory->setMemoryManager(manager);
        }
    }
    virtual dsp_memory_manager* getMemoryManager() { return fProcessFactory->getMemoryManager(); }
    
    /* Create a new polyphonic DSP instance with global effect, to be deleted with C++ 'delete'
     *
     * @param nvoices - number of polyphony voices, should be at least 1
     * @param control - whether voices will be dynamically allocated and controlled (typically by a MIDI controler).
     *                If false all voices are always running.
     * @param group - if true, voices are not individually accessible, a global "Voices" tab will automatically dispatch
     *                a given control on all voices, assuming GUI::updateAllGuis() is called.
     *                If false, all voices can be individually controlled.
     */
    dsp_poly* createPolyDSPInstance(int nvoices, bool control, bool group)
    {
        dsp_poly* dsp_poly = new mydsp_poly(fProcessFactory->createDSPInstance(), nvoices, control, group);
        if (fEffectFactory) {
            // the 'dsp_poly' object has to be controlled with MIDI, so kept separated from new dsp_sequencer(...) object
            return new dsp_poly_effect(dsp_poly, new dsp_sequencer(dsp_poly, fEffectFactory->createDSPInstance()));
        } else {
            return new dsp_poly_effect(dsp_poly, dsp_poly);
        }
    }
    
    /* Create a new DSP instance, to be deleted with C++ 'delete' */
    dsp* createDSPInstance()
    {
        return fProcessFactory->createDSPInstance();
    }
    
};

#endif // __poly_dsp__
/**************************  END  poly-dsp.h **************************/
/************************** BEGIN JuceGUI.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif

#include <stack>

#include "../JuceLibraryCode/JuceHeader.h"


// Definition of the standard size of the different elements

#define kKnobWidth 100
#define kKnobHeight 100

#define kVSliderWidth 80
#define kVSliderHeight 250

#define kHSliderWidth 350
#define kHSliderHeight 50

#define kButtonWidth 100
#define kButtonHeight 50

#define kCheckButtonWidth 60
#define kCheckButtonHeight 40

#define kMenuWidth 100
#define kMenuHeight 50

#define kRadioButtonWidth 100
#define kRadioButtonHeight 55

#define kNumEntryWidth 100
#define kNumEntryHeight 50

#define kNumDisplayWidth 75
#define kNumDisplayHeight 50

#define kVBargraphWidth 60
#define kVBargraphHeight 250

#define kHBargraphWidth 350
#define kHBargraphHeight 50

#define kLedWidth 25
#define kLedHeight 25

#define kNameHeight 14

#define kMargin 4

/**
 * \brief       Custom LookAndFeel class.
 * \details     Define the appearance of all the JUCE widgets.
 */

struct CustomLookAndFeel : public LookAndFeel_V3
{
    void drawRoundThumb (Graphics& g, const float x, const float y,
                         const float diameter, const Colour& colour, float outlineThickness)
    {
        const juce::Rectangle<float> a (x, y, diameter, diameter);
        const float halfThickness = outlineThickness * 0.5f;

        Path p;
        p.addEllipse (x + halfThickness, y + halfThickness, diameter - outlineThickness, diameter - outlineThickness);

        const DropShadow ds (Colours::black, 1, Point<int> (0, 0));
        ds.drawForPath (g, p);

        g.setColour (colour);
        g.fillPath (p);

        g.setColour (colour.brighter());
        g.strokePath (p, PathStrokeType (outlineThickness));
    }

    void drawButtonBackground (Graphics& g, Button& button, const Colour& backgroundColour,
                               bool isMouseOverButton, bool isButtonDown) override
    {
        Colour baseColour (backgroundColour.withMultipliedSaturation (button.hasKeyboardFocus (true) ? 1.3f : 0.9f)
                           .withMultipliedAlpha (button.isEnabled() ? 0.9f : 0.5f));

        if (isButtonDown || isMouseOverButton)
            baseColour = baseColour.contrasting (isButtonDown ? 0.2f : 0.1f);

        const bool flatOnLeft   = button.isConnectedOnLeft();
        const bool flatOnRight  = button.isConnectedOnRight();
        const bool flatOnTop    = button.isConnectedOnTop();
        const bool flatOnBottom = button.isConnectedOnBottom();

        const float width  = button.getWidth() - 1.0f;
        const float height = button.getHeight() - 1.0f;

        if (width > 0 && height > 0)
        {
            const float cornerSize = jmin(15.0f, jmin(width, height) * 0.45f);
            const float lineThickness = cornerSize * 0.1f;
            const float halfThickness = lineThickness * 0.5f;

            Path outline;
            outline.addRoundedRectangle (0.5f + halfThickness, 0.5f + halfThickness, width - lineThickness, height - lineThickness,
                                         cornerSize, cornerSize,
                                         ! (flatOnLeft  || flatOnTop),
                                         ! (flatOnRight || flatOnTop),
                                         ! (flatOnLeft  || flatOnBottom),
                                         ! (flatOnRight || flatOnBottom));

            const Colour outlineColour (button.findColour (button.getToggleState() ? TextButton::textColourOnId
                                        : TextButton::textColourOffId));

            g.setColour (baseColour);
            g.fillPath (outline);

            if (! button.getToggleState()) {
                g.setColour (outlineColour);
                g.strokePath (outline, PathStrokeType (lineThickness));
            }
        }
    }

    void drawTickBox (Graphics& g, Component& component,
                      float x, float y, float w, float h,
                      bool ticked,
                      bool isEnabled,
                      bool isMouseOverButton,
                      bool isButtonDown) override
    {
        const float boxSize = w * 0.7f;

        bool isDownOrDragging = component.isEnabled() && (component.isMouseOverOrDragging() || component.isMouseButtonDown());
        const Colour colour (component.findColour (TextButton::buttonColourId).withMultipliedSaturation ((component.hasKeyboardFocus (false) || isDownOrDragging) ? 1.3f : 0.9f)
                             .withMultipliedAlpha (component.isEnabled() ? 1.0f : 0.7f));

        drawRoundThumb (g, x, y + (h - boxSize) * 0.5f, boxSize, colour,
                        isEnabled ? ((isButtonDown || isMouseOverButton) ? 1.1f : 0.5f) : 0.3f);

        if (ticked) {
            const Path tick (LookAndFeel_V2::getTickShape (6.0f));
            g.setColour (isEnabled ? findColour (TextButton::buttonOnColourId) : Colours::grey);

            const float scale = 9.0f;
            const AffineTransform trans (AffineTransform::scale (w / scale, h / scale)
                                         .translated (x - 2.5f, y + 1.0f));
            g.fillPath (tick, trans);
        }
    }

    void drawLinearSliderThumb (Graphics& g, int x, int y, int width, int height,
                                float sliderPos, float minSliderPos, float maxSliderPos,
                                const Slider::SliderStyle style, Slider& slider) override
    {
        const float sliderRadius = (float)(getSliderThumbRadius (slider) - 2);

        bool isDownOrDragging = slider.isEnabled() && (slider.isMouseOverOrDragging() || slider.isMouseButtonDown());
        Colour knobColour (slider.findColour (Slider::thumbColourId).withMultipliedSaturation ((slider.hasKeyboardFocus (false) || isDownOrDragging) ? 1.3f : 0.9f)
                           .withMultipliedAlpha (slider.isEnabled() ? 1.0f : 0.7f));

        if (style == Slider::LinearHorizontal || style == Slider::LinearVertical) {
            float kx, ky;

            if (style == Slider::LinearVertical) {
                kx = x + width * 0.5f;
                ky = sliderPos;
            } else {
                kx = sliderPos;
                ky = y + height * 0.5f;
            }

            const float outlineThickness = slider.isEnabled() ? 0.8f : 0.3f;

            drawRoundThumb (g,
                            kx - sliderRadius,
                            ky - sliderRadius,
                            sliderRadius * 2.0f,
                            knobColour, outlineThickness);
        } else {
            // Just call the base class for the demo
            LookAndFeel_V2::drawLinearSliderThumb (g, x, y, width, height, sliderPos, minSliderPos, maxSliderPos, style, slider);
        }
    }

    void drawLinearSlider (Graphics& g, int x, int y, int width, int height,
                           float sliderPos, float minSliderPos, float maxSliderPos,
                           const Slider::SliderStyle style, Slider& slider) override
    {
        g.fillAll (slider.findColour (Slider::backgroundColourId));

        if (style == Slider::LinearBar || style == Slider::LinearBarVertical) {
            const float fx = (float)x, fy = (float)y, fw = (float)width, fh = (float)height;

            Path p;

            if (style == Slider::LinearBarVertical)
                p.addRectangle (fx, sliderPos, fw, 1.0f + fh - sliderPos);
            else
                p.addRectangle (fx, fy, sliderPos - fx, fh);

            Colour baseColour (slider.findColour (Slider::rotarySliderFillColourId)
                               .withMultipliedSaturation (slider.isEnabled() ? 1.0f : 0.5f)
                               .withMultipliedAlpha (0.8f));

            g.setColour (baseColour);
            g.fillPath (p);

            const float lineThickness = jmin(15.0f, jmin(width, height) * 0.45f) * 0.1f;
            g.drawRect (slider.getLocalBounds().toFloat(), lineThickness);
        } else {
            drawLinearSliderBackground (g, x, y, width, height, sliderPos, minSliderPos, maxSliderPos, style, slider);
            drawLinearSliderThumb (g, x, y, width, height, sliderPos, minSliderPos, maxSliderPos, style, slider);
        }
    }

    void drawLinearSliderBackground (Graphics& g, int x, int y, int width, int height,
                                     float /*sliderPos*/,
                                     float /*minSliderPos*/,
                                     float /*maxSliderPos*/,
                                     const Slider::SliderStyle /*style*/, Slider& slider) override
    {
        const float sliderRadius = getSliderThumbRadius (slider) - 5.0f;
        Path on, off;

        if (slider.isHorizontal()) {
            const float iy = y + height * 0.5f - sliderRadius * 0.5f;
            juce::Rectangle<float> r (x - sliderRadius * 0.5f, iy, width + sliderRadius, sliderRadius);
            const float onW = r.getWidth() * ((float)slider.valueToProportionOfLength (slider.getValue()));

            on.addRectangle (r.removeFromLeft (onW));
            off.addRectangle (r);
        } else {
            const float ix = x + width * 0.5f - sliderRadius * 0.5f;
            juce::Rectangle<float> r (ix, y - sliderRadius * 0.5f, sliderRadius, height + sliderRadius);
            const float onH = r.getHeight() * ((float)slider.valueToProportionOfLength (slider.getValue()));

            on.addRectangle (r.removeFromBottom (onH));
            off.addRectangle (r);
        }

        g.setColour (slider.findColour (Slider::rotarySliderFillColourId));
        g.fillPath (on);

        g.setColour (slider.findColour (Slider::trackColourId));
        g.fillPath (off);
    }

    void drawRotarySlider (Graphics& g, int x, int y, int width, int height, float sliderPos,
                           float rotaryStartAngle, float rotaryEndAngle, Slider& slider) override
    {
        const float radius = jmin(width / 2, height / 2) - 4.0f;
        const float centreX = x + width * 0.5f;
        const float centreY = y + height * 0.5f;
        const float rx = centreX - radius;
        const float ry = centreY - radius;
        const float rw = radius * 2.0f;
        const float angle = rotaryStartAngle + sliderPos * (rotaryEndAngle - rotaryStartAngle);
        const bool isMouseOver = slider.isMouseOverOrDragging() && slider.isEnabled();

        //Background
        {
            g.setColour(Colours::lightgrey.withAlpha (isMouseOver ? 1.0f : 0.7f));
            Path intFilledArc;
            intFilledArc.addPieSegment(rx, ry, rw, rw, rotaryStartAngle, rotaryEndAngle, 0.8);
            g.fillPath(intFilledArc);
        }

        if (slider.isEnabled()) {
            g.setColour(slider.findColour (Slider::rotarySliderFillColourId).withAlpha (isMouseOver ? 1.0f : 0.7f));
        } else {
            g.setColour(Colour (0x80808080));
        }

        //Render knob value
        {
            Path pathArc;
            pathArc.addPieSegment(rx, ry, rw, rw, rotaryStartAngle, angle, 0.8);
            g.fillPath(pathArc);

            Path cursor, cursorShadow;
            float rectWidth = radius*0.4;
            float rectHeight = rectWidth/2;
            float rectX = centreX + radius*0.9 - rectHeight/2;
            float rectY = centreY - rectWidth/2;

            cursor.addRectangle(rectX, rectY, rectWidth, rectHeight);
            cursorShadow.addRectangle(rectX-1, rectY-1, rectWidth+2, rectHeight+2);

            AffineTransform t = AffineTransform::translation(-rectWidth + 2, rectHeight/2);
            t = t.rotated((angle - float_Pi/2), centreX, centreY);

            cursor.applyTransform(t);
            cursorShadow.applyTransform(t);

            g.setColour(Colours::black);
            g.fillPath(cursor);

            g.setColour(Colours::black .withAlpha(0.15f));
            g.fillPath(cursorShadow);
        }
    }
};

/**
 * \brief   Different kind of slider available
 * \see     uiSlider
 */
enum SliderType {
    HSlider,    /*!< Horizontal Slider      */
    VSlider,    /*!< Vertical Slider        */
    NumEntry,   /*!< Numerical Entry Box    */
    Knob        /*!< Circular Slider        */
};

/**
 * \brief   Different kind of VU-meter available.
 */
enum VUMeterType {
    HVUMeter,   /*!< Horizontal VU-meter    */
    VVUMeter,   /*!< Vertical VU-meter      */
    Led,        /*!< LED VU-meter           */
    NumDisplay  /*!< TextBox VU-meter       */
};

/**
 * \brief   Intern class for all FAUST widgets.
 * \details Every active, passive or box widgets derive from this class.
 */
class uiBase
{
    
    protected:
        
        int fTotalWidth, fTotalHeight;              // Size with margins included (for a uiBox)
        int fDisplayRectWidth, fDisplayRectHeight;  // Size without margin, just the child dimensions, sum on one dimension, max on the other
        float fHRatio, fVRatio;
        
    public:
        
        /**
         * \brief   Constructor.
         * \details Initialize a uiBase with all its sizes.
         *
         * \param   totWidth    Minimal total width.
         * \param   totHeight   Minimal total Height.
         */
        uiBase(int totWidth = 0, int totHeight = 0):
            fTotalWidth(totWidth), fTotalHeight(totHeight),
            fDisplayRectWidth(0), fDisplayRectHeight(0),
            fHRatio(1), fVRatio(1)
        {}
        
        virtual ~uiBase()
        {}
        
        /** Return the size. */
        juce::Rectangle<int> getSize()
        {
            return juce::Rectangle<int>(0, 0, fTotalWidth, fTotalHeight);
        }
        
        /** Return the total height in pixels. */
        int getTotalHeight()
        {
            return fTotalHeight;
        }
        
        /** Return the total width in pixels. */
        int getTotalWidth()
        {
            return fTotalWidth;
        }
        
        /** Return the horizontal ratio, between 0 and 1. */
        float getHRatio()
        {
            return fHRatio;
        }
        
        /** Return the vertical ratio, between 0 and 1. */
        float getVRatio()
        {
            return fVRatio;
        }
        
        /**
         * \brief   Set the uiBase bounds.
         * \details Convert absolute bounds to relative bounds,
         *          used in JUCE Component mechanics.
         *
         * \param r The absolute bounds.
         *
         */
        void setRelativeSize(Component* comp, const juce::Rectangle<int>& r)
        {
            comp->setBounds(r.getX() - comp->getParentComponent()->getX(),
                            r.getY() - comp->getParentComponent()->getY(),
                            r.getWidth(),
                            r.getHeight());
        }
    
        virtual void init(Component* comp = nullptr)
        {
            /** Initialize both vertical and horizontal ratios. */
            assert(comp);
            uiBase* parentBox = comp->findParentComponentOfClass<uiBase>();
            if (parentBox != nullptr) {
                fHRatio = (float)fTotalWidth / (float)parentBox->fDisplayRectWidth;
                fVRatio = (float)fTotalHeight / (float)parentBox->fDisplayRectHeight;
            }
        }
    
        virtual void setRecommendedSize()
        {}
        
        virtual void add(Component* comp)
        {}
    
};

/**
 * \brief   Intern class for all FAUST active or passive widgets.
 * \details Every activ or passive widgets derive from this class.
 */
class uiComponent : public uiBase, public Component, public uiItem
{

    public:
        /**
         * \brief   Constructor.
         * \details Initialize all uiItem, uiBase and the tooltip variables.
         *
         * \param   gui     Current FAUST GUI.
         * \param   zone    Zone of the widget.
         * \param   w       Width of the widget.
         * \param   h       Height of the widget.
         * \param   name    Name of the widget.
         */
        uiComponent(GUI* gui, FAUSTFLOAT* zone, int w, int h, String name):uiBase(w, h), Component(name), uiItem(gui, zone)
        {}

};

/** 
 * \brief   Intern class for all kind of sliders.
 * \see     SliderType
 */
class uiSlider : public uiComponent, private juce::Slider::Listener
{
    
    private:
        
        Slider::SliderStyle fStyle;
        Label fLabel;
        ScopedPointer<ValueConverter> fConverter;
        SliderType fType;
        Slider fSlider;

    public:
        /**
         * \brief   Constructor.
         * \details Initialize all uiComponent variables, and Slider specific ones.
         *          Initialize juce::Slider parameters.
         *
         * \param   gui, zone, w, h, tooltip, name  uiComponent variables.
         * \param   min                             Minimum value of the slider.
         * \param   max                             Maximum value of the slider.
         * \param   cur                             Initial value of the slider.
         * \param   step                            Step of the slider.
         * \param   unit                            Unit of the slider value.
         * \param   scale                           Scale of the slider, exponential, logarithmic, or linear.
         * \param   type                            Type of slider (see SliderType).
         */
        uiSlider(GUI* gui, FAUSTFLOAT* zone, FAUSTFLOAT w, FAUSTFLOAT h, FAUSTFLOAT cur, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step, String name, String unit, String tooltip, MetaDataUI::Scale scale, SliderType type) : uiComponent(gui, zone, w, h, name), fType(type)
        {
            if (scale == MetaDataUI::kLog) {
                fConverter = new LogValueConverter(min, max, min, max);
                fSlider.setSkewFactor(0.5); // Logarithmic slider
            } else if (scale == MetaDataUI::kExp) {
                fConverter = new ExpValueConverter(min, max, min, max);
                fSlider.setSkewFactor(2.0); // Exponential slider
            } else {
                fConverter = new LinearValueConverter(min, max, min, max);
            }

            // Set the JUCE widget initalization variables.
            switch(fType) {
                case HSlider:
                    fStyle = Slider::SliderStyle::LinearHorizontal;
                    break;
                case VSlider:
                    fStyle = Slider::SliderStyle::LinearVertical;
                    fSlider.setTextBoxStyle(juce::Slider::TextBoxBelow, false, 60, 20);
                    break;
                case NumEntry:
                    fSlider.setIncDecButtonsMode(Slider::incDecButtonsDraggable_AutoDirection);
                    fStyle = Slider::SliderStyle::IncDecButtons;
                    break;
                case Knob:
                    fStyle = Slider::SliderStyle::Rotary;
                    fSlider.setTextBoxStyle(juce::Slider::TextBoxBelow, false, 60, 20);
                    break;
                default:
                    break;
            }
            addAndMakeVisible(fSlider);

            // Slider settings
            fSlider.setRange(min, max, step);
            fSlider.setValue(fConverter->faust2ui(cur));
            fSlider.addListener(this);
            fSlider.setSliderStyle(fStyle);
            fSlider.setTextValueSuffix(" " + unit);
            fSlider.setTooltip(tooltip);
      
            // Label settings, only happens for a horizontal of numerical entry slider
            // because the method attachToComponent only give the choice to place the
            // slider name on centered top, which is what we want. It's done manually
            // in the paint method.
            if (fType == HSlider || fType == NumEntry) {
                fLabel.setText(getName(), dontSendNotification);
                fLabel.attachToComponent(&fSlider, true);
                fLabel.setTooltip(tooltip);
                addAndMakeVisible(fLabel);
            }
        }

        /** Draw the name of a vertical or circular slider. */
        virtual void paint(Graphics& g) override
        {
            if (fType == VSlider || fType == Knob) {
                g.setColour(Colours::black);
                g.drawText(getName(), getLocalBounds(), Justification::centredTop);
            }
        }

        /** Allow to control the slider when its value is changed, but not by the user. */
        void reflectZone() override
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            fSlider.setValue(fConverter->faust2ui(v));
        }

        /** JUCE callback for a slider value change, give the value to the FAUST module. */
        void sliderValueChanged(Slider* slider) override
        {
            float value = slider->getValue();
            //std::cout << getName() << " : " << value << std::endl;
            modifyZone(FAUSTFLOAT(value));
        }

        /** 
         * Set the good coordinates and size for the juce::Slider object depending 
         * on its SliderType, whenever the layout size changes.
         */
        void resized() override
        {
            int x, y, width, height;
            
            switch (fType) {
                    
                case HSlider: {
                    int nameWidth = Font().getStringWidth(getName()) + kMargin * 2;
                    x = nameWidth;
                    y = 0;
                    width = getWidth() - nameWidth;
                    height = getHeight();
                    break;
                }
                    
                case VSlider:
                    x = 0;
                    y = kNameHeight; // kNameHeight pixels for the name
                    height = getHeight() - kNameHeight;
                    width = getWidth();
                    break;

                case NumEntry:
                    width = kNumEntryWidth;
                    height = kNumEntryHeight;
                    // x position is the top left corner horizontal position of the box
                    // and not the top left of the NumEntry label, so we have to do that
                    x = (getWidth() - width)/2 + (Font().getStringWidth(getName()) + kMargin)/2;
                    y = (getHeight() - height)/2;
                    break;
                    
                case Knob:
                    // The knob name needs to be displayed, kNameHeight pixels
                    height = width = jmin(getHeight() - kNameHeight, kKnobHeight);
                    x = (getWidth() - width)/2;
                    // kNameHeight pixels for the knob name still
                    y = jmax((getHeight() - height)/2, kNameHeight);
                    break;
                    
                default:
                    assert(false);
                    break;
            }
            
            fSlider.setBounds(x, y, width, height);
        }
    
};

/** Intern class for button */
class uiButton : public uiComponent, private juce::Button::Listener
{
    
    private:
        
        TextButton fButton;

    public:
        /**
         * \brief   Constructor.
         * \details Initialize all uiComponent variables and juce::TextButton parameters.
         *
         * \param   gui, zone, w, h, tooltip, label uiComponent variable.
         */
        uiButton(GUI* gui, FAUSTFLOAT* zone, FAUSTFLOAT w, FAUSTFLOAT h, String label, String tooltip) :  uiComponent(gui, zone, w, h, label)
        {
            int x = 0;
            int y = (getHeight() - kButtonHeight)/2;

            fButton.setButtonText(label);
            fButton.setBounds(x, y, kButtonWidth, kButtonHeight);
            fButton.addListener(this);
            fButton.setTooltip(tooltip);
            addAndMakeVisible(fButton);
        }

        /** 
         * Has to be defined because its a pure virtual function of juce::Button::Listener, 
         * which uiButton derives from. Control of user actions is done in buttonStateChanged.
         * \see buttonStateChanged
         */
        void buttonClicked (Button* button) override
        {}

        /** Indicate to the FAUST module when the button is pressed and released. */
        void buttonStateChanged (Button* button) override
        {
            if (button->isDown()) {
                modifyZone(FAUSTFLOAT(1));
            } else {
                modifyZone(FAUSTFLOAT(0));
            }
        }
        
        void reflectZone() override
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            if (v == FAUSTFLOAT(1)) {
                fButton.triggerClick();
            }
        }

        /** Set the good coordinates and size to the juce::TextButton widget whenever the layout size changes. */
        virtual void resized() override
        {
            int x = kMargin;
            int width = getWidth() - 2 * kMargin;
            int height = jmin(getHeight(), kButtonHeight);
            int y = (getHeight()-height)/2;
            fButton.setBounds(x, y, width, height);
        }
    
};

/** Intern class for checkButton */
class uiCheckButton : public uiComponent, private juce::Button::Listener
{
    
    private:
        
        ToggleButton fCheckButton;

    public:
        /**
         * \brief   Constructor.
         * \details Initialize all uiComponent variables and juce::ToggleButton parameters.
         *
         * \param   gui, zone, w, h, label, tooltip     uiComponent variables.
         */
        uiCheckButton(GUI* gui, FAUSTFLOAT* zone, FAUSTFLOAT w, FAUSTFLOAT h, String label, String tooltip) : uiComponent(gui, zone, w, h, label)
        {
            int x = 0;
            int y = (getHeight()-h)/2;
            
            fCheckButton.setButtonText(label);
            fCheckButton.setBounds(x, y, w, h);
            fCheckButton.addListener(this);
            fCheckButton.setTooltip(tooltip);
            addAndMakeVisible(fCheckButton);
        }

        /** Indicate to the FAUST module when the button is toggled or not. */
        void buttonClicked(Button* button) override
        {
            //std::cout << getName() << " : " << button->getToggleState() << std::endl;
            modifyZone(button->getToggleState());
        }

        void reflectZone() override
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            fCheckButton.triggerClick();
        }

        /** Set the good coordinates and size to the juce::ToggleButton widget, whenever the layout size changes. */
        virtual void resized() override
        {
            fCheckButton.setBounds(getLocalBounds());
        }
    
};

/** Intern class for Menu */
class uiMenu : public uiComponent, private juce::ComboBox::Listener
{
    
    private:
        
        ComboBox fComboBox;
        std::vector<double> fValues;

    public:
        /**
         * \brief   Constructor.
         * \details Initialize the uiComponent and Menu specific variables, and the juce::ComboBox parameters.
         *          Menu is considered as a slider in the FAUST logic, with a step of one. The first item
         *          would be 0 on a slider, the second 1, etc. Each "slider value" is associated with a 
         *          string.
         *
         * \param   gui, zone, w, h, tooltip, label     uiComponent variables.
         * \param   cur                                 Current "slider value" associated with the current item selected.
         * \param   low                                 Lowest value possible.
         * \param   hi                                  Highest value possible.
         * \param   mdescr                              Menu description. Contains the names of the items associated with their "value".
         */
        uiMenu(GUI* gui, FAUSTFLOAT* zone, String label, FAUSTFLOAT w, FAUSTFLOAT h, FAUSTFLOAT cur, FAUSTFLOAT lo, FAUSTFLOAT hi, String tooltip, const char* mdescr) : uiComponent(gui, zone, w, h, label)
        {
            //Init ComboBox parameters
            fComboBox.setEditableText(false);
            fComboBox.setJustificationType(Justification::centred);
            fComboBox.addListener(this);
            addAndMakeVisible(fComboBox);

            std::vector<std::string> names;
            std::vector<double> values;

            if (parseMenuList(mdescr, names, values)) {

                int defaultitem = -1;
                double mindelta = FLT_MAX;
                int item = 1;

                // Go through all the Menu's items.
                for (int i = 0; i < names.size(); i++) {
                    double v = values[i];
                    if ((v >= lo) && (v <= hi)) {
                        // It is a valid value : add corresponding menu item
                        // item astrating at 1 because index 0 is reserved for a non-defined item.
                        fComboBox.addItem(String(names[i].c_str()), item++);
                        fValues.push_back(v);

                        // Check if this item is a good candidate to represent the current value
                        double delta = fabs(cur-v);
                        if (delta < mindelta) {
                            mindelta = delta;
                            defaultitem = fComboBox.getNumItems();
                        }
                    }
                }
                // check the best candidate to represent the current value
                if (defaultitem > -1) {
                    fComboBox.setSelectedItemIndex(defaultitem);
                }
            }

            *fZone = cur;
        }

        /** Indicate to the FAUST module when the selected items is changed. */
        void comboBoxChanged (ComboBox* cb) override
        {
            //std::cout << getName( )<< " : " << cb->getSelectedId() - 1 << std::endl;
            // -1 because of the starting item  at 1 at the initialization
            modifyZone(fValues[cb->getSelectedId() - 1]);
        }

        virtual void reflectZone() override
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;

            // search closest value
            int defaultitem = -1;
            double mindelta = FLT_MAX;

            for (unsigned int i = 0; i < fValues.size(); i++) {
                double delta = fabs(fValues[i]-v);
                if (delta < mindelta) {
                    mindelta = delta;
                    defaultitem = i;
                }
            }
            if (defaultitem > -1) {
                fComboBox.setSelectedItemIndex(defaultitem);
            }
        }

        /** Set the good coordinates and size to the juce::ComboBox widget whenever the layout get reiszed */
        virtual void resized() override
        {
            fComboBox.setBounds(0, 0 + kMenuHeight/2, getWidth(), kMenuHeight/2);
        }

        /** Display the name of the Menu */
        virtual void paint(Graphics& g) override
        {
            g.setColour(Colours::black);
            g.drawText(getName(), getLocalBounds().withHeight(getHeight()/2), Justification::centredTop);
        }
    
};

/** Intern class for RadioButton */
class uiRadioButton : public uiComponent, private juce::Button::Listener
{
    
    private:
        
        bool fIsVertical;
        OwnedArray<ToggleButton> fButtons;
        std::vector<double> fValues;

    public:
        /**
         * \brief   Constructor.
         * \details Initialize the uiComponent variables, and the RadioButton specific variables
         *          and parameters. Works in a similar way to the Menu, because it is a special
         *          kind of sliders in the faust logic. 
         * \see     uiMenu
         * 
         * \param   gui, zone, tooltip, label   uiComponent variables.
         * \param   w                           uiComponent variable and width of the RadioButton widget.
         * \param   h                           uiComponent variable and height of the RadioButton widget.
         * \param   cur                         Current "value" associated with the item selected.
         * \param   low                         Lowest "value" possible.
         * \param   hi                          Highest "value" possible.
         * \param   vert                        True if vertical, false if horizontal.
         * \param   names                       Contain the names of the different items.
         * \param   values                      Contain the "values" of the different items.
         * \param   fRadioGroupID               RadioButton being multiple CheckButton in JUCE,
         *                                      we need an ID to know which are linked together.
         */
        uiRadioButton(GUI* gui, FAUSTFLOAT* zone, String label, FAUSTFLOAT w, FAUSTFLOAT h, FAUSTFLOAT cur, FAUSTFLOAT lo, FAUSTFLOAT hi, bool vert, std::vector<std::string>& names, std::vector<double>& values, String tooltip, int radioGroupID) : uiComponent(gui, zone, w, h, label), fIsVertical(vert)
        {
            ToggleButton* defaultbutton = 0;
            double mindelta = FLT_MAX;

            for (int i = 0; i < names.size(); i++) {
                double v = values[i];
                if ((v >= lo) && (v <= hi)) {

                    // It is a valid value included in slider's range
                    ToggleButton* tb = new ToggleButton(names[i]);
                    addAndMakeVisible(tb);
                    tb->setRadioGroupId (radioGroupID);
                    tb->addListener(this);
                    tb->setTooltip(tooltip);
                    fValues.push_back(v);
                    fButtons.add(tb);
      
                    // Check if this item is a good candidate to represent the current value
                    double delta = fabs(cur-v);
                    if (delta < mindelta) {
                        mindelta = delta;
                        defaultbutton = tb;
                    }
                }
            }
            // check the best candidate to represent the current value
            if (defaultbutton) {
                defaultbutton->setToggleState (true, dontSendNotification);
            }
        }
     
        virtual void reflectZone() override
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;

            // select closest value
            int defaultitem = -1;
            double mindelta = FLT_MAX;

            for (unsigned int i = 0; i < fValues.size(); i++) {
                double delta = fabs(fValues[i]-v);
                if (delta < mindelta) {
                    mindelta = delta;
                    defaultitem = i;
                }
            }
            if (defaultitem > -1) {
                fButtons.operator[](defaultitem)->setToggleState (true, dontSendNotification);
            }
        }

        /** Handle the placement of each juce::ToggleButton everytime the layout size is changed. */
        virtual void resized() override
        {
            int width, height;
            fIsVertical ? (height = (getHeight() - kNameHeight) / fButtons.size()) : (width = getWidth() / fButtons.size());

            for (int i = 0; i < fButtons.size(); i++) {
                if (fIsVertical) {
                    fButtons.operator[](i)->setBounds(0, i * height + kNameHeight, getWidth(), height);
                } else {
                    // kNameHeight pixels offset for the title
                    fButtons.operator[](i)->setBounds(i * width, kNameHeight, width, getHeight() - kNameHeight);
                }
            }
        }
        
        /** Display the RadioButton name */
        virtual void paint(Graphics& g) override
        {
            g.setColour(Colours::black);
            g.drawText(getName(), getLocalBounds().withHeight(kNameHeight), Justification::centredTop);
        }

        /** Check which button is checked, and give its "value" to the FAUST module */
        void buttonClicked(Button* button) override
        {
            ToggleButton* checkButton = dynamic_cast<ToggleButton*>(button);
            //std::cout << getName() << " : " << fButtons.indexOf(checkButton) << std::endl;
            modifyZone(fButtons.indexOf(checkButton));
        }
    
};

/**
 * \brief   Intern class for VU-meter
 * \details There is no JUCE widgets for VU-meter, so its fully designed in this class.
 */
class uiVUMeter : public uiComponent, public SettableTooltipClient, public Timer
{
    
    private:
    
        FAUSTFLOAT fLevel;               // Current level of the VU-meter.
        FAUSTFLOAT fMin, fMax;           // Linear range of the VU-meter.
        FAUSTFLOAT fScaleMin, fScaleMax; // Range in dB if needed.
        bool fDB;                        // True if it's a dB VU-meter, false otherwise.
        VUMeterType fStyle;
        String fUnit;
        Label fLabel;               // Name of the VU-meter.
    
        bool isNameDisplayed()
        {
            return (!(getName().startsWith("0x")) && getName().isNotEmpty());
        }
        
        /** Give the right coordinates and size to the text of Label depending on the VU-meter style */
        void setLabelPos()
        {
            if (fStyle == VVUMeter) {
                // -22 on the height because of the text box.
                fLabel.setBounds((getWidth()-50)/2, getHeight()-22, 50, 20);
            } else if (fStyle == HVUMeter) {
                isNameDisplayed() ? fLabel.setBounds(63, (getHeight()-20)/2, 50, 20)
                : fLabel.setBounds(3, (getHeight()-20)/2, 50, 20);
            } else if (fStyle == NumDisplay) {
                fLabel.setBounds((getWidth()-kNumDisplayWidth)/2,
                                 (getHeight()-kNumDisplayHeight/2)/2,
                                 kNumDisplayWidth,
                                 kNumDisplayHeight/2);
            }
        }
        
        /** Contain all the initialization need for our Label */
        void setupLabel(String tooltip)
        {
            setLabelPos();
            fLabel.setEditable(false, false, false);
            fLabel.setJustificationType(Justification::centred);
            fLabel.setText(String((int)*fZone) + " " + fUnit, dontSendNotification);
            fLabel.setTooltip(tooltip);
            addAndMakeVisible(fLabel);
        }
        
        /**
         * \brief   Generic method to draw an horizontal VU-meter.
         * \details Draw the background of the bargraph, and the TextBox box, without taking
         *          care of the actual level of the VU-meter
         * \see     drawHBargraphDB
         * \see     drawHBargraphLin
         *
         * \param   g       JUCE graphics context, used to draw components or images.
         * \param   width   Width of the VU-meter widget.
         * \param   height  Height of the VU-meter widget.
         * \param   level   Current level that needs to be displayed.
         * \param   dB      True if it's a db level, false otherwise.
         */
        void drawHBargraph(Graphics& g, int width, int height)
        {
            float x;
            float y = (float)(getHeight()-height)/2;
            if (isNameDisplayed()) {
                x = 120;
                width -= x;
                // VUMeter Name
                g.setColour(Colours::black);
                g.drawText(getName(), 0, y, 60, height, Justification::centredRight);
            } else {
                x = 60;
                width -= x;
            }
            
            // VUMeter Background
            g.setColour(Colours::lightgrey);
            g.fillRect(x, y, (float)width, (float)height);
            g.setColour(Colours::black);
            g.fillRect(x+1.0f, y+1.0f, (float)width-2, (float)height-2);
            
            // Label Window
            g.setColour(Colours::darkgrey);
            g.fillRect((int)x-58, (getHeight()-22)/2, 52, 22);
            g.setColour(Colours::white.withAlpha(0.8f));
            g.fillRect((int)x-57, (getHeight()-20)/2, 50, 20);
            
            // Call the appropriate drawing method for the level.
            fDB ? drawHBargraphDB (g, y, height) : drawHBargraphLin(g, x, y, width, height);
        }
        
        /**
         * Method in charge of drawing the level of a horizontal dB VU-meter.
         *
         * \param   g       JUCE graphics context, used to draw components or images.
         * \param   y       y coordinate of the VU-meter.
         * \param   height  Height of the VU-meter.
         * \param   level   Current level of the VU-meter, in dB.
         */
        void drawHBargraphDB(Graphics& g, int y, int height)
        {
            // Drawing Scale
            g.setFont(9.0f);
            g.setColour(Colours::white);
            for (int i = -10; i > fMin; i -= 10) {
                paintScale(g, i);
            }
            for (int i = -6; i < fMax; i += 3)  {
                paintScale(g, i);
            }
            
            int alpha = 200;
            FAUSTFLOAT dblevel = dB2Scale(fLevel);
            
            // We need to test here every color changing levels, to avoid to mix colors because of the alpha,
            // and so to start the new color rectangle at the end of the previous one.
            
            // Drawing from the minimal range to the current level, or -10dB.
            g.setColour(Colour((uint8)40, (uint8)160, (uint8)40, (uint8)alpha));
            g.fillRect(dB2x(fMin), y+1.0f, jmin(dB2x(fLevel)-dB2x(fMin), dB2x(-10)-dB2x(fMin)), (float)height-2);
            
            // Drawing from -10dB to the current level, or -6dB.
            if (dblevel > dB2Scale(-10)) {
                g.setColour(Colour((uint8)160, (uint8)220, (uint8)20, (uint8)alpha));
                g.fillRect(dB2x(-10), y+1.0f, jmin(dB2x(fLevel)-dB2x(-10), dB2x(-6)-dB2x(-10)), (float)height-2);
            }
            // Drawing from -6dB to the current level, or -3dB.
            if (dblevel > dB2Scale(-6)) {
                g.setColour(Colour((uint8)220, (uint8)220, (uint8)20, (uint8)alpha));
                g.fillRect(dB2x(-6), y+1.0f, jmin(dB2x(fLevel)-dB2x(-6), dB2x(-3)-dB2x(-6)), (float)height-2);
            }
            // Drawing from -3dB to the current level, or 0dB.
            if (dblevel > dB2Scale(-3)) {
                g.setColour(Colour((uint8)240, (uint8)160, (uint8)20, (uint8)alpha));
                g.fillRect(dB2x(-3), y+1.0f, jmin(dB2x(fLevel)-dB2x(-3), dB2x(0)-dB2x(-3)), (float)height-2);
            }
            // Drawing from 0dB to the current level, or the max range.
            if (dblevel > dB2Scale(0)) {
                g.setColour(Colour((uint8)240,  (uint8)0, (uint8)20, (uint8)alpha));
                g.fillRect(dB2x(0), y+1.0f, jmin(dB2x(fLevel)-dB2x(0), dB2x(fMax)-dB2x(0)), (float)height-2);
            }
        }
        
        /**
         * Method in charge of drawing the level of a horizontal linear VU-meter.
         *
         * \param   g       JUCE graphics context, used to draw components or images.
         * \param   x       x coordinate of the VU-meter.
         * \param   y       y coordinate of the VU-meter.
         * \param   height  Height of the VU-meter.
         * \param   width   Width of the VU-meter.
         * \param   level   Current level of the VU-meter, in linear logic.
         */
        void drawHBargraphLin(Graphics& g, int x, int y, int width, int height)
        {
            int alpha = 200;
            Colour c = juce::Colour((uint8)255, (uint8)165, (uint8)0, (uint8)alpha);
            
            // Drawing from the minimal range to the current level, or 20% of the VU-meter
            g.setColour(c.brighter());
            g.fillRect(x+1.0f, y+1.0f, jmin<float>(fLevel*(width-2), 0.2f*(width-2)), (float)height-2);
            // Drawing from 20% of the VU-meter to the current level, or 90% of the VU-meter
            if (fLevel > 0.2f) {
                g.setColour(c);
                g.fillRect(x+1.0f + 0.2f*(width-2), y+1.0f, jmin<float>((fLevel-0.2f) * (width-2), (0.9f-0.2f) * (width-2)), (float)height-2);
            }
            // Drawing from 90% of the VU-meter to the current level, or the maximal range of the VU-meter
            if (fLevel > 0.9f) {
                g.setColour(c.darker());
                g.fillRect(x+1.0f + 0.9f*(width-2), y+1.0f, jmin<float>((fLevel-0.9f) * (width-2), (1.0f-0.9f) * (width-2)), (float)height-2);
            }
        }
        /**
         * \brief   Generic method to draw a vertical VU-meter.
         * \details Draw the background of the bargraph, and the TextBox box, without taking
         *          care of the actual level of the VU-meter
         * \see     drawHBargraphDB
         * \see     drawHBargraphLin
         *
         * \param   g       JUCE graphics context, used to draw components or images.
         * \param   width   Width of the VU-meter widget.
         * \param   height  Height of the VU-meter widget.
         * \param   level   Current level that needs to be displayed.
         * \param   dB      True if it's a db level, false otherwise.
         */
        void drawVBargraph(Graphics& g, int width, int height)
        {
            float x = (float)(getWidth()-width)/2;
            float y;
            if (isNameDisplayed()) {
                y = (float)getHeight()-height+15;
                height -= 40;
                // VUMeter Name
                g.setColour(Colours::black);
                g.drawText(getName(), getLocalBounds(), Justification::centredTop);
            } else {
                y = (float)getHeight()-height;
                height -= 25;
            }
            
            // VUMeter Background
            g.setColour(Colours::lightgrey);
            g.fillRect(x, y, (float)width, (float)height);
            g.setColour(Colours::black);
            g.fillRect(x+1.0f, y+1.0f, (float)width-2, (float)height-2);
            
            // Label window
            g.setColour(Colours::darkgrey);
            g.fillRect(jmax((getWidth()-50)/2, 0), getHeight()-23, jmin(getWidth(), 50), 22);
            g.setColour(Colours::white.withAlpha(0.8f));
            g.fillRect(jmax((getWidth()-48)/2, 1), getHeight()-22, jmin(getWidth()-2, 48), 20);
            
            fDB ? drawVBargraphDB (g, x, width) : drawVBargraphLin(g, x, width);
        }
        
        /**
         * Method in charge of drawing the level of a vertical dB VU-meter.
         *
         * \param   g       JUCE graphics context, used to draw components or images.
         * \param   x       x coordinate of the VU-meter.
         * \param   width   Width of the VU-meter.
         * \param   level   Current level of the VU-meter, in dB.
         */
        void drawVBargraphDB(Graphics& g, int x, int width)
        {
            // Drawing Scale
            g.setFont(9.0f);
            g.setColour(Colours::white);
            for (int i = -10; i > fMin; i -= 10) {
                paintScale(g, i);
            }
            for (int i = -6; i < fMax; i += 3)  {
                paintScale(g, i);
            }
            
            int alpha = 200;
            FAUSTFLOAT dblevel = dB2Scale(fLevel);
            
            // We need to test here every color changing levels, to avoid to mix colors because of the alpha,
            // and so to start the new color rectangle at the end of the previous one.
            
            // Drawing from the minimal range to the current level, or -10dB.
            g.setColour(Colour((uint8)40, (uint8)160, (uint8)40, (uint8)alpha));
            g.fillRect(x+1.0f, jmax(dB2y(fLevel), dB2y(-10)), (float)width-2, dB2y(fMin)-jmax(dB2y(fLevel), dB2y(-10)));
            
            // Drawing from -10dB to the current level, or -6dB.
            if (dblevel > dB2Scale(-10)) {
                g.setColour(Colour((uint8)160, (uint8)220, (uint8)20, (uint8)alpha));
                g.fillRect(x+1.0f, jmax(dB2y(fLevel), dB2y(-6)), (float)width-2, dB2y(-10)-jmax(dB2y(fLevel), dB2y(-6)));
            }
            // Drawing from -6dB to the current level, or -3dB.
            if (dblevel > dB2Scale(-6)) {
                g.setColour(Colour((uint8)220, (uint8)220, (uint8)20, (uint8)alpha));
                g.fillRect(x+1.0f, jmax(dB2y(fLevel), dB2y(-3)), (float)width-2, dB2y(-6)-jmax(dB2y(fLevel), dB2y(-3)));
            }
            // Drawing from -3dB to the current level, or 0dB.
            if (dblevel > dB2Scale(-3)) {
                g.setColour(Colour((uint8)240, (uint8)160, (uint8)20, (uint8)alpha));
                g.fillRect(x+1.0f, jmax(dB2y(fLevel), dB2y(0)), (float)width-2, dB2y(-3)-jmax(dB2y(fLevel), dB2y(0)));
            }
            // Drawing from 0dB to the current level, or the maximum range.
            if (dblevel > dB2Scale(0)) {
                g.setColour(Colour((uint8)240,  (uint8)0, (uint8)20, (uint8)alpha));
                g.fillRect(x+1.0f, jmax(dB2y(fLevel), dB2y(fMax)), (float)width-2, dB2y(0)-jmax(dB2y(fLevel), dB2y(fMax)));
            }
        }
        
        /**
         * Method in charge of drawing the level of a vertical linear VU-meter.
         *
         * \param   g       JUCE graphics context, used to draw components or images.
         * \param   x       x coordinate of the VU-meter.
         * \param   width   Width of the VU-meter.
         * \param   level   Current level of the VU-meter, in linear logic.
         */
        void drawVBargraphLin(Graphics& g, int x, int width)
        {
            int alpha = 200;
            Colour c = juce::Colour((uint8)255, (uint8)165, (uint8)0, (uint8)alpha);
            
            // Drawing from the minimal range to the current level, or 20% of the VU-meter.
            g.setColour(c.brighter());
            g.fillRect(x+1.0f, jmax(lin2y(fLevel), lin2y(0.2)), (float)width-2, lin2y(fMin)-jmax(lin2y(fLevel), lin2y(0.2)));
            
            // Drawing from 20% of the VU-meter to the current level, or 90% of the VU-meter.
            if (fLevel > 0.2f) {
                g.setColour(c);
                g.fillRect(x+1.0f, jmax(lin2y(fLevel), lin2y(0.9)), (float)width-2, lin2y(0.2)-jmax(lin2y(fLevel), lin2y(0.9)));
            }
            
            // Drawing from 90% of the VU-meter to the current level, or the maximum range.
            if (fLevel > 0.9f) {
                g.setColour(c.darker());
                g.fillRect(x+1.0f, jmax(lin2y(fLevel), lin2y(fMax)), (float)width-2, lin2y(0.9)-jmax(lin2y(fLevel), lin2y(fMax)));
            }
        }
        
        /**
         * Method in charge of drawing the LED VU-meter, dB or not.
         *
         * \param   g       JUCE graphics context, used to draw components or images.
         * \param   width   Width of the LED.
         * \param   height  Height of the LED.
         * \param   level   Current level of the VU-meter, dB or not.
         */
        void drawLed(Graphics& g, int width, int height)
        {
            float x = (float)(getWidth() - width)/2;
            float y = (float)(getHeight() - height)/2;
            g.setColour(Colours::black);
            g.fillEllipse(x, y, width, height);
            
            if (fDB) {
                int alpha = 200;
                FAUSTFLOAT dblevel = dB2Scale(fLevel);
                
                // Adjust the color depending on the current level
                g.setColour(Colour((uint8)40, (uint8)160, (uint8)40, (uint8)alpha));
                if (dblevel > dB2Scale(-10)) {
                    g.setColour(Colour((uint8)160, (uint8)220, (uint8)20, (uint8)alpha));
                }
                if (dblevel > dB2Scale(-6)) {
                    g.setColour(Colour((uint8)220, (uint8)220, (uint8)20, (uint8)alpha));
                }
                if (dblevel > dB2Scale(-3)) {
                    g.setColour(Colour((uint8)240, (uint8)160, (uint8)20, (uint8)alpha));
                }
                if (dblevel > dB2Scale(0))  {
                    g.setColour(Colour((uint8)240, (uint8)0, (uint8)20, (uint8)alpha));
                }
                
                g.fillEllipse(x+1, y+1, width-2, height-2);
            } else {
                // The alpha depend on the level, from 0 to 1
                g.setColour(Colours::red.withAlpha((float)fLevel));
                g.fillEllipse(x+1, y+1, width-2, height-2);
            }
        }
        
        /**
         * Method in charge of drawing the Numerical Display VU-meter, dB or not.
         *
         * \param   g       JUCE graphics context, used to draw components or images.
         * \param   width   Width of the Numerical Display.
         * \param   height  Height of the Numerical Display.
         * \param   level   Current level of the VU-meter.
         */
        void drawNumDisplay(Graphics& g, int width, int height)
        {
            // Centering it
            int x = (getWidth()-width) / 2;
            int y = (getHeight()-height) / 2;
            
            // Draw box.
            g.setColour(Colours::darkgrey);
            g.fillRect(x, y, width, height);
            g.setColour(Colours::white.withAlpha(0.8f));
            g.fillRect(x+1, y+1, width-2, height-2);
            
            // Text is handled by the setLabelPos() function
        }
        
        /** Convert a dB level to a y coordinate, for easier draw methods. */
        FAUSTFLOAT dB2y(FAUSTFLOAT dB)
        {
            FAUSTFLOAT s0 = fScaleMin;      // Minimal range.
            FAUSTFLOAT s1 = fScaleMax;      // Maximum range.
            FAUSTFLOAT sx = dB2Scale(dB);   // Current level.
            
            int h;
            int treshold;   // Value depend if the name is displayed
            
            if (isNameDisplayed()) {
                h = getHeight()-42; // 15 pixels for the VU-Meter name,
                // 25 for the textBox, 2 pixels margin.
                treshold = 16;      // 15 pixels for the VU-Meter name.
            } else {
                h = getHeight()-27; // 25 for the textBox, 2 pixels margin.
                treshold = 1;       // 1 pixel margin.
            }
            
            return (h - h*(s0-sx)/(s0-s1)) + treshold;
        }
        
        /** Convert a linear level to a y coordinate, for easier draw methods. */
        FAUSTFLOAT lin2y(FAUSTFLOAT level)
        {
            int h;
            int treshold;
            
            if (isNameDisplayed()) {
                h = getHeight()-42; // 15 pixels for the VU-Meter name,
                // 25 for the textBox, 2 pixels margin.
                treshold = 16;      // 15 pixels for the VU-Meter name.
            } else {
                h = getHeight()-27; // 25 for the textBox, 2 pixels margin.
                treshold = 1;       // 1 pixel margin.
            }
            
            return h * (1 - level) + treshold;
        }
        
        /** Convert a dB level to a x coordinate, for easier draw methods. */
        FAUSTFLOAT dB2x(FAUSTFLOAT dB)
        {
            FAUSTFLOAT s0 = fScaleMin;      // Minimal range.
            FAUSTFLOAT s1 = fScaleMax;      // Maximal range.
            FAUSTFLOAT sx = dB2Scale(dB);   // Current level.
            
            int w;
            int treshold;
            
            if (isNameDisplayed()) {
                w = getWidth()-122; // 60 pixels for the VU-Meter name,
                // 60 for the TextBox, 2 pixels margin.
                treshold = 121;     // 60 pixels for the VU-Meter name,
                // 60 for the TextBox, and 1 pixel margin.
            } else {
                w = getWidth()-62;  // 60 pixels for the TextBox, 2 pixels margin.
                treshold = 61;      // 60 pixels for the TextBox, 1 pixel margin.
            }
            
            return treshold + w - w*(s1-sx)/(s1-s0);
        }
        
        /** Write the different level included in the VU-Meter range. */
        void paintScale(Graphics& g, float num)
        {
            juce::Rectangle<int> r;
            
            if (fStyle == VVUMeter) {
                r = juce::Rectangle<int>((getWidth()-(kVBargraphWidth/2))/2 + 1,  // Left side of the VU-Meter.
                                         dB2y(num),                               // Vertically centred with 20 height.
                                         (kVBargraphWidth/2)-2,                   // VU-Meter width with margin.
                                         20);                                     // 20 height.
                g.drawText(String(num), r, Justification::centredRight, false);
            } else {
                r = juce::Rectangle<int>(dB2x(num)-10,                            // Horizontally centred with 20 width.
                                        (getHeight()-kHBargraphHeight/2)/2 + 1,  // Top side of the VU-Meter.
                                        20,                                      // 20 width.
                                        (kHBargraphHeight/2)-2);                 // VU-Meter height with margin
                g.drawText(String(num), r, Justification::centredTop, false);
            }
        }
        
        /** Set the level, keep it in the range of the VU-Meter, and set the TextBox text. */
        void setLevel()
        {
            FAUSTFLOAT rawLevel = *fZone;
            if (fDB) {
                fLevel = range(rawLevel);
            } else {
                fLevel = range((rawLevel-fMin)/(fMax-fMin));
            }
            fLabel.setText(String((int)rawLevel) + " " + fUnit, dontSendNotification);
        }
        
        FAUSTFLOAT range(FAUSTFLOAT level) { return (level > fMax) ? fMax : ((level < fMin) ? fMin : level); }
    
    public:
    
        /**
         * \brief   Constructor.
         * \details Initialize the uiComponent variables and the VU-meter specific ones.
         *
         * \param   gui, zone, w, h, tooltip, label     uiComponent variables.
         * \param   mini                                Minimal value of the VU-meter range.
         * \param   maxi                                Maximal value of the VU-meter range.
         * \param   unit                                Unit of the VU-meter (dB or not).
         * \param   style                               Type of the VU-meter (see VUMeterType).
         * \param   vert                                True if vertical, false if horizontal.
         */
        uiVUMeter (GUI* gui, FAUSTFLOAT* zone, FAUSTFLOAT w, FAUSTFLOAT h, String label, FAUSTFLOAT mini, FAUSTFLOAT maxi, String unit, String tooltip, VUMeterType style, bool vert)
            : uiComponent(gui, zone, w, h, label), fMin(mini), fMax(maxi), fStyle(style)
        {
            fLevel = 0;         // Initialization of the level
            startTimer(50);     // Launch a timer that trigger a callback every 50ms
            this->fUnit = unit;
            fDB = (unit == "dB");
            
            if (fDB) {
                // Conversion in dB of the range
                fScaleMin = dB2Scale(fMin);
                fScaleMax = dB2Scale(fMax);
            }
            setTooltip(tooltip);
            
            // No text editor for LEDs
            if (fStyle != Led) {
                setupLabel(tooltip);
            }
        }
        
        /** Method called by the timer every 50ms, to refresh the VU-meter if it needs to */
        void timerCallback() override
        {
            if (isShowing()) {
                //Force painting at the initialisation
                bool forceRepaint = (fLevel == 0);
                FAUSTFLOAT lastLevel = fLevel;   //t-1
                setLevel(); //t
                
                // Following condition means that we're repainting our VUMeter only if
                // there's one or more changing pixels between last state and this one,
                // and if the curent level is included in the VUMeter range. It improves
                // performances a lot in IDLE. It's the same for the other style of VUMeter
                
                if (fDB) {
                    switch (fStyle) {
                        case VVUMeter:
                            if (((int)dB2y(lastLevel) != (int)dB2y(fLevel) && fLevel >= fMin && fLevel <= fMax) || forceRepaint) {
                                repaint();
                            }
                            break;
                        case HVUMeter:
                            if (((int)dB2x(lastLevel) != (int)dB2x(fLevel) && fLevel >= fMin && fLevel <= fMax) || forceRepaint) {
                                repaint();
                            }
                            break;
                        case NumDisplay:
                            if (((int)lastLevel != (int)fLevel && fLevel >= fMin && fLevel <= fMax) || forceRepaint) {
                                repaint();
                            }
                            break;
                        case Led:
                            if ((dB2Scale(lastLevel) != dB2Scale(fLevel) && fLevel >= fMin && fLevel <= fMax) || forceRepaint) {
                                repaint();
                            }
                            break;
                        default:
                            break;
                    }
                } else {
                    switch (fStyle) {
                        case VVUMeter:
                            if (((int)lin2y(lastLevel) != (int)lin2y(fLevel) && fLevel >= fMin && fLevel <= fMax) || forceRepaint) {
                                repaint();
                            }
                            break;
                        case HVUMeter:
                            if ((std::abs(lastLevel-fLevel) > 0.01 && fLevel >= fMin && fLevel <= fMax) || forceRepaint) {
                                repaint();
                            }
                            break;
                        case NumDisplay:
                            if ((std::abs(lastLevel-fLevel) > 0.01 && fLevel >= fMin && fLevel <= fMax) || forceRepaint) {
                                repaint();
                            }
                            break;
                        case Led:
                            if (((int)lastLevel != (int)fLevel && fLevel >= fMin && fLevel <= fMax) || forceRepaint) {
                                repaint();
                            }
                            break;
                        default:
                            break;
                    }
                }
            } else {
                fLevel = 0;
            }
        }
        
        /**
         * Call the appropriate drawing method according to the VU-meter style
         * \see drawLed
         * \see drawNumDisplay
         * \see drawVBargraph
         * \see drawHBargraph
         */
        void paint(Graphics& g) override
        {
            switch (fStyle) {
                case Led:
                    drawLed(g, kLedWidth, kLedHeight);
                    break;
                case NumDisplay:
                    drawNumDisplay(g, kNumDisplayWidth, kNumDisplayHeight/2);
                    break;
                case VVUMeter:
                    drawVBargraph(g, kVBargraphWidth/2, getHeight());
                    break;
                case HVUMeter:
                    drawHBargraph(g, getWidth(), kHBargraphHeight/2);
                    break;
                default:
                    break;
            }
        }
        
        /** Set the Label position whenever the layout size changes. */
        void resized() override
        {
            setLabelPos();
        }
        
        void reflectZone() override
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
        }
    
};

/** Intern class for tab widget */
class uiTabBox : public uiBase, public TabbedComponent
{
    
public:
    /**
     * \brief   Constructor.
     * \details Initalize the juce::TabbedComponent tabs to be at top, and the uiTabBox size at 0
     */
    uiTabBox():uiBase(),TabbedComponent(TabbedButtonBar::TabsAtTop)
    {}
    
    /**
     * Initialize all his child ratios (1 uiBox per tabs), the LookAndFeel
     * and the uiTabBox size to fit the biggest of its child.
     */
    void init(Component* comp = nullptr) override
    {
        for (int i = 0; i < getNumTabs(); i++) {
            Component* comp = getTabContentComponent(i);
            uiBase* base_comp = dynamic_cast<uiBase*>(comp);
            base_comp->init(comp);
            
            // The TabbedComponent size should be as big as its bigger child's dimension, done here
            fTotalWidth = jmax(fTotalWidth, base_comp->getTotalWidth());
            fTotalHeight = jmax(fTotalHeight, base_comp->getTotalHeight());
        }
        
        fTotalHeight += 30;  // 30 height for the TabBar.
    }
    
    void setRecommendedSize() override
    {
        for (int i = 0; i < getNumTabs(); i++) {
            uiBase* comp = dynamic_cast<uiBase*>(getTabContentComponent(i));
            comp->setRecommendedSize();
            
            // The TabbedComponent size should be as big as its bigger child's dimension, done here
            fTotalWidth = jmax(fTotalWidth, comp->getTotalWidth());
            fTotalHeight = jmax(fTotalHeight, comp->getTotalHeight());
        }
        
        fTotalHeight += 30;  // 30 height for the TabBar
    }
    
    void add(Component* comp) override
    {
        // Name of the component is moved in Tab (so removed from component)
        TabbedComponent::addTab(comp->getName(), Colours::white, comp, true);
        comp->setName("");
    }
    
};

/**
 * \brief   Intern class for box widgets
 * \details That's the class where the whole layout is calculated.
 */
class uiBox : public uiBase, public Component
{
  
    private:
    
        bool fIsVertical;
    
        bool isNameDisplayed()
        {
            return (!(getName().startsWith("0x")) && getName().isNotEmpty());
        }
    
        /**
         * \brief   Return the vertical dimension size for a child to be displayed in.
         *
         */
        int getVSpaceToRemove()
        {
            // Checking if the name is displayed, to give to good amount space for child components
            // kNameHeight pixels is the bix name, kMargin pixel per child components for the margins
            if (isNameDisplayed()) {
                return (getHeight() - kNameHeight - kMargin * getNumChildComponents());
            } else {
                return (getHeight() - kMargin * getNumChildComponents());
            }
        }
    
        /**
         * \brief   Return the vertical dimension size for a child to be displayed in.
         *
         */
        int getHSpaceToRemove()
        {
            // Don't need to check for an horizontal box, as it height doesn't matter
            return (getWidth() - kMargin * getNumChildComponents());
        }
    
    public:
        /**
         * \brief   Constructor.
         * \details Initialize uiBase variables and uiBox specific ones.
         *
         * \param   vert        True if it's a vertical box, false otherwise.
         * \param   boxName     Name of the uiBox.
         */
        uiBox(bool vert, String boxName): uiBase(0,0), Component(boxName), fIsVertical(vert)
        {}
    
        /**
         * \brief   Destructor.
         * \details Delete all uiBox recusively, but not the uiComponent,
         *          because it's handled by the uiItem FAUST objects.
         */
        virtual ~uiBox()
        {
            /*
             Deleting boxes, from leaves to root:
             - leaves (uiComponent) are deleted by the uiItem mechanism
             - containers (uiBox and uiTabBox) have to be explicitly deleted
             */
            for (int i = getNumChildComponents()-1; i >= 0; i--) {
                delete dynamic_cast<uiBox*>(getChildComponent(i));
                delete dynamic_cast<uiTabBox*>(getChildComponent(i));
            }
        }

        /**
         * \brief   Initialization of the DisplayRect and Total size.
         * \details Calculate the correct size for each box, depending on its child sizes.
         */
        void setRecommendedSize() override
        {
            // Initialized each time
            fDisplayRectWidth = fDisplayRectHeight = 0;
            
            // Display rectangle size is the sum of a dimension on a side, and the max of the other one
            // on the other side, depending on its orientation (horizontal/vertical).
            // Using child's totalSize, because the display rectangle size need to be as big as
            // all of its child components with their margins included.
            for (int j = 0; j < getNumChildComponents(); j++) {
                uiBase* base_comp = dynamic_cast<uiBase*>(getChildComponent(j));
                if (fIsVertical) {
                    fDisplayRectWidth = jmax(fDisplayRectWidth, base_comp->getTotalWidth());
                    fDisplayRectHeight += base_comp->getTotalHeight();
                } else {
                    fDisplayRectWidth += base_comp->getTotalWidth();
                    fDisplayRectHeight = jmax(fDisplayRectHeight, base_comp->getTotalHeight());
                }
            }
            
            fTotalHeight = fDisplayRectHeight;
            fTotalWidth = fDisplayRectWidth;
            
            // Adding kMargin pixels of margins per child component on a dimension, and just kMargin on
            // the other one, depending on its orientation
            
            if (fIsVertical) {
                fTotalHeight += kMargin * getNumChildComponents();
                fTotalWidth += kMargin;
            } else {
                fTotalWidth += kMargin * getNumChildComponents();
                fTotalHeight += kMargin;
            }
         
            // Adding kNameHeight pixels on its height to allow the name to be displayed
            if (isNameDisplayed()) {
                fTotalHeight += kNameHeight;
            }
        }

        /** Initiate the current box ratio, and its child's ones recursively. */
        void init(Component* comp = nullptr) override
        {
            uiBase::init(this);
            
            // Going through the Component tree recursively
            for (int i = 0; i < getNumChildComponents(); i++) {
                Component* comp = getChildComponent(i);
                uiBase* base_comp = dynamic_cast<uiBase*>(comp);
                base_comp->init(comp);
            }
        }

        /**
         * \brief   Main layout function.
         * \details Allow to place all uiBase child correctly according to their ratios
         *          and the current box size.
         *
         * \param   displayRect    Absolute raw bounds of the current box (with margins
         *                          and space for the title).
         */
        void resized() override
        {
            juce::Rectangle<int> displayRect = getBounds();
            
            // Deleting space for the box name if it needs to be shown
            if (isNameDisplayed()) {
                displayRect.removeFromTop(kNameHeight);
            }
            
            // Putting the margins
            displayRect.reduce(kMargin/2, kMargin/2);
            
            // Give child components an adapt size depending on its ratio and the current box size
            for (int i = 0; i < getNumChildComponents(); i++) {
                Component* comp = getChildComponent(i);
                uiBase* base_comp = dynamic_cast<uiBase*>(comp);
                
                if (fIsVertical) {
                    int heightToRemove = getVSpaceToRemove() * base_comp->getVRatio();
                    // Remove the space needed from the displayRect, and translate it to show the margins
                    base_comp->setRelativeSize(comp, displayRect.removeFromTop(heightToRemove).translated(0, kMargin * i));
                } else {
                    int widthToRemove = getHSpaceToRemove() * base_comp->getHRatio();
                    // Remove the space needed from the displayRect, and translate it to show the margins
                    base_comp->setRelativeSize(comp, displayRect.removeFromLeft(widthToRemove).translated(kMargin * i, 0));
                }
            }
        }

        /** 
         * Fill the uiBox bounds with a grey color, different shades depending on its order.
         * Write the uiBox name if it needs to.
         */
        void paint(Graphics& g) override
        {
            // Fill the box background in gray shades
            g.setColour(Colours::black.withAlpha(0.05f));
            g.fillRect(getLocalBounds());

            // Display the name if it's needed
            if (isNameDisplayed()) {
                g.setColour(Colours::black);
                g.drawText(getName(), getLocalBounds().withHeight(kNameHeight), Justification::centred);
            }
        }
        
        void add(Component* comp) override
        {
            addAndMakeVisible(comp);
        }
    
};

/** Class in charge of doing the glue between FAUST and JUCE */
class JuceGUI : public GUI, public MetaDataUI, public Component
{
    
    private:
    
        bool fDefault = true;
        std::stack<uiBase*> fBoxStack;
        uiBase* fCurrentBox = nullptr;   // Current box used in buildUserInterface logic.
        
        int fRadioGroupID;               // In case of radio buttons.
        //ScopedPointer<LookAndFeel> fLaf = new CustomLookAndFeel();
        ScopedPointer<LookAndFeel> fLaf = new LookAndFeel_V4();
    
        FAUSTFLOAT defaultVal(FAUSTFLOAT* zone, FAUSTFLOAT def)
        {
            return (fDefault) ? def : *zone;
        }
    
        /** Add generic box to the user interface. */
        void openBox(uiBase* box)
        {
            if (fCurrentBox) {
                fCurrentBox->add(dynamic_cast<Component*>(box));
                fBoxStack.push(fCurrentBox);
            }
            fCurrentBox = box;
        }
     
        /** Add a slider to the user interface. */
        void addSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step, int kWidth, int kHeight, SliderType type)
        {
            if (isKnob(zone)) {
                addKnob(label, zone, defaultVal(zone, init), min, max, step);
            } else if (isRadio(zone)) {
                addRadioButtons(label, zone, defaultVal(zone, init), min, max, step, fRadioDescription[zone].c_str(), false);
            } else if (isMenu(zone)) {
                addMenu(label, zone, defaultVal(zone, init), min, max, step, fMenuDescription[zone].c_str());
            } else {
                fCurrentBox->add(new uiSlider(this, zone, kWidth, kHeight, defaultVal(zone, init), min, max, step, String(label), String(fUnit[zone]), String(fTooltip[zone]),  getScale(zone), type));
            }
        }
        
        /** Add a radio buttons to the user interface. */
        void addRadioButtons(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step, const char* mdescr, bool vert)
        {
            std::vector<std::string> names;
            std::vector<double> values;
            parseMenuList(mdescr, names, values); // Set names and values vectors
            
            // and not just n checkButtons :
            // TODO : check currently unused checkButtonWidth...
            int checkButtonWidth = 0;
            for (int i = 0; i < names.size(); i++) {
                // Checking the maximum of horizontal space needed to display the radio buttons
                checkButtonWidth = jmax(Font().getStringWidth(String(names[i])) + 15, checkButtonWidth);
            }
            
            if (vert) {
                fCurrentBox->add(new uiRadioButton(this, zone, String(label), kCheckButtonWidth, names.size() * (kRadioButtonHeight - 25) + 25, defaultVal(zone, init), min, max, true, names, values, String(fTooltip[zone]), fRadioGroupID++));
            } else {
                fCurrentBox->add(new uiRadioButton(this, zone, String(label), kCheckButtonWidth, kRadioButtonHeight, defaultVal(zone, init), min, max, false, names, values, String(fTooltip[zone]), fRadioGroupID++));
            }
        }
        
        /** Add a menu to the user interface. */
        void addMenu(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step, const char* mdescr)
        {
            fCurrentBox->add(new uiMenu(this, zone, String(label), kMenuWidth, kMenuHeight, defaultVal(zone, init), min, max, String(fTooltip[zone]), mdescr));
        }
        
        /** Add a ciruclar slider to the user interface. */
        void addKnob(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {
            fCurrentBox->add(new uiSlider(this, zone, kKnobWidth, kKnobHeight, defaultVal(zone, init), min, max, step, String(label), String(fUnit[zone]), String(fTooltip[zone]),  getScale(zone), Knob));
        }
        
        /** Add a bargraph to the user interface. */
        void addBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max, int kWidth, int kHeight, VUMeterType type)
        {
            if (isLed(zone)) {
                addLed(String(label), zone, min, max);
            } else if (isNumerical(zone)) {
                addNumericalDisplay(String(label), zone, min, max);
            } else {
                fCurrentBox->add(new uiVUMeter (this, zone, kWidth, kHeight, String(label), min, max, String(fUnit[zone]), String(fTooltip[zone]), type, false));
            }
        }
        
    public:
        /**
         * \brief   Constructor.
         * \details Initialize the JuceGUI specific variables. 
         */
        JuceGUI(bool def = true):fDefault(def), fRadioGroupID(1) // fRadioGroupID must start at 1
        {
            setLookAndFeel(fLaf);
        }
        
        /**
         * \brief   Destructor.
         * \details Delete root box used in buildUserInterface logic.
         */
        virtual ~JuceGUI()
        {
            setLookAndFeel(nullptr);
            delete fCurrentBox;
        }

        /** Return the size of the FAUST program */
        juce::Rectangle<int> getSize()
        {
            // Mininum size in case of empty GUI
            if (fCurrentBox) {
                juce::Rectangle<int> res = fCurrentBox->getSize();
                res.setSize(std::max<int>(1, res.getWidth()), std::max<int>(1, res.getHeight()));
                return res;
            } else {
                return juce::Rectangle<int>(0, 0, 1, 1);
            }
        }

        /** Initialize the uiTabBox component to be visible. */
        virtual void openTabBox(const char* label) override
        {
            openBox(new uiTabBox());
        }
        
        /** Add a new vertical box to the user interface. */
        virtual void openVerticalBox(const char* label) override
        {
            openBox(new uiBox(true, String(label)));
        }

        /** Add a new horizontal box to the user interface. */
        virtual void openHorizontalBox(const char* label) override
        {
            openBox(new uiBox(false, String(label)));
        }

        /** Close the current box. */
        virtual void closeBox() override
        {
            fCurrentBox->setRecommendedSize();
            
            if (fBoxStack.empty()) {
                // Add root box in JuceGUI component
                addAndMakeVisible(dynamic_cast<Component*>(fCurrentBox));
                fCurrentBox->init();
                // Force correct draw
                resized();
            } else {
                fCurrentBox = fBoxStack.top();
                fBoxStack.pop();
            }
        }
     
        /** Add an horizontal slider to the user interface. */
        virtual void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) override
        {
            addSlider(label, zone, init, min, max, step, kHSliderWidth, kHSliderHeight, HSlider);
        }
        
        /** Add a vertical slider to the user interface. */
        virtual void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) override
        {
            int newWidth = jmax(Font().getStringWidth(String(label)), kVSliderWidth) + kMargin;
            addSlider(label, zone, init, min, max, step, newWidth, kVSliderHeight, VSlider);
        }
        
        /** Add a button to the user interface. */
        virtual void addButton(const char* label, FAUSTFLOAT* zone) override
        {
            fCurrentBox->add(new uiButton(this, zone, kButtonWidth, kButtonHeight, String(label), String(fTooltip[zone])));
        }
        
        /** Add a check button to the user interface. */
        virtual void addCheckButton(const char* label, FAUSTFLOAT* zone) override
        {
            // newWidth is his text size, plus the check box size
            int newWidth = Font().getStringWidth(String(label)) + kCheckButtonWidth;
            fCurrentBox->add(new uiCheckButton(this, zone, newWidth, kCheckButtonHeight, String(label), String(fTooltip[zone])));
        }
        
        /** Add a numerical entry to the user interface. */
        virtual void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) override
        {
            // kMargin pixels between the slider and his name
            int newWidth = Font().getStringWidth(String(label)) + kNumEntryWidth + kMargin;
            fCurrentBox->add(new uiSlider(this, zone, newWidth, kNumEntryHeight, defaultVal(zone, init), min, max, step, String(label), String(fUnit[zone]), String(fTooltip[zone]), getScale(zone), NumEntry));
        }
        
        /** Add a vertical bargraph to the user interface. */
        virtual void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) override
        {
            addBargraph(label, zone, min, max, kVBargraphWidth, kVBargraphHeight, VVUMeter);
        }
        
        /** Add a vertical bargraph to the user interface. */
        virtual void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) override
        {
            addBargraph(label, zone, min, max, kHBargraphWidth, kHBargraphHeight, HVUMeter);
        }
      
        /** Add a LED to the user interface. */
        void addLed(String label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
        {
            fCurrentBox->add(new uiVUMeter(this, zone, kLedWidth, kLedHeight, label, min, max, String(fUnit[zone]), String(fTooltip[zone]), Led, false));
        }
        
        /** Add a numerical display to the user interface. */
        void addNumericalDisplay(String label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) {
            fCurrentBox->add(new uiVUMeter(this, zone, kNumDisplayWidth, kNumDisplayHeight, label, min, max, String(fUnit[zone]), String(fTooltip[zone]), NumDisplay, false));
        }
        
        /** Declare a metadata. */
        virtual void declare(FAUSTFLOAT* zone, const char* key, const char* value) override
        {
            MetaDataUI::declare(zone, key, value);
        }

        /** Resize its child to match the new bounds */
        void resized() override
        {
            if (fCurrentBox) {
                dynamic_cast<Component*>(fCurrentBox)->setBounds(getLocalBounds());
            }
        }
    
};
/**************************  END  JuceGUI.h **************************/
/************************** BEGIN JuceParameterUI.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef JuceParameterUI_H
#define JuceParameterUI_H

#include "../JuceLibraryCode/JuceHeader.h"


// Link AudioParameterBool with on/off parameter

struct FaustPlugInAudioParameterBool : public AudioParameterBool, public uiOwnedItem {
    
    FaustPlugInAudioParameterBool(GUI* gui, FAUSTFLOAT* zone, const std::string& path, const std::string& label)
    :AudioParameterBool(path, label, false), uiOwnedItem(gui, zone)
    {}
    
    virtual ~FaustPlugInAudioParameterBool() {}
    
    void reflectZone() override
    {
        FAUSTFLOAT v = *fZone;
        fCache = v;
        setValueNotifyingHost(float(v));
    }
    
    virtual void setValue (float newValue) override
    {
        modifyZone(FAUSTFLOAT(newValue));
    }
    
};

// Link AudioParameterFloat with range parameters

struct FaustPlugInAudioParameterFloat : public AudioParameterFloat, public uiOwnedItem {
    
    FaustPlugInAudioParameterFloat(GUI* gui, FAUSTFLOAT* zone, const std::string& path, const std::string& label, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
    :AudioParameterFloat(path, label, float(min), float(max), float(init)), uiOwnedItem(gui, zone)
    {}
    
    virtual ~FaustPlugInAudioParameterFloat() {}
    
    void reflectZone() override
    {
        FAUSTFLOAT v = *fZone;
        fCache = v;
        if (v >= range.start && v <= range.end) {
            setValueNotifyingHost(range.convertTo0to1(float(v)));
        }
    }
    
    virtual void setValue (float newValue) override
    {
        modifyZone(FAUSTFLOAT(range.convertFrom0to1(newValue)));
    }
    
};

// A class to create AudioProcessorParameter objects for each zone

class JuceParameterUI : public GUI, public PathBuilder {
    
    private:
        
        AudioProcessor* fProcessor;
        
    public:
        
        JuceParameterUI(AudioProcessor* processor):fProcessor(processor)
        {}
    
        virtual ~JuceParameterUI() {}
        
        // -- widget's layouts
        
        virtual void openTabBox(const char* label)
        {
            pushLabel(label);
        }
        virtual void openHorizontalBox(const char* label)
        {
            pushLabel(label);
        }
        virtual void openVerticalBox(const char* label)
        {
            pushLabel(label);
        }
        virtual void closeBox()
        {
            popLabel();
        }
        
        // -- active widgets
        
        virtual void addButton(const char* label, FAUSTFLOAT* zone)
        {
            fProcessor->addParameter(new FaustPlugInAudioParameterBool(this, zone, buildPath(label), label));
        }
        virtual void addCheckButton(const char* label, FAUSTFLOAT* zone)
        {
            fProcessor->addParameter(new FaustPlugInAudioParameterBool(this, zone, buildPath(label), label));
        }
        
        virtual void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        {
            fProcessor->addParameter(new FaustPlugInAudioParameterFloat(this, zone, buildPath(label), label, init, min, max, step));
        }
        
        virtual void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        {
            fProcessor->addParameter(new FaustPlugInAudioParameterFloat(this, zone, buildPath(label), label, init, min, max, step));
        }
        
        virtual void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        {
            fProcessor->addParameter(new FaustPlugInAudioParameterFloat(this, zone, buildPath(label), label, init, min, max, step));
        }
        
        // -- passive widgets
        
        virtual void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
        {
            fProcessor->addParameter(new FaustPlugInAudioParameterFloat(this, zone, buildPath(label), label, 0, min, max, 0));
        }
        
        virtual void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
        {
            fProcessor->addParameter(new FaustPlugInAudioParameterFloat(this, zone, buildPath(label), label, 0, min, max, 0));
        }
    
};

#endif
/**************************  END  JuceParameterUI.h **************************/
/************************** BEGIN JuceStateUI.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef JuceStateUI_H
#define JuceStateUI_H

#include "../JuceLibraryCode/JuceHeader.h"


// A class to save/restore DSP state using JUCE, which also set default values at construction time.

class JuceStateUI : public MapUI {
    
    public:
        
        JuceStateUI() {}
        virtual ~JuceStateUI() {}
        
        void getStateInformation (MemoryBlock& destData)
        {
            MemoryOutputStream stream (destData, true);
            
            // Write path and values
            std::map<std::string, FAUSTFLOAT*>::iterator it;
            if (sizeof(FAUSTFLOAT) == sizeof(float)) {
                for (it = fPathZoneMap.begin(); it != fPathZoneMap.end(); ++it) {
                    stream.writeString((*it).first);
                    stream.writeFloat(*(*it).second);
                }
            } else {
                for (it = fPathZoneMap.begin(); it != fPathZoneMap.end(); ++it) {
                    stream.writeString((*it).first);
                    stream.writeDouble(*(*it).second);
                }
            }
        }
        
        void setStateInformation (const void* data, int sizeInBytes)
        {
            MemoryInputStream stream (data, static_cast<size_t> (sizeInBytes), false);
            std::string path;
            
            // Read path then value and try to restore them
            if (sizeof(FAUSTFLOAT) == sizeof(float)) {
                while ((path = stream.readString().toStdString()) != "") {
                    setParamValue(path, stream.readFloat());
                }
            } else {
                while ((path = stream.readString().toStdString()) != "") {
                    setParamValue(path, stream.readDouble());
                }
            }
        }
        
        // -- active widgets
        // use MapUI derived methods
        
        // -- passive widgets
        // empty si we don't want to save/restore them
        void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT fmin, FAUSTFLOAT fmax) {}
        void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT fmin, FAUSTFLOAT fmax) {}
    
};

#endif
/**************************  END  JuceStateUI.h **************************/

// Always included otherwise -i mode sometimes fails...
/************************** BEGIN DecoratorUI.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef Decorator_UI_H
#define Decorator_UI_H


//----------------------------------------------------------------
//  Generic UI empty implementation
//----------------------------------------------------------------

class GenericUI : public UI
{
    
    public:
        
        GenericUI() {}
        virtual ~GenericUI() {}
        
        // -- widget's layouts
        virtual void openTabBox(const char* label) {}
        virtual void openHorizontalBox(const char* label) {}
        virtual void openVerticalBox(const char* label) {}
        virtual void closeBox() {}
        
        // -- active widgets
        virtual void addButton(const char* label, FAUSTFLOAT* zone) {}
        virtual void addCheckButton(const char* label, FAUSTFLOAT* zone) {}
        virtual void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
        virtual void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
        virtual void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
    
        // -- passive widgets
        virtual void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) {}
        virtual void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) {}
    
        // -- soundfiles
        virtual void addSoundfile(const char* label, const char* soundpath, Soundfile** sf_zone) {}
    
        virtual void declare(FAUSTFLOAT* zone, const char* key, const char* val) {}
    
};

//----------------------------------------------------------------
//  Generic UI decorator
//----------------------------------------------------------------

class DecoratorUI : public UI
{
    
    protected:
        
        UI* fUI;
        
    public:
        
        DecoratorUI(UI* ui = 0):fUI(ui) {}
        virtual ~DecoratorUI() { delete fUI; }
        
        // -- widget's layouts
        virtual void openTabBox(const char* label)          { fUI->openTabBox(label); }
        virtual void openHorizontalBox(const char* label)   { fUI->openHorizontalBox(label); }
        virtual void openVerticalBox(const char* label)     { fUI->openVerticalBox(label); }
        virtual void closeBox()                             { fUI->closeBox(); }
        
        // -- active widgets
        virtual void addButton(const char* label, FAUSTFLOAT* zone)         { fUI->addButton(label, zone); }
        virtual void addCheckButton(const char* label, FAUSTFLOAT* zone)    { fUI->addCheckButton(label, zone); }
        virtual void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        { fUI->addVerticalSlider(label, zone, init, min, max, step); }
        virtual void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        { fUI->addHorizontalSlider(label, zone, init, min, max, step); }
        virtual void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        { fUI->addNumEntry(label, zone, init, min, max, step); }
        
        // -- passive widgets
        virtual void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
        { fUI->addHorizontalBargraph(label, zone, min, max); }
        virtual void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
        { fUI->addVerticalBargraph(label, zone, min, max); }
    
        // -- soundfiles
        virtual void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone) { fUI->addSoundfile(label, filename, sf_zone); }
    
        virtual void declare(FAUSTFLOAT* zone, const char* key, const char* val) { fUI->declare(zone, key, val); }
    
};

#endif
/**************************  END  DecoratorUI.h **************************/

#if defined(SOUNDFILE)
/************************** BEGIN SoundUI.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2018 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/
 
#ifndef __SoundUI_H__
#define __SoundUI_H__

#include <map>
#include <vector>
#include <string>


#ifdef __APPLE__
#include <CoreFoundation/CFBundle.h>
#endif

// Always included otherwise -i mode later on will not always include it (with the conditional includes)
/************************** BEGIN Soundfile.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.

 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __Soundfile__
#define __Soundfile__

#include <iostream>
#include <string.h>

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif

#define BUFFER_SIZE 16384
#define SAMPLE_RATE 44100
#define MAX_CHAN 64
#define MAX_SOUNDFILE_PARTS 256

#ifdef _MSC_VER
#define PRE_PACKED_STRUCTURE __pragma(pack(push, 1))
#define POST_PACKED_STRUCTURE \
    ;                         \
    __pragma(pack(pop))
#else
#define PRE_PACKED_STRUCTURE
#define POST_PACKED_STRUCTURE __attribute__((__packed__))
#endif

/*
 The soundfile structure to be used by the DSP code. Soundfile has a MAX_SOUNDFILE_PARTS parts 
 (even a single soundfile or an empty soundfile). 
 fLength, fOffset and fSR fields are filled accordingly by repeating
 the actual parts if needed.
 
 It has to be 'packed' to that the LLVM backend can correctly access it.

 Index computation:
    - p is the current part number [0..MAX_SOUNDFILE_PARTS-1] (must be proved by the type system)
    - i is the current position in the part. It will be constrained between [0..length]
    - idx(p,i) = fOffset[p] + max(0, min(i, fLength[p]));
*/

PRE_PACKED_STRUCTURE
struct Soundfile {
    FAUSTFLOAT** fBuffers;
    int* fLength;   // length of each part
    int* fSR;       // sample rate of each part
    int* fOffset;   // offset of each part in the global buffer
    int fChannels;  // max number of channels of all concatenated files

    Soundfile()
    {
        fBuffers  = NULL;
        fChannels = -1;
        fLength   = new int[MAX_SOUNDFILE_PARTS];
        fSR       = new int[MAX_SOUNDFILE_PARTS];
        fOffset   = new int[MAX_SOUNDFILE_PARTS];
    }

    ~Soundfile()
    {
        // Free the real channels only
        for (int chan = 0; chan < fChannels; chan++) {
            delete fBuffers[chan];
        }
        delete[] fBuffers;
        delete[] fLength;
        delete[] fSR;
        delete[] fOffset;
    }

} POST_PACKED_STRUCTURE;

/*
 The generic soundfile reader.
 */

class SoundfileReader {
    
   protected:
    
    int fDriverSR;
    
    void emptyFile(Soundfile* soundfile, int part, int& offset)
    {
        soundfile->fLength[part] = BUFFER_SIZE;
        soundfile->fSR[part] = SAMPLE_RATE;
        soundfile->fOffset[part] = offset;
        // Update offset
        offset += soundfile->fLength[part];
    }

    Soundfile* createSoundfile(int cur_chan, int length, int max_chan)
    {
        Soundfile* soundfile = new Soundfile();
        if (!soundfile) {
            throw std::bad_alloc();
        }
        
        soundfile->fBuffers = new FAUSTFLOAT*[max_chan];
        if (!soundfile->fBuffers) {
            throw std::bad_alloc();
        }
        
        for (int chan = 0; chan < cur_chan; chan++) {
            soundfile->fBuffers[chan] = new FAUSTFLOAT[length];
            if (!soundfile->fBuffers[chan]) {
                throw std::bad_alloc();
            }
            memset(soundfile->fBuffers[chan], 0, sizeof(FAUSTFLOAT) * length);
        }
        
        soundfile->fChannels = cur_chan;
        return soundfile;
    }

    void getBuffersOffset(Soundfile* soundfile, FAUSTFLOAT** buffers, int offset)
    {
        for (int chan = 0; chan < soundfile->fChannels; chan++) {
            buffers[chan] = &soundfile->fBuffers[chan][offset];
        }
    }
    
    // Check if a soundfile exists and return its real path_name
    std::string checkFile(const std::vector<std::string>& sound_directories, const std::string& file_name)
    {
        if (checkFile(file_name)) {
            return file_name;
        } else {
            for (size_t i = 0; i < sound_directories.size(); i++) {
                std::string path_name = sound_directories[i] + "/" + file_name;
                if (checkFile(path_name)) { return path_name; }
            }
            return "";
        }
    }
    
    bool isResampling(int sample_rate) { return (fDriverSR > 0 && fDriverSR != sample_rate); }
 
    // To be implemented by subclasses

    /**
     * Check the availability of a sound resource.
     *
     * @param path_name - the name of the file, or sound resource identified this way
     *
     * @return true if the sound resource is available, false otherwise.
     */
    virtual bool checkFile(const std::string& path_name) = 0;
    
    /**
     * Check the availability of a sound resource.
     *
     * @param buffer - the sound buffer
     * @param buffer - the sound buffer length
     *
     * @return true if the sound resource is available, false otherwise.
     */

    virtual bool checkFile(unsigned char* buffer, size_t length) { return true; }

    /**
     * Get the channels and length values of the given sound resource.
     *
     * @param path_name - the name of the file, or sound resource identified this way
     * @param channels - the channels value to be filled with the sound resource number of channels
     * @param length - the length value to be filled with the sound resource length in frames
     *
     */
    virtual void getParamsFile(const std::string& path_name, int& channels, int& length) = 0;
    
    /**
     * Get the channels and length values of the given sound resource.
     *
     * @param buffer - the sound buffer
     * @param buffer - the sound buffer length
     * @param channels - the channels value to be filled with the sound resource number of channels
     * @param length - the length value to be filled with the sound resource length in frames
     *
     */
    virtual void getParamsFile(unsigned char* buffer, size_t size, int& channels, int& length) {}

    /**
     * Read one sound resource and fill the 'soundfile' structure accordingly
     *
     * @param path_name - the name of the file, or sound resource identified this way
     * @param part - the part number to be filled in the soundfile
     * @param offset - the offset value to be incremented with the actual sound resource length in frames
     * @param max_chan - the maximum number of mono channels to fill
     *
     */
    virtual void readFile(Soundfile* soundfile, const std::string& path_name, int part, int& offset, int max_chan) = 0;
    
    /**
     * Read one sound resource and fill the 'soundfile' structure accordingly
     *
     * @param buffer - the sound buffer
     * @param buffer - the sound buffer length
     * @param part - the part number to be filled in the soundfile
     * @param offset - the offset value to be incremented with the actual sound resource length in frames
     * @param max_chan - the maximum number of mono channels to fill
     *
     */
    virtual void readFile(Soundfile* soundfile, unsigned char* buffer, size_t length, int part, int& offset, int max_chan) {}

  public:
    
    virtual ~SoundfileReader() {}
    
    void setSampleRate(int sample_rate) { fDriverSR = sample_rate; }
   
    Soundfile* createSoundfile(const std::vector<std::string>& path_name_list, int max_chan)
    {
        try {
            int cur_chan = 1; // At least one buffer
            int total_length = 0;
            
            // Compute total length and channels max of all files
            for (int i = 0; i < int(path_name_list.size()); i++) {
                int chan, length;
                if (path_name_list[i] == "__empty_sound__") {
                    length = BUFFER_SIZE;
                    chan = 1;
                } else {
                    getParamsFile(path_name_list[i], chan, length);
                }
                cur_chan = std::max<int>(cur_chan, chan);
                total_length += length;
            }
           
            // Complete with empty parts
            total_length += (MAX_SOUNDFILE_PARTS - path_name_list.size()) * BUFFER_SIZE;
            
            // Create the soundfile
            Soundfile* soundfile = createSoundfile(cur_chan, total_length, max_chan);
            
            // Init offset
            int offset = 0;
            
            // Read all files
            for (int i = 0; i < int(path_name_list.size()); i++) {
                if (path_name_list[i] == "__empty_sound__") {
                    emptyFile(soundfile, i, offset);
                } else {
                    readFile(soundfile, path_name_list[i], i, offset, max_chan);
                }
            }
            
            // Complete with empty parts
            for (int i = int(path_name_list.size()); i < MAX_SOUNDFILE_PARTS; i++) {
                emptyFile(soundfile, i, offset);
            }
            
            // Share the same buffers for all other channels so that we have max_chan channels available
            for (int chan = cur_chan; chan < max_chan; chan++) {
                soundfile->fBuffers[chan] = soundfile->fBuffers[chan % cur_chan];
            }
            
            return soundfile;
            
        } catch (...) {
            return NULL;
        }
    }

    // Check if all soundfiles exist and return their real path_name
    std::vector<std::string> checkFiles(const std::vector<std::string>& sound_directories,
                                        const std::vector<std::string>& file_name_list)
    {
        std::vector<std::string> path_name_list;
        for (size_t i = 0; i < file_name_list.size(); i++) {
            std::string path_name = checkFile(sound_directories, file_name_list[i]);
            // If 'path_name' is not found, it is replaced by an empty sound (= silence)
            path_name_list.push_back((path_name == "") ? "__empty_sound__" : path_name);
        }
        return path_name_list;
    }

};

#endif
/**************************  END  Soundfile.h **************************/

#if defined(JUCE_32BIT) || defined(JUCE_64BIT)
/************************** BEGIN JuceReader.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2018 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __JuceReader__
#define __JuceReader__

#include <assert.h>


struct JuceReader : public SoundfileReader {
    
    AudioFormatManager fFormatManager;
    
    JuceReader() { fFormatManager.registerBasicFormats(); }
    
    bool checkFile(const std::string& path_name)
    {
        File file(path_name);
        if (file.existsAsFile()) {
            return true;
        } else {
            std::cerr << "ERROR : cannot open '" << path_name << "'" << std::endl;
            return false;
        }
    }
    
    void getParamsFile(const std::string& path_name, int& channels, int& length)
    {
        ScopedPointer<AudioFormatReader> formatReader = fFormatManager.createReaderFor(File(path_name));
        assert(formatReader);
        channels = int(formatReader->numChannels);
        length = int(formatReader->lengthInSamples);
    }
    
    void readFile(Soundfile* soundfile, const std::string& path_name, int part, int& offset, int max_chan)
    {
        ScopedPointer<AudioFormatReader> formatReader = fFormatManager.createReaderFor(File(path_name));
        
        int channels = std::min<int>(max_chan, int(formatReader->numChannels));
        
        soundfile->fLength[part] = int(formatReader->lengthInSamples);
        soundfile->fSR[part] = int(formatReader->sampleRate);
        soundfile->fOffset[part] = offset;
        
        FAUSTFLOAT* buffers[soundfile->fChannels];
        getBuffersOffset(soundfile, buffers, offset);
        
        if (formatReader->read(reinterpret_cast<int *const *>(buffers), int(formatReader->numChannels), 0, int(formatReader->lengthInSamples), false)) {
            
            // Possibly concert samples
            if (!formatReader->usesFloatingPointData) {
                for (int chan = 0; chan < int(formatReader->numChannels); ++chan) {
                    FAUSTFLOAT* buffer = &soundfile->fBuffers[chan][soundfile->fOffset[part]];
                    FloatVectorOperations::convertFixedToFloat(buffer, reinterpret_cast<const int*>(buffer), 1.0f/0x7fffffff, int(formatReader->lengthInSamples));
                }
            }
            
        } else {
            std::cerr << "Error reading the file : " << path_name << std::endl;
        }
            
        // Update offset
        offset += soundfile->fLength[part];
    }
    
};

#endif
/**************************  END  JuceReader.h **************************/
JuceReader gReader;
#elif defined(MEMORY_READER)
/************************** BEGIN MemoryReader.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2018 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __MemoryReader__
#define __MemoryReader__


/*
 A 'MemoryReader' object can be used to prepare a set of sound resources in memory, to be used by SoundUI::addSoundfile.
 
 A Soundfile* object will have to be filled with a list of sound resources: the fLength, fOffset, fSampleRate and fBuffers fields 
 have to be completed with the appropriate values, and will be accessed in the DSP object while running.
 *
 */

// To adapt for a real case use

#define SOUND_CHAN      2
#define SOUND_LENGTH    4096
#define SOUND_SR        40100

struct MemoryReader : public SoundfileReader {
    
    MemoryReader()
    {}
    
    /**
     * Check the availability of a sound resource.
     *
     * @param path_name - the name of the file, or sound resource identified this way
     *
     * @return true if the sound resource is available, false otherwise.
     */
    virtual bool checkFile(const std::string& path_name) { return true; }
    
    /**
     * Get the channels and length values of the given sound resource.
     *
     * @param path_name - the name of the file, or sound resource identified this way
     * @param channels - the channels value to be filled with the sound resource number of channels
     * @param length - the length value to be filled with the sound resource length in frames
     *
     */
    virtual void getParamsFile(const std::string& path_name, int& channels, int& length)
    {
        channels = SOUND_CHAN;
        length = SOUND_LENGTH;
    }
    
    /**
     * Read one sound resource and fill the 'soundfile' structure accordingly
     *
     * @param path_name - the name of the file, or sound resource identified this way
     * @param part - the part number to be filled in the soundfile
     * @param offset - the offset value to be incremented with the actual sound resource length in frames
     * @param max_chan - the maximum number of mono channels to fill
     *
     */
    virtual void readFile(Soundfile* soundfile, const std::string& path_name, int part, int& offset, int max_chan)
    {
        soundfile->fLength[part] = SOUND_LENGTH;
        soundfile->fSR[part] = SOUND_SR;
        soundfile->fOffset[part] = offset;
        
        // Audio frames have to be written for each chan
        for (int sample = 0; sample < SOUND_LENGTH; sample++) {
            for (int chan = 0; chan < SOUND_CHAN; chan++) {
                soundfile->fBuffers[chan][offset + sample] = 0.f;
            }
        }
        
        // Update offset
        offset += SOUND_LENGTH;
    }
    
};

#endif
/**************************  END  MemoryReader.h **************************/
MemoryReader gReader;
#else
/************************** BEGIN LibsndfileReader.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2018 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __LibsndfileReader__
#define __LibsndfileReader__

#ifdef SAMPLERATE
#include <samplerate.h>
#endif
#include <sndfile.h>
#include <string.h>
#include <assert.h>
#include <iostream>


struct VFLibsndfile {
    
    #define SIGNED_SIZEOF(x) ((int)sizeof(x))
    
    unsigned char* fBuffer;
    size_t fLength;
    size_t fOffset;
    SF_VIRTUAL_IO fVIO;
    
    VFLibsndfile(unsigned char* buffer, size_t length):fBuffer(buffer), fLength(length), fOffset(0)
    {
        fVIO.get_filelen = vfget_filelen;
        fVIO.seek = vfseek;
        fVIO.read = vfread;
        fVIO.write = vfwrite;
        fVIO.tell = vftell;
    }
    
    static sf_count_t vfget_filelen(void* user_data)
    {
        VFLibsndfile* vf = static_cast<VFLibsndfile*>(user_data);
        return vf->fLength;
    }
  
    static sf_count_t vfseek(sf_count_t offset, int whence, void* user_data)
    {
        VFLibsndfile* vf = static_cast<VFLibsndfile*>(user_data);
        switch (whence) {
            case SEEK_SET:
                vf->fOffset = offset;
                break;
                
            case SEEK_CUR:
                vf->fOffset = vf->fOffset + offset;
                break;
                
            case SEEK_END:
                vf->fOffset = vf->fLength + offset;
                break;
                
            default:
                break;
        };
        
        return vf->fOffset;
    }
    
    static sf_count_t vfread(void* ptr, sf_count_t count, void* user_data)
    {
        VFLibsndfile* vf = static_cast<VFLibsndfile*>(user_data);
        
        /*
         **	This will break badly for files over 2Gig in length, but
         **	is sufficient for testing.
         */
        if (vf->fOffset + count > vf->fLength) {
            count = vf->fLength - vf->fOffset;
        }
        
        memcpy(ptr, vf->fBuffer + vf->fOffset, count);
        vf->fOffset += count;
        
        return count;
    }
    
    static sf_count_t vfwrite(const void* ptr, sf_count_t count, void* user_data)
    {
        VFLibsndfile* vf = static_cast<VFLibsndfile*>(user_data);
        
        /*
         **	This will break badly for files over 2Gig in length, but
         **	is sufficient for testing.
         */
        if (vf->fOffset >= SIGNED_SIZEOF(vf->fBuffer)) {
            return 0;
        }
        
        if (vf->fOffset + count > SIGNED_SIZEOF(vf->fBuffer)) {
            count = sizeof (vf->fBuffer) - vf->fOffset;
        }
        
        memcpy(vf->fBuffer + vf->fOffset, ptr, (size_t)count);
        vf->fOffset += count;
        
        if (vf->fOffset > vf->fLength) {
            vf->fLength = vf->fOffset;
        }
        
        return count;
    }
    
    static sf_count_t vftell(void* user_data)
    {
        VFLibsndfile* vf = static_cast<VFLibsndfile*>(user_data);
        return vf->fOffset;
    }
 
};

struct LibsndfileReader : public SoundfileReader {
	
    LibsndfileReader() {}
	
    typedef sf_count_t (* sample_read)(SNDFILE* sndfile, FAUSTFLOAT* ptr, sf_count_t frames);
	
    // Check file
    bool checkFile(const std::string& path_name)
    {
        SF_INFO snd_info;
        snd_info.format = 0;
        SNDFILE* snd_file = sf_open(path_name.c_str(), SFM_READ, &snd_info);
        return checkFileAux(snd_file, path_name);
    }
    
    bool checkFile(unsigned char* buffer, size_t length)
    {
        SF_INFO snd_info;
        snd_info.format = 0;
        VFLibsndfile vio(buffer, length);
        SNDFILE* snd_file = sf_open_virtual(&vio.fVIO, SFM_READ, &snd_info, &vio);
        return checkFileAux(snd_file, "virtual file");
    }
    
    bool checkFileAux(SNDFILE* snd_file, const std::string& path_name)
    {
        if (snd_file) {
            sf_close(snd_file);
            return true;
        } else {
            std::cerr << "ERROR : cannot open '" << path_name << "' (" << sf_strerror(NULL) << ")" << std::endl;
            return false;
        }
    }

    // Open the file and returns its length and channels
    void getParamsFile(const std::string& path_name, int& channels, int& length)
    {
        SF_INFO	snd_info;
        snd_info.format = 0;
        SNDFILE* snd_file = sf_open(path_name.c_str(), SFM_READ, &snd_info);
        getParamsFileAux(snd_file, snd_info, channels, length);
    }
    
    void getParamsFile(unsigned char* buffer, size_t size, int& channels, int& length)
    {
        SF_INFO	snd_info;
        snd_info.format = 0;
        VFLibsndfile vio(buffer, size);
        SNDFILE* snd_file = sf_open_virtual(&vio.fVIO, SFM_READ, &snd_info, &vio);
        getParamsFileAux(snd_file, snd_info, channels, length);
    }
    
    void getParamsFileAux(SNDFILE* snd_file, const SF_INFO& snd_info, int& channels, int& length)
    {
        assert(snd_file);
        channels = int(snd_info.channels);
    #ifdef SAMPLERATE
        length = (isResampling(snd_info.samplerate)) ? ((double(snd_info.frames) * double(fDriverSR) / double(snd_info.samplerate)) + BUFFER_SIZE) : int(snd_info.frames);
    #else
        length = int(snd_info.frames);
    #endif
        sf_close(snd_file);
    }
    
    // Read the file
    void copyToOut(Soundfile* soundfile, int size, int channels, int max_channels, int offset, FAUSTFLOAT* buffer)
    {
        for (int sample = 0; sample < size; sample++) {
            for (int chan = 0; chan < channels; chan++) {
                soundfile->fBuffers[chan][offset + sample] = buffer[sample * max_channels + chan];
            }
        }
    }
    
    void readFile(Soundfile* soundfile, const std::string& path_name, int part, int& offset, int max_chan)
    {
        SF_INFO	snd_info;
        snd_info.format = 0;
        SNDFILE* snd_file = sf_open(path_name.c_str(), SFM_READ, &snd_info);
        readFileAux(soundfile, snd_file, snd_info, part, offset, max_chan);
    }
    
    void readFile(Soundfile* soundfile, unsigned char* buffer, size_t length, int part, int& offset, int max_chan)
    {
        SF_INFO	snd_info;
        snd_info.format = 0;
        VFLibsndfile vio(buffer, length);
        SNDFILE* snd_file = sf_open_virtual(&vio.fVIO, SFM_READ, &snd_info, &vio);
        readFileAux(soundfile, snd_file, snd_info, part, offset, max_chan);
    }
	
    // Will be called to fill all parts from 0 to MAX_SOUNDFILE_PARTS-1
    void readFileAux(Soundfile* soundfile, SNDFILE* snd_file, const SF_INFO& snd_info, int part, int& offset, int max_chan)
    {
        assert(snd_file);
        int channels = std::min<int>(max_chan, snd_info.channels);
    #ifdef SAMPLERATE
        if (isResampling(snd_info.samplerate)) {
            soundfile->fLength[part] = int(double(snd_info.frames) * double(fDriverSR) / double(snd_info.samplerate));
            soundfile->fSR[part] = fDriverSR;
        } else {
            soundfile->fLength[part] = int(snd_info.frames);
            soundfile->fSR[part] = snd_info.samplerate;
        }
    #else
        soundfile->fLength[part] = int(snd_info.frames);
        soundfile->fSR[part] = snd_info.samplerate;
    #endif
        soundfile->fOffset[part] = offset;
		
        // Read and fill snd_info.channels number of channels
        sf_count_t nbf;
        FAUSTFLOAT* buffer_in = (FAUSTFLOAT*)alloca(BUFFER_SIZE * sizeof(FAUSTFLOAT) * snd_info.channels);
        sample_read reader;
        
        if (sizeof(FAUSTFLOAT) == 4) {
            reader = reinterpret_cast<sample_read>(sf_readf_float);
        } else {
            reader = reinterpret_cast<sample_read>(sf_readf_double);
        }
        
    #ifdef SAMPLERATE
        // Resampling
        SRC_STATE* resampler = nullptr;
        FAUSTFLOAT* buffer_out = nullptr;
        if  (isResampling(snd_info.samplerate)) {
            int error;
            resampler = src_new(SRC_SINC_FASTEST, channels, &error);
            if (error != 0) {
                std::cerr << "ERROR : src_new " << src_strerror(error) << std::endl;
                throw -1;
            }
            buffer_out = (FAUSTFLOAT*)alloca(BUFFER_SIZE * sizeof(FAUSTFLOAT) * snd_info.channels);
        }
    #endif
        
        do {
            nbf = reader(snd_file, buffer_in, BUFFER_SIZE);
        #ifdef SAMPLERATE
            // Resampling
            if  (isResampling(snd_info.samplerate)) {
                int in_offset = 0;
                SRC_DATA src_data;
                src_data.src_ratio = double(fDriverSR)/double(snd_info.samplerate);
                do {
                    src_data.data_in = &buffer_in[in_offset * snd_info.channels];
                    src_data.data_out = buffer_out;
                    src_data.input_frames = nbf - in_offset;
                    src_data.output_frames = BUFFER_SIZE;
                    src_data.end_of_input = (nbf < BUFFER_SIZE);
                    int res = src_process(resampler, &src_data);
                    if (res != 0) {
                        std::cerr << "ERROR : src_process " << src_strerror(res) << std::endl;
                        throw -1;
                    }
                    copyToOut(soundfile, src_data.output_frames_gen, channels, snd_info.channels, offset, buffer_out);
                    in_offset += src_data.input_frames_used;
                    // Update offset
                    offset += src_data.output_frames_gen;
                } while (in_offset < nbf);
            } else {
                copyToOut(soundfile, nbf, channels, snd_info.channels, offset, buffer_in);
                // Update offset
                offset += nbf;
            }
        #else
            copyToOut(soundfile, nbf, channels, snd_info.channels, offset, buffer_in);
            // Update offset
            offset += nbf;
        #endif
        } while (nbf == BUFFER_SIZE);
		
        sf_close(snd_file);
    #ifdef SAMPLERATE
        if (resampler) src_delete(resampler);
    #endif
    }

};

#endif
/**************************  END  LibsndfileReader.h **************************/
LibsndfileReader gReader;
#endif

// To be used by DSP code if no SoundUI is used
std::vector<std::string> path_name_list;
Soundfile* defaultsound = gReader.createSoundfile(path_name_list, MAX_CHAN);

class SoundUI : public GenericUI
{
		
    private:
    
        std::vector<std::string> fSoundfileDir;             // The soundfile directories
        std::map<std::string, Soundfile*> fSoundfileMap;    // Map to share loaded soundfiles
        SoundfileReader* fSoundReader;

     public:
    
        SoundUI(const std::string& sound_directory = "", int sample_rate = -1, SoundfileReader* reader = nullptr)
        {
            fSoundfileDir.push_back(sound_directory);
            fSoundReader = (reader) ? reader : &gReader;
            fSoundReader->setSampleRate(sample_rate);
        }
    
        SoundUI(const std::vector<std::string>& sound_directories, int sample_rate = -1, SoundfileReader* reader = nullptr)
        :fSoundfileDir(sound_directories)
        {
            fSoundReader = (reader) ? reader : &gReader;
            fSoundReader->setSampleRate(sample_rate);
        }
    
        virtual ~SoundUI()
        {   
            // Delete all soundfiles
            std::map<std::string, Soundfile*>::iterator it;
            for (it = fSoundfileMap.begin(); it != fSoundfileMap.end(); it++) {
                delete (*it).second;
            }
        }

        // -- soundfiles
        virtual void addSoundfile(const char* label, const char* url, Soundfile** sf_zone)
        {
            const char* saved_url = url; // 'url' is consumed by parseMenuList2
            std::vector<std::string> file_name_list;
            
            bool menu = parseMenuList2(url, file_name_list, true);
            // If not a list, we have as single file
            if (!menu) { file_name_list.push_back(saved_url); }
            
            // Parse the possible list
            if (fSoundfileMap.find(saved_url) == fSoundfileMap.end()) {
                // Check all files and get their complete path
                std::vector<std::string> path_name_list = fSoundReader->checkFiles(fSoundfileDir, file_name_list);
                // Read them and create the Soundfile
                Soundfile* sound_file = fSoundReader->createSoundfile(path_name_list, MAX_CHAN);
                if (sound_file) {
                    fSoundfileMap[saved_url] = sound_file;
                } else {
                    // If failure, use 'defaultsound'
                    std::cerr << "addSoundfile : soundfile for " << saved_url << " cannot be created !" << std::endl;
                    *sf_zone = defaultsound;
                    return;
                }
            }
            
            // Get the soundfile
            *sf_zone = fSoundfileMap[saved_url];
        }
    
        static std::string getBinaryPath(std::string folder = "")
        {
            std::string bundle_path_str;
        #ifdef __APPLE__
            CFURLRef bundle_ref = CFBundleCopyBundleURL(CFBundleGetMainBundle());
            if (bundle_ref) {
                UInt8 bundle_path[512];
                if (CFURLGetFileSystemRepresentation(bundle_ref, true, bundle_path, 512)) {
                    bundle_path_str = std::string((char*)bundle_path) + folder;
                }
            }
        #endif
        #ifdef ANDROID_DRIVER
            bundle_path_str = "/data/data/__CURRENT_ANDROID_PACKAGE__/files";
        #endif
            return bundle_path_str;
        }
        
        static std::string getBinaryPathFrom(const std::string& path)
        {
            std::string bundle_path_str;
        #ifdef __APPLE__
            CFBundleRef bundle = CFBundleGetBundleWithIdentifier(CFStringCreateWithCString(kCFAllocatorDefault, path.c_str(), CFStringGetSystemEncoding()));
            CFURLRef bundle_ref = CFBundleCopyBundleURL(bundle);
            if (bundle_ref) {
                UInt8 bundle_path[512];
                if (CFURLGetFileSystemRepresentation(bundle_ref, true, bundle_path, 512)) {
                    bundle_path_str = std::string((char*)bundle_path);
                }
            }
        #endif
        #ifdef ANDROID_DRIVER
            bundle_path_str = "/data/data/__CURRENT_ANDROID_PACKAGE__/files";
        #endif
            return bundle_path_str;
        }
};

#endif
/**************************  END  SoundUI.h **************************/
#endif

#if defined(OSCCTRL)
/************************** BEGIN JuceOSCUI.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/
 
#ifndef __juce_osc__
#define __juce_osc__
 
#include "../JuceLibraryCode/JuceHeader.h"

/************************** BEGIN APIUI.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef API_UI_H
#define API_UI_H

#include <sstream>
#include <string>
#include <vector>
#include <iostream>
#include <map>


class APIUI : public PathBuilder, public Meta, public UI
{
    public:
    
        enum ItemType { kButton = 0, kCheckButton, kVSlider, kHSlider, kNumEntry, kHBargraph, kVBargraph };
  
    protected:
    
        enum { kLin = 0, kLog = 1, kExp = 2 };
    
        int fNumParameters;
        std::vector<std::string> fPaths;
        std::vector<std::string> fLabels;
        std::map<std::string, int> fPathMap;
        std::map<std::string, int> fLabelMap;
        std::vector<ValueConverter*> fConversion;
        std::vector<FAUSTFLOAT*> fZone;
        std::vector<FAUSTFLOAT> fInit;
        std::vector<FAUSTFLOAT> fMin;
        std::vector<FAUSTFLOAT> fMax;
        std::vector<FAUSTFLOAT> fStep;
        std::vector<ItemType> fItemType;
        std::vector<std::map<std::string, std::string> > fMetaData;
        std::vector<ZoneControl*> fAcc[3];
        std::vector<ZoneControl*> fGyr[3];

        // Screen color control
        // "...[screencolor:red]..." etc.
        bool fHasScreenControl;      // true if control screen color metadata
        ZoneReader* fRedReader;
        ZoneReader* fGreenReader;
        ZoneReader* fBlueReader;

        // Current values controlled by metadata
        std::string fCurrentUnit;
        int fCurrentScale;
        std::string fCurrentAcc;
        std::string fCurrentGyr;
        std::string fCurrentColor;
        std::string fCurrentTooltip;
        std::map<std::string, std::string> fCurrentMetadata;
    
        // Add a generic parameter
        virtual void addParameter(const char* label,
                                FAUSTFLOAT* zone,
                                FAUSTFLOAT init,
                                FAUSTFLOAT min,
                                FAUSTFLOAT max,
                                FAUSTFLOAT step,
                                ItemType type)
        {
            std::string path = buildPath(label);
            fPathMap[path] = fLabelMap[label] = fNumParameters++;
            fPaths.push_back(path);
            fLabels.push_back(label);
            fZone.push_back(zone);
            fInit.push_back(init);
            fMin.push_back(min);
            fMax.push_back(max);
            fStep.push_back(step);
            fItemType.push_back(type);
            
            // handle scale metadata
            switch (fCurrentScale) {
                case kLin:
                    fConversion.push_back(new LinearValueConverter(0, 1, min, max));
                    break;
                case kLog:
                    fConversion.push_back(new LogValueConverter(0, 1, min, max));
                    break;
                case kExp: fConversion.push_back(new ExpValueConverter(0, 1, min, max));
                    break;
            }
            fCurrentScale = kLin;
            
            if (fCurrentAcc.size() > 0 && fCurrentGyr.size() > 0) {
                std::cerr << "warning : 'acc' and 'gyr' metadata used for the same " << label << " parameter !!\n";
            }

            // handle acc metadata "...[acc : <axe> <curve> <amin> <amid> <amax>]..."
            if (fCurrentAcc.size() > 0) {
                std::istringstream iss(fCurrentAcc);
                int axe, curve;
                double amin, amid, amax;
                iss >> axe >> curve >> amin >> amid >> amax;

                if ((0 <= axe) && (axe < 3) &&
                    (0 <= curve) && (curve < 4) &&
                    (amin < amax) && (amin <= amid) && (amid <= amax))
                {
                    fAcc[axe].push_back(new CurveZoneControl(zone, curve, amin, amid, amax, min, init, max));
                } else {
                    std::cerr << "incorrect acc metadata : " << fCurrentAcc << std::endl;
                }
                fCurrentAcc = "";
            }
       
            // handle gyr metadata "...[gyr : <axe> <curve> <amin> <amid> <amax>]..."
            if (fCurrentGyr.size() > 0) {
                std::istringstream iss(fCurrentGyr);
                int axe, curve;
                double amin, amid, amax;
                iss >> axe >> curve >> amin >> amid >> amax;

                if ((0 <= axe) && (axe < 3) &&
                    (0 <= curve) && (curve < 4) &&
                    (amin < amax) && (amin <= amid) && (amid <= amax))
                {
                    fGyr[axe].push_back(new CurveZoneControl(zone, curve, amin, amid, amax, min, init, max));
                } else {
                    std::cerr << "incorrect gyr metadata : " << fCurrentGyr << std::endl;
                }
                fCurrentGyr = "";
            }
        
            // handle screencolor metadata "...[screencolor:red|green|blue|white]..."
            if (fCurrentColor.size() > 0) {
                if ((fCurrentColor == "red") && (fRedReader == 0)) {
                    fRedReader = new ZoneReader(zone, min, max);
                    fHasScreenControl = true;
                } else if ((fCurrentColor == "green") && (fGreenReader == 0)) {
                    fGreenReader = new ZoneReader(zone, min, max);
                    fHasScreenControl = true;
                } else if ((fCurrentColor == "blue") && (fBlueReader == 0)) {
                    fBlueReader = new ZoneReader(zone, min, max);
                    fHasScreenControl = true;
                } else if ((fCurrentColor == "white") && (fRedReader == 0) && (fGreenReader == 0) && (fBlueReader == 0)) {
                    fRedReader = new ZoneReader(zone, min, max);
                    fGreenReader = new ZoneReader(zone, min, max);
                    fBlueReader = new ZoneReader(zone, min, max);
                    fHasScreenControl = true;
                } else {
                    std::cerr << "incorrect screencolor metadata : " << fCurrentColor << std::endl;
                }
            }
            fCurrentColor = "";
            
            fMetaData.push_back(fCurrentMetadata);
            fCurrentMetadata.clear();
        }

        int getZoneIndex(std::vector<ZoneControl*>* table, int p, int val)
        {
            FAUSTFLOAT* zone = fZone[p];
            for (size_t i = 0; i < table[val].size(); i++) {
                if (zone == table[val][i]->getZone()) return int(i);
            }
            return -1;
        }
    
        void setConverter(std::vector<ZoneControl*>* table, int p, int val, int curve, double amin, double amid, double amax)
        {
            int id1 = getZoneIndex(table, p, 0);
            int id2 = getZoneIndex(table, p, 1);
            int id3 = getZoneIndex(table, p, 2);
            
            // Deactivates everywhere..
            if (id1 != -1) table[0][id1]->setActive(false);
            if (id2 != -1) table[1][id2]->setActive(false);
            if (id3 != -1) table[2][id3]->setActive(false);
            
            if (val == -1) { // Means: no more mapping...
                // So stay all deactivated...
            } else {
                int id4 = getZoneIndex(table, p, val);
                if (id4 != -1) {
                    // Reactivate the one we edit...
                    table[val][id4]->setMappingValues(curve, amin, amid, amax, fMin[p], fInit[p], fMax[p]);
                    table[val][id4]->setActive(true);
                } else {
                    // Allocate a new CurveZoneControl which is 'active' by default
                    FAUSTFLOAT* zone = fZone[p];
                    table[val].push_back(new CurveZoneControl(zone, curve, amin, amid, amax, fMin[p], fInit[p], fMax[p]));
                }
            }
        }
    
        void getConverter(std::vector<ZoneControl*>* table, int p, int& val, int& curve, double& amin, double& amid, double& amax)
        {
            int id1 = getZoneIndex(table, p, 0);
            int id2 = getZoneIndex(table, p, 1);
            int id3 = getZoneIndex(table, p, 2);
            
            if (id1 != -1) {
                val = 0;
                curve = table[val][id1]->getCurve();
                table[val][id1]->getMappingValues(amin, amid, amax);
            } else if (id2 != -1) {
                val = 1;
                curve = table[val][id2]->getCurve();
                table[val][id2]->getMappingValues(amin, amid, amax);
            } else if (id3 != -1) {
                val = 2;
                curve = table[val][id3]->getCurve();
                table[val][id3]->getMappingValues(amin, amid, amax);
            } else {
                val = -1; // No mapping
                curve = 0;
                amin = -100.;
                amid = 0.;
                amax = 100.;
            }
        }

     public:
    
        enum Type { kAcc = 0, kGyr = 1, kNoType };
   
        APIUI() : fNumParameters(0), fHasScreenControl(false), fRedReader(0), fGreenReader(0), fBlueReader(0), fCurrentScale(kLin)
        {}

        virtual ~APIUI()
        {
            std::vector<ValueConverter*>::iterator it1;
            for (it1 = fConversion.begin(); it1 != fConversion.end(); it1++) {
                delete(*it1);
            }

            std::vector<ZoneControl*>::iterator it2;
            for (int i = 0; i < 3; i++) {
                for (it2 = fAcc[i].begin(); it2 != fAcc[i].end(); it2++) {
                    delete(*it2);
                }
                for (it2 = fGyr[i].begin(); it2 != fGyr[i].end(); it2++) {
                    delete(*it2);
                }
            }
            
            delete fRedReader;
            delete fGreenReader;
            delete fBlueReader;
        }
    
        // -- widget's layouts

        virtual void openTabBox(const char* label)          { pushLabel(label); }
        virtual void openHorizontalBox(const char* label)   { pushLabel(label); }
        virtual void openVerticalBox(const char* label)     { pushLabel(label); }
        virtual void closeBox()                             { popLabel(); }

        // -- active widgets

        virtual void addButton(const char* label, FAUSTFLOAT* zone)
        {
            addParameter(label, zone, 0, 0, 1, 1, kButton);
        }

        virtual void addCheckButton(const char* label, FAUSTFLOAT* zone)
        {
            addParameter(label, zone, 0, 0, 1, 1, kCheckButton);
        }

        virtual void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        {
            addParameter(label, zone, init, min, max, step, kVSlider);
        }

        virtual void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        {
            addParameter(label, zone, init, min, max, step, kHSlider);
        }

        virtual void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step)
        {
            addParameter(label, zone, init, min, max, step, kNumEntry);
        }

        // -- passive widgets

        virtual void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
        {
            addParameter(label, zone, min, min, max, (max-min)/1000.0, kHBargraph);
        }

        virtual void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max)
        {
            addParameter(label, zone, min, min, max, (max-min)/1000.0, kVBargraph);
        }
    
        // -- soundfiles
    
        virtual void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone) {}

        // -- metadata declarations

        virtual void declare(FAUSTFLOAT* zone, const char* key, const char* val)
        {
            // Keep matadata
            fCurrentMetadata[key] = val;
            
            if (strcmp(key, "scale") == 0) {
                if (strcmp(val, "log") == 0) {
                    fCurrentScale = kLog;
                } else if (strcmp(val, "exp") == 0) {
                    fCurrentScale = kExp;
                } else {
                    fCurrentScale = kLin;
                }
            } else if (strcmp(key, "unit") == 0) {
                fCurrentUnit = val;
            } else if (strcmp(key, "acc") == 0) {
                fCurrentAcc = val;
            } else if (strcmp(key, "gyr") == 0) {
                fCurrentGyr = val;
            } else if (strcmp(key, "screencolor") == 0) {
                fCurrentColor = val; // val = "red", "green", "blue" or "white"
            } else if (strcmp(key, "tooltip") == 0) {
                fCurrentTooltip = val;
            }
        }

        virtual void declare(const char* key, const char* val)
        {}

		//-------------------------------------------------------------------------------
		// Simple API part
		//-------------------------------------------------------------------------------
		int getParamsCount() { return fNumParameters; }
        int getParamIndex(const char* path)
        {
            if (fPathMap.find(path) != fPathMap.end()) {
                return fPathMap[path];
            } else if (fLabelMap.find(path) != fLabelMap.end()) {
                return fLabelMap[path];
            } else {
                return -1;
            }
        }
        const char* getParamAddress(int p) { return fPaths[p].c_str(); }
        const char* getParamLabel(int p) { return fLabels[p].c_str(); }
        std::map<const char*, const char*> getMetadata(int p)
        {
            std::map<const char*, const char*> res;
            std::map<std::string, std::string> metadata = fMetaData[p];
            std::map<std::string, std::string>::iterator it;
            for (it = metadata.begin(); it != metadata.end(); ++it) {
                res[(*it).first.c_str()] = (*it).second.c_str();
            }
            return res;
        }

        const char* getMetadata(int p, const char* key)
        {
            return (fMetaData[p].find(key) != fMetaData[p].end()) ? fMetaData[p][key].c_str() : "";
        }
        FAUSTFLOAT getParamMin(int p) { return fMin[p]; }
        FAUSTFLOAT getParamMax(int p) { return fMax[p]; }
        FAUSTFLOAT getParamStep(int p) { return fStep[p]; }
        FAUSTFLOAT getParamInit(int p) { return fInit[p]; }

        FAUSTFLOAT* getParamZone(int p) { return fZone[p]; }
        FAUSTFLOAT getParamValue(int p) { return *fZone[p]; }
        void setParamValue(int p, FAUSTFLOAT v) { *fZone[p] = v; }

        double getParamRatio(int p) { return fConversion[p]->faust2ui(*fZone[p]); }
        void setParamRatio(int p, double r) { *fZone[p] = fConversion[p]->ui2faust(r); }

        double value2ratio(int p, double r)	{ return fConversion[p]->faust2ui(r); }
        double ratio2value(int p, double r)	{ return fConversion[p]->ui2faust(r); }
    
        /**
         * Return the control type (kAcc, kGyr, or -1) for a given parameter
         *
         * @param p - the UI parameter index
         *
         * @return the type
         */
        Type getParamType(int p)
        {
            if (p >= 0) {
                if (getZoneIndex(fAcc, p, 0) != -1
                    || getZoneIndex(fAcc, p, 1) != -1
                    || getZoneIndex(fAcc, p, 2) != -1) {
                    return kAcc;
                } else if (getZoneIndex(fGyr, p, 0) != -1
                           || getZoneIndex(fGyr, p, 1) != -1
                           || getZoneIndex(fGyr, p, 2) != -1) {
                    return kGyr;
                }
            }
            return kNoType;
        }
    
        /**
         * Return the Item type (kButton = 0, kCheckButton, kVSlider, kHSlider, kNumEntry, kHBargraph, kVBargraph) for a given parameter
         *
         * @param p - the UI parameter index
         *
         * @return the Item type
         */
        ItemType getParamItemType(int p)
        {
            return fItemType[p];
        }
   
        /**
         * Set a new value coming from an accelerometer, propagate it to all relevant float* zones.
         *
         * @param acc - 0 for X accelerometer, 1 for Y accelerometer, 2 for Z accelerometer
         * @param value - the new value
         *
         */
        void propagateAcc(int acc, double value)
        {
            for (size_t i = 0; i < fAcc[acc].size(); i++) {
                fAcc[acc][i]->update(value);
            }
        }
    
        /**
         * Used to edit accelerometer curves and mapping. Set curve and related mapping for a given UI parameter.
         *
         * @param p - the UI parameter index
         * @param acc - 0 for X accelerometer, 1 for Y accelerometer, 2 for Z accelerometer (-1 means "no mapping")
         * @param curve - between 0 and 3
         * @param amin - mapping 'min' point
         * @param amid - mapping 'middle' point
         * @param amax - mapping 'max' point
         *
         */
        void setAccConverter(int p, int acc, int curve, double amin, double amid, double amax)
        {
            setConverter(fAcc, p, acc, curve, amin, amid, amax);
        }
    
        /**
         * Used to edit gyroscope curves and mapping. Set curve and related mapping for a given UI parameter.
         *
         * @param p - the UI parameter index
         * @param acc - 0 for X gyroscope, 1 for Y gyroscope, 2 for Z gyroscope (-1 means "no mapping")
         * @param curve - between 0 and 3
         * @param amin - mapping 'min' point
         * @param amid - mapping 'middle' point
         * @param amax - mapping 'max' point
         *
         */
        void setGyrConverter(int p, int gyr, int curve, double amin, double amid, double amax)
        {
             setConverter(fGyr, p, gyr, curve, amin, amid, amax);
        }
    
        /**
         * Used to edit accelerometer curves and mapping. Get curve and related mapping for a given UI parameter.
         *
         * @param p - the UI parameter index
         * @param acc - the acc value to be retrieved (-1 means "no mapping")
         * @param curve - the curve value to be retrieved
         * @param amin - the amin value to be retrieved
         * @param amid - the amid value to be retrieved
         * @param amax - the amax value to be retrieved
         *
         */
        void getAccConverter(int p, int& acc, int& curve, double& amin, double& amid, double& amax)
        {
            getConverter(fAcc, p, acc, curve, amin, amid, amax);
        }

        /**
         * Used to edit gyroscope curves and mapping. Get curve and related mapping for a given UI parameter.
         *
         * @param p - the UI parameter index
         * @param gyr - the gyr value to be retrieved (-1 means "no mapping")
         * @param curve - the curve value to be retrieved
         * @param amin - the amin value to be retrieved
         * @param amid - the amid value to be retrieved
         * @param amax - the amax value to be retrieved
         *
         */
        void getGyrConverter(int p, int& gyr, int& curve, double& amin, double& amid, double& amax)
        {
            getConverter(fGyr, p, gyr, curve, amin, amid, amax);
        }
    
        /**
         * Set a new value coming from an gyroscope, propagate it to all relevant float* zones.
         *
         * @param gyr - 0 for X gyroscope, 1 for Y gyroscope, 2 for Z gyroscope
         * @param value - the new value
         *
         */
        void propagateGyr(int gyr, double value)
        {
            for (size_t i = 0; i < fGyr[gyr].size(); i++) {
                fGyr[gyr][i]->update(value);
            }
        }
   
        // getScreenColor() : -1 means no screen color control (no screencolor metadata found)
        // otherwise return 0x00RRGGBB a ready to use color
        int getScreenColor()
        {
            if (fHasScreenControl) {
                int r = (fRedReader) ? fRedReader->getValue() : 0;
                int g = (fGreenReader) ? fGreenReader->getValue() : 0;
                int b = (fBlueReader) ? fBlueReader->getValue() : 0;
                return (r<<16) | (g<<8) | b;
            } else {
                return -1;
            }
        }

};

#endif
/**************************  END  APIUI.h **************************/

class oscItem : public uiItem {
    
    protected:
        
        OSCSender* fSender;
        String fPath;
        
    public:
        
        oscItem(OSCSender* sender, GUI* ui, const String& path, FAUSTFLOAT* zone)
        :uiItem(ui, zone), fSender(sender), fPath(path) {}
        virtual ~oscItem()
        {}
        
        virtual void reflectZone()
        {
            FAUSTFLOAT v = *fZone;
            fCache = v;
            fSender->send(fPath, float(v));
        }
    
};

class JuceOSCUI : private OSCReceiver, private OSCReceiver::Listener<OSCReceiver::RealtimeCallback>, public GUI {
    
    private:
        
        OSCSender fSender;
        String fIP;
        int fInputPort, fOutputPort;
        APIUI fAPIUI;
        Array<oscItem*> fOSCItems;  // Pointers are kept and desallocated by the GUI class
        
    public:
        
        JuceOSCUI(const std::string& ip, int in_port, int out_port)
        :fIP(ip), fInputPort(in_port), fOutputPort(out_port)
        {}
        
        virtual ~JuceOSCUI()
        {}
        
        void oscMessageReceived(const OSCMessage& message) override
        {
            String address = message.getAddressPattern().toString();
            
            for (int i = 0; i < message.size(); ++i) {
                if (message[i].isFloat32()) {
                    fAPIUI.setParamValue(fAPIUI.getParamIndex(address.toStdString().c_str()), FAUSTFLOAT(message[i].getFloat32()));
                    // "get" message with correct address
                } else if (message[i].isString()
                           && message[i].getString().equalsIgnoreCase("get")
                           && String(fAPIUI.getParamAddress(0)).startsWith(address)) {
                    for (int p = 0; p < fAPIUI.getParamsCount(); ++p) {
                        fSender.send(fAPIUI.getParamAddress(p), float(fAPIUI.getParamValue(p)), float(fAPIUI.getParamMin(p)), float(fAPIUI.getParamMax(p)));
                    }
                    // "hello" message
                } else if (message[i].isString()
                           && address.equalsIgnoreCase("/*")
                           && message[i].getString().equalsIgnoreCase("hello")) {
                    String path = fAPIUI.getParamAddress(0);
                    int pos1 = path.indexOfChar('/');
                    int pos2 = path.indexOfChar(pos1 + 1, '/');
                    fSender.send(path.substring(pos1, pos2), fIP, fInputPort, fOutputPort);
                }
            }
        }
        
        bool run() override
        {
            // Keep all zones for update when OSC messages are received
            if (fOSCItems.size() == 0) {
                for (int p = 0; p < fAPIUI.getParamsCount(); ++p) {
                    fOSCItems.add(new oscItem(&fSender, this, fAPIUI.getParamAddress(p), fAPIUI.getParamZone(p)));
                }
            }
            
            if (!fSender.connect(fIP, fOutputPort)) {
                std::cerr << "Error: could not connect to UDP port " << fInputPort << std::endl;
                return false;
            }
            
            if (!connect(fInputPort)) {
                std::cerr << "Error: could not connect to UDP port " << fOutputPort << std::endl;
                return false;
            }
            addListener(this);
            return true;
        }
        
        void stop() override
        {
            fSender.disconnect();
            disconnect();
            removeListener(this);
        }
        
        // -- widget's layouts
        
        void openTabBox(const char* label) override { fAPIUI.openTabBox(label); }
        void openHorizontalBox(const char* label) override { fAPIUI.openHorizontalBox(label); }
        void openVerticalBox(const char* label) override { fAPIUI.openVerticalBox(label); }
        void closeBox() override { fAPIUI.closeBox(); }
        
        // -- active widgets
        
        void addButton(const char* label, FAUSTFLOAT* zone) override { fAPIUI.addButton(label, zone); }
        void addCheckButton(const char* label, FAUSTFLOAT* zone) override { fAPIUI.addCheckButton(label, zone); }
        void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) override
        { fAPIUI.addVerticalSlider(label, zone, init, min, max, step); }
        void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) override
        { fAPIUI.addHorizontalSlider(label, zone, init, min, max, step); }
        void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) override
        { fAPIUI.addNumEntry(label, zone, init, min, max, step); }
        
        // -- passive widgets
        
        void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) override
        { fAPIUI.addHorizontalBargraph(label, zone, min, max); }
        void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) override
        { fAPIUI.addVerticalBargraph(label, zone, min, max); }
        
        // -- metadata declarations
        
        void declare(FAUSTFLOAT* zone, const char* key, const char* val) override { fAPIUI.declare(zone, key, val); }
    
};

#endif // __juce_osc__

/**************************  END  JuceOSCUI.h **************************/
#endif

#if defined(MIDICTRL)
/************************** BEGIN juce-midi.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __juce_midi__
#define __juce_midi__
 

class MapUI;

//-----------------------------------------------
// MIDI input/output handling using JUCE library
//-----------------------------------------------

class juce_midi_handler : public midi_handler {
    
    protected:
    
        MidiBuffer fOutputBuffer;
        CriticalSection fMutex;
    
        void decodeMessage(const MidiMessage& message)
        {
            const uint8* data = message.getRawData();
            
            if (message.isNoteOff()) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->keyOff(message.getTimeStamp(), message.getChannel(), data[1], data[2]);
                }
            } else if (message.isNoteOn()) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    if (data[1] != 0) {
                        fMidiInputs[i]->keyOn(message.getTimeStamp(), message.getChannel(), data[1], data[2]);
                    } else {
                        fMidiInputs[i]->keyOff(message.getTimeStamp(), message.getChannel(), data[1], data[2]);
                    }
                }
            } else if (message.isAftertouch()) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->keyPress(message.getTimeStamp(), message.getChannel(), data[1], data[2]);
                }
            } else if (message.isController()) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->ctrlChange(message.getTimeStamp(), message.getChannel(), data[1], data[2]);
                }
            } else if (message.isProgramChange()) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->progChange(message.getTimeStamp(), message.getChannel(), data[1]);
                }
            } else if (message.isChannelPressure()) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->chanPress(message.getTimeStamp(), message.getChannel(), data[1]);
                }
            } else if (message.isPitchWheel()) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->pitchWheel(message.getTimeStamp(), message.getChannel(), ((data[1] << 7) + data[2]));
                }
            } else if (message.isMidiClock()) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->clock(message.getTimeStamp());
                }
            } else if (message.isMidiStart()) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->startSync(message.getTimeStamp());
                }
            } else if (message.isMidiStop()) {
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->stopSync(message.getTimeStamp());
                }
            } else if (message.isSysEx()) {
                std::vector<unsigned char> sysex(data, data + message.getRawDataSize());
                for (unsigned int i = 0; i < fMidiInputs.size(); i++) {
                    fMidiInputs[i]->sysEx(message.getTimeStamp(), sysex);
                }
            } else {
                std::cerr << "Unused MIDI message" << std::endl;
            }
        }
    
    public:
    
        juce_midi_handler():midi_handler("JUCE")
        {}
    
        virtual ~juce_midi_handler() {}
    
        // Used with MidiBuffer (containing several messages)
        void encodeBuffer(MidiBuffer& buffer)
        {
            const ScopedTryLock lock(fMutex);
            if (lock.isLocked()) {
                buffer.swapWith(fOutputBuffer);
                fOutputBuffer.clear();
            } else {
                std::cerr << "encodeBuffer fails..." << std::endl;
            }
        }
        
        void decodeBuffer(MidiBuffer& buffer)
        {
            MidiMessage msg;
            int ignore;

            for (MidiBuffer::Iterator it(buffer); it.getNextEvent(msg, ignore);) {
                decodeMessage(msg);
            }
            
            buffer.clear();
        }
    
        // MIDI output API
        MapUI* keyOn(int channel, int pitch, int velocity)
        {
            fOutputBuffer.addEvent(MidiMessage::noteOn(channel + 1, pitch, uint8(velocity)), 0);
            return nullptr;
        }
        
        void keyOff(int channel, int pitch, int velocity)
        {
            fOutputBuffer.addEvent(MidiMessage::noteOff(channel + 1, pitch, uint8(velocity)), 0);
        }
        
        void ctrlChange(int channel, int ctrl, int val)
        {
            fOutputBuffer.addEvent(MidiMessage::controllerEvent(channel + 1, ctrl, uint8(val)), 0);
        }
        
        void chanPress(int channel, int press)
        {
            fOutputBuffer.addEvent(MidiMessage::channelPressureChange(channel + 1, press), 0);
        }
        
        void progChange(int channel, int pgm)
        {
            fOutputBuffer.addEvent(MidiMessage::programChange(channel + 1, pgm), 0);
        }
        
        void keyPress(int channel, int pitch, int press)
        {
            fOutputBuffer.addEvent(MidiMessage::aftertouchChange(channel + 1, pitch, press), 0);
        }
        
        void pitchWheel(int channel, int wheel)
        {
            fOutputBuffer.addEvent(MidiMessage::pitchWheel(channel + 1, range(0, 16383, wheel)), 0);
        }
        
        void ctrlChange14bits(int channel, int ctrl, int value)
        {
            // TODO
        }
        
        void startSync(double date)
        {
            fOutputBuffer.addEvent(MidiMessage::midiStart(), 0);
        }
        
        void stopSync(double date)
        {
            fOutputBuffer.addEvent(MidiMessage::midiStop(), 0);
        }
        
        void clock(double date)
        {
            fOutputBuffer.addEvent(MidiMessage::midiClock(), 0);
        }
    
        void sysEx(double date, std::vector<unsigned char>& message)
        {
            fOutputBuffer.addEvent(MidiMessage(message.data(), (int)message.size()), 0);
        }

};

class juce_midi : public juce_midi_handler, public MidiInputCallback {

    private:
    
        MidiInput* fMidiIn;
        MidiOutput* fMidiOut;
    
        void handleIncomingMidiMessage(MidiInput*, const MidiMessage& message)
        {
            decodeMessage(message);
        }
    
    public:
    
        virtual ~juce_midi()
        {
            stopMidi();
        }
        
        bool startMidi()
        {
            if ((fMidiIn = MidiInput::openDevice(MidiInput::getDefaultDeviceIndex(), this)) == nullptr) {
                return false;
            }
            if ((fMidiOut = MidiOutput::openDevice(MidiOutput::getDefaultDeviceIndex())) == nullptr) {
                return false;
            }
            
            fMidiIn->start();
            return true;
        }
        
        void stopMidi()
        { 
            fMidiIn->stop();
            delete fMidiIn;
            delete fMidiOut;
        }
    
        // MIDI output API
        MapUI* keyOn(int channel, int pitch, int velocity)
        {
            fMidiOut->sendMessageNow(MidiMessage::noteOn(channel + 1, pitch, uint8(velocity)));
            return nullptr;
        }
        
        void keyOff(int channel, int pitch, int velocity) 
        {
            fMidiOut->sendMessageNow(MidiMessage::noteOff(channel + 1, pitch, uint8(velocity)));
        }
        
        void ctrlChange(int channel, int ctrl, int val) 
        {
            fMidiOut->sendMessageNow(MidiMessage::controllerEvent(channel + 1, ctrl, uint8(val)));
        }
        
        void chanPress(int channel, int press) 
        {
            fMidiOut->sendMessageNow(MidiMessage::channelPressureChange(channel + 1, press));
        }
        
        void progChange(int channel, int pgm) 
        {
            fMidiOut->sendMessageNow(MidiMessage::programChange(channel + 1, pgm));
        }
          
        void keyPress(int channel, int pitch, int press) 
        {
            fMidiOut->sendMessageNow(MidiMessage::aftertouchChange(channel + 1, pitch, press));
        }
   
        void pitchWheel(int channel, int wheel) 
        {
            fMidiOut->sendMessageNow(MidiMessage::pitchWheel(channel + 1, range(0, 16383, wheel)));
        }
        
        void ctrlChange14bits(int channel, int ctrl, int value)
        {
            // TODO
        }
    
        void startSync(double date) 
        {
            fMidiOut->sendMessageNow(MidiMessage::midiStart());
        }
       
        void stopSync(double date) 
        {
            fMidiOut->sendMessageNow(MidiMessage::midiStop());
        }
        
        void clock(double date) 
        {
            fMidiOut->sendMessageNow(MidiMessage::midiClock());
        }
    
        void sysEx(double date, std::vector<unsigned char>& message)
        {
            fMidiOut->sendMessageNow(MidiMessage(message.data(), (int)message.size()));
        }
    
};

#endif // __juce_midi__

/**************************  END  juce-midi.h **************************/
/************************** BEGIN timed-dsp.h **************************/
/************************************************************************
 FAUST Architecture File
 Copyright (C) 2003-2017 GRAME, Centre National de Creation Musicale
 ---------------------------------------------------------------------
 This Architecture section is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 3 of
 the License, or (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; If not, see <http://www.gnu.org/licenses/>.
 
 EXCEPTION : As a special exception, you may create a larger work
 that contains this FAUST architecture section and distribute
 that work under terms of your choice, so long as this FAUST
 architecture section is not modified.
 ************************************************************************/

#ifndef __timed_dsp__
#define __timed_dsp__

#include <set>
#include <float.h>
#include <assert.h>


namespace {
    
#if __APPLE__
#if TARGET_OS_IPHONE
    //inline double GetCurrentTimeInUsec() { return double(CAHostTimeBase::GetCurrentTimeInNanos()) / 1000.; }
    // TODO
    inline double GetCurrentTimeInUsec() { return 0.0; }
#else
    #include <CoreAudio/HostTime.h>
    inline double GetCurrentTimeInUsec() { return double(AudioConvertHostTimeToNanos(AudioGetCurrentHostTime())) / 1000.; }
#endif
#endif

#if __linux__
#include <sys/time.h>
inline double GetCurrentTimeInUsec() 
{
    struct timeval tv;
    (void)gettimeofday(&tv, (struct timezone *)NULL);
    return double((tv.tv_sec * 1000000) + tv.tv_usec);
}
#endif

#if _WIN32
#include <windows.h>
inline double GetCurrentTimeInUsec(void)
{
    LARGE_INTEGER time;
    LARGE_INTEGER frequency;
    QueryPerformanceFrequency(&frequency);
    QueryPerformanceCounter(&time);
    return double(time.QuadPart) / double(frequency.QuadPart) * 1000000.0;
}
#endif
    
}

/**
 * ZoneUI : this class collect zones in a set.
 */

struct ZoneUI : public GenericUI
{
    
    std::set<FAUSTFLOAT*> fZoneSet;
    
    ZoneUI():GenericUI() {}
    virtual ~ZoneUI() {}
    
    void insertZone(FAUSTFLOAT* zone) 
    { 
        if (GUI::gTimedZoneMap.find(zone) != GUI::gTimedZoneMap.end()) {
            fZoneSet.insert(zone);
        } 
    }
    
    // -- active widgets
    void addButton(const char* label, FAUSTFLOAT* zone)
    {
        insertZone(zone);
    }
    void addCheckButton(const char* label, FAUSTFLOAT* zone)
    {
        insertZone(zone);
    }
    void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT fmin, FAUSTFLOAT fmax, FAUSTFLOAT step)
    {
        insertZone(zone);
    }
    void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT fmin, FAUSTFLOAT fmax, FAUSTFLOAT step)
    {
        insertZone(zone);
    }
    void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT fmin, FAUSTFLOAT fmax, FAUSTFLOAT step)
    {
        insertZone(zone);
    }
    
    // -- passive widgets
    void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT fmin, FAUSTFLOAT fmax)
    {
        insertZone(zone);
    }
    void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT fmin, FAUSTFLOAT fmax)
    {
        insertZone(zone);
    }
  
};

/**
 * Timed signal processor that allows to handle the decorated DSP by 'slices'
 * that is, calling the 'compute' method several times and changing control
 * parameters between slices.
 */

class timed_dsp : public decorator_dsp {

    protected:
        
        double fDateUsec;       // Compute call date in usec
        double fOffsetUsec;     // Compute call offset in usec
        bool fFirstCallback;
        ZoneUI fZoneUI;
    
        FAUSTFLOAT** fInputsSlice;
        FAUSTFLOAT** fOutputsSlice;
    
        void computeSlice(int offset, int slice, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) 
        {
            if (slice > 0) {
                for (int chan = 0; chan < fDSP->getNumInputs(); chan++) {
                    fInputsSlice[chan] = &(inputs[chan][offset]);
                }
                for (int chan = 0; chan < fDSP->getNumOutputs(); chan++) {
                    fOutputsSlice[chan] = &(outputs[chan][offset]);
                }
                fDSP->compute(slice, fInputsSlice, fOutputsSlice);
            } 
        }
        
        double convertUsecToSample(double usec)
        {
            return std::max<double>(0., (double(getSampleRate()) * (usec - fDateUsec)) / 1000000.);
        }
        
        ztimedmap::iterator getNextControl(DatedControl& res)
        {
            DatedControl date1(DBL_MAX, 0);
            ztimedmap::iterator it1, it2 = GUI::gTimedZoneMap.end();
            std::set<FAUSTFLOAT*>::iterator it3;
              
            // Find date of next audio slice to compute
            for (it3 = fZoneUI.fZoneSet.begin(); it3 != fZoneUI.fZoneSet.end(); it3++) {
                // If value list is not empty, get the date and keep the minimal one
                it1 = GUI::gTimedZoneMap.find(*it3);
                if (it1 != GUI::gTimedZoneMap.end()) { // Check if zone still in global GUI::gTimedZoneMap (since MidiUI may have been desallocated)
                    DatedControl date2;
                    if (ringbuffer_peek((*it1).second, (char*)&date2, sizeof(DatedControl)) == sizeof(DatedControl) 
                        && date2.fDate < date1.fDate) {
                        it2 = it1;
                        date1 = date2;
                    }
                }
            }
            
            res = date1;
            return it2;
        }
        
        virtual void computeAux(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs, bool convert_ts)
        {
            int slice, offset = 0;
            ztimedmap::iterator it;
            DatedControl next_control;
             
            // Do audio computation "slice" by "slice"
            while ((it = getNextControl(next_control)) != GUI::gTimedZoneMap.end()) {
                
                // If needed, convert next_control in samples from begining of the buffer, possible moving to 0 (if negative)
                if (convert_ts) {
                    next_control.fDate = convertUsecToSample(next_control.fDate);
                }
                     
                // Compute audio slice
                slice = int(next_control.fDate) - offset;
                computeSlice(offset, slice, inputs, outputs);
                offset += slice;
               
                // Update control
                ringbuffer_t* control_values = (*it).second;
                *((*it).first) = next_control.fValue;
                
                // Move ringbuffer pointer
                ringbuffer_read_advance(control_values, sizeof(DatedControl));
            } 
            
            // Compute last audio slice
            slice = count - offset;
            computeSlice(offset, slice, inputs, outputs);
        }

    public:

        timed_dsp(dsp* dsp):decorator_dsp(dsp), fDateUsec(0), fOffsetUsec(0), fFirstCallback(true)
        {
            fInputsSlice = new FAUSTFLOAT*[dsp->getNumInputs()];
            fOutputsSlice = new FAUSTFLOAT*[dsp->getNumOutputs()];
        }
        virtual ~timed_dsp() 
        {
            delete [] fInputsSlice;
            delete [] fOutputsSlice;
        }
        
        virtual void init(int sample_rate)
        {
            fDSP->init(sample_rate);
        }
        
        virtual void buildUserInterface(UI* ui_interface)   
        { 
            fDSP->buildUserInterface(ui_interface); 
            // Only keep zones that are in GUI::gTimedZoneMap
            fDSP->buildUserInterface(&fZoneUI);
        }
    
        virtual timed_dsp* clone()
        {
            return new timed_dsp(fDSP->clone());
        }
    
        // Default method take a timestamp at 'compute' call time
        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            compute(::GetCurrentTimeInUsec(), count, inputs, outputs);
        }    
        
        virtual void compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            if (date_usec == -1) {
                // Timestamp is expressed in frames
                computeAux(count, inputs, outputs, false);
            } else {
                // Save the timestamp offset in the first callback
                if (fFirstCallback) {
                    fFirstCallback = false;
                    double current_date_usec = ::GetCurrentTimeInUsec();
                    fDateUsec = current_date_usec;
                    fOffsetUsec = current_date_usec - date_usec;
                }
                
                // RtMidi mode: timestamp must be converted in frames
                computeAux(count, inputs, outputs, true);
                
                // Keep call date 
                fDateUsec = date_usec + fOffsetUsec;
            }
        }
        
};

#endif
/**************************  END  timed-dsp.h **************************/
#endif

#if defined(POLY2)
#include "effect.h"
#endif 


#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif 

#include <algorithm>
#include <cmath>
#include <math.h>

static float mydsp_faustpower2_f(float value) {
	return (value * value);
	
}

#ifndef FAUSTCLASS 
#define FAUSTCLASS mydsp
#endif
#ifdef __APPLE__ 
#define exp10f __exp10f
#define exp10 __exp10
#endif





















//String sNote;
//String str;
FAUSTFLOAT maxnum;
FAUSTFLOAT a;
FAUSTFLOAT b;



class mydsp : public dsp {
	
 private:
	
	FAUSTFLOAT fHslider0;
	int fSampleRate;
	float fConst0;
	float fConst1;
	FAUSTFLOAT fHslider1;
	float fConst2;
	float fConst3;
	float fConst4;
	float fConst5;
	float fConst6;
	float fConst7;
	float fConst8;
	float fConst9;
	float fConst10;
	float fConst11;
	float fConst12;
	float fConst13;
	float fConst14;
	float fConst15;
	float fConst16;
	float fRec3[3];
	float fConst17;
	float fConst18;
	float fConst19;
	float fRec2[3];
	float fConst20;
	float fConst21;
	float fConst22;
	float fRec1[3];
	float fConst23;
	float fRec0[2];
	FAUSTFLOAT fVbargraph0;
	float fConst24;
	float fConst25;
	float fConst26;
	float fConst27;
	float fConst28;
	float fConst29;
	float fConst30;
	float fConst31;
	float fConst32;
	float fConst33;
	float fConst34;
	float fConst35;
	float fConst36;
	float fConst37;
	float fConst38;
	float fConst39;
	float fConst40;
	float fConst41;
	float fConst42;
	float fConst43;
	float fConst44;
	float fRec10[3];
	float fConst45;
	float fConst46;
	float fConst47;
	float fRec9[3];
	float fConst48;
	float fConst49;
	float fConst50;
	float fRec8[3];
	float fConst51;
	float fConst52;
	float fConst53;
	float fConst54;
	float fRec7[3];
	float fConst55;
	float fConst56;
	float fConst57;
	float fRec6[3];
	float fConst58;
	float fConst59;
	float fConst60;
	float fRec5[3];
	float fConst61;
	float fRec4[2];
	FAUSTFLOAT fVbargraph1;
	float fConst62;
	float fConst63;
	float fConst64;
	float fConst65;
	float fConst66;
	float fConst67;
	float fConst68;
	float fConst69;
	float fConst70;
	float fConst71;
	float fConst72;
	float fConst73;
	float fConst74;
	float fConst75;
	float fConst76;
	float fConst77;
	float fConst78;
	float fConst79;
	float fConst80;
	float fConst81;
	float fConst82;
	float fRec17[3];
	float fConst83;
	float fConst84;
	float fConst85;
	float fRec16[3];
	float fConst86;
	float fConst87;
	float fConst88;
	float fRec15[3];
	float fConst89;
	float fConst90;
	float fConst91;
	float fConst92;
	float fRec14[3];
	float fConst93;
	float fConst94;
	float fConst95;
	float fRec13[3];
	float fConst96;
	float fConst97;
	float fConst98;
	float fRec12[3];
	float fConst99;
	float fRec11[2];
	FAUSTFLOAT fVbargraph2;
	float fConst100;
	float fConst101;
	float fConst102;
	float fConst103;
	float fConst104;
	float fConst105;
	float fConst106;
	float fConst107;
	float fConst108;
	float fConst109;
	float fConst110;
	float fConst111;
	float fConst112;
	float fConst113;
	float fConst114;
	float fConst115;
	float fConst116;
	float fConst117;
	float fConst118;
	float fConst119;
	float fConst120;
	float fRec24[3];
	float fConst121;
	float fConst122;
	float fConst123;
	float fRec23[3];
	float fConst124;
	float fConst125;
	float fConst126;
	float fRec22[3];
	float fConst127;
	float fConst128;
	float fConst129;
	float fConst130;
	float fRec21[3];
	float fConst131;
	float fConst132;
	float fConst133;
	float fRec20[3];
	float fConst134;
	float fConst135;
	float fConst136;
	float fRec19[3];
	float fConst137;
	float fRec18[2];
	FAUSTFLOAT fVbargraph3;
	float fConst138;
	float fConst139;
	float fConst140;
	float fConst141;
	float fConst142;
	float fConst143;
	float fConst144;
	float fConst145;
	float fConst146;
	float fConst147;
	float fConst148;
	float fConst149;
	float fConst150;
	float fConst151;
	float fConst152;
	float fConst153;
	float fConst154;
	float fConst155;
	float fConst156;
	float fConst157;
	float fConst158;
	float fRec31[3];
	float fConst159;
	float fConst160;
	float fConst161;
	float fRec30[3];
	float fConst162;
	float fConst163;
	float fConst164;
	float fRec29[3];
	float fConst165;
	float fConst166;
	float fConst167;
	float fConst168;
	float fRec28[3];
	float fConst169;
	float fConst170;
	float fConst171;
	float fRec27[3];
	float fConst172;
	float fConst173;
	float fConst174;
	float fRec26[3];
	float fConst175;
	float fRec25[2];
	FAUSTFLOAT fVbargraph4;
	float fConst176;
	float fConst177;
	float fConst178;
	float fConst179;
	float fConst180;
	float fConst181;
	float fConst182;
	float fConst183;
	float fConst184;
	float fConst185;
	float fConst186;
	float fConst187;
	float fConst188;
	float fConst189;
	float fConst190;
	float fConst191;
	float fConst192;
	float fConst193;
	float fConst194;
	float fConst195;
	float fConst196;
	float fRec38[3];
	float fConst197;
	float fConst198;
	float fConst199;
	float fRec37[3];
	float fConst200;
	float fConst201;
	float fConst202;
	float fRec36[3];
	float fConst203;
	float fConst204;
	float fConst205;
	float fConst206;
	float fRec35[3];
	float fConst207;
	float fConst208;
	float fConst209;
	float fRec34[3];
	float fConst210;
	float fConst211;
	float fConst212;
	float fRec33[3];
	float fConst213;
	float fRec32[2];
	FAUSTFLOAT fVbargraph5;
	float fConst214;
	float fConst215;
	float fConst216;
	float fConst217;
	float fConst218;
	float fConst219;
	float fConst220;
	float fConst221;
	float fConst222;
	float fConst223;
	float fConst224;
	float fConst225;
	float fConst226;
	float fConst227;
	float fConst228;
	float fConst229;
	float fConst230;
	float fConst231;
	float fConst232;
	float fConst233;
	float fConst234;
	float fRec45[3];
	float fConst235;
	float fConst236;
	float fConst237;
	float fRec44[3];
	float fConst238;
	float fConst239;
	float fConst240;
	float fRec43[3];
	float fConst241;
	float fConst242;
	float fConst243;
	float fConst244;
	float fRec42[3];
	float fConst245;
	float fConst246;
	float fConst247;
	float fRec41[3];
	float fConst248;
	float fConst249;
	float fConst250;
	float fRec40[3];
	float fConst251;
	float fRec39[2];
	FAUSTFLOAT fVbargraph6;
	float fConst252;
	float fConst253;
	float fConst254;
	float fConst255;
	float fConst256;
	float fConst257;
	float fConst258;
	float fConst259;
	float fConst260;
	float fConst261;
	float fConst262;
	float fConst263;
	float fConst264;
	float fConst265;
	float fConst266;
	float fConst267;
	float fConst268;
	float fConst269;
	float fConst270;
	float fConst271;
	float fConst272;
	float fRec52[3];
	float fConst273;
	float fConst274;
	float fConst275;
	float fRec51[3];
	float fConst276;
	float fConst277;
	float fConst278;
	float fRec50[3];
	float fConst279;
	float fConst280;
	float fConst281;
	float fConst282;
	float fRec49[3];
	float fConst283;
	float fConst284;
	float fConst285;
	float fRec48[3];
	float fConst286;
	float fConst287;
	float fConst288;
	float fRec47[3];
	float fConst289;
	float fRec46[2];
	FAUSTFLOAT fVbargraph7;
	float fConst290;
	float fConst291;
	float fConst292;
	float fConst293;
	float fConst294;
	float fConst295;
	float fConst296;
	float fConst297;
	float fConst298;
	float fConst299;
	float fConst300;
	float fConst301;
	float fConst302;
	float fConst303;
	float fConst304;
	float fConst305;
	float fConst306;
	float fConst307;
	float fConst308;
	float fConst309;
	float fConst310;
	float fRec59[3];
	float fConst311;
	float fConst312;
	float fConst313;
	float fRec58[3];
	float fConst314;
	float fConst315;
	float fConst316;
	float fRec57[3];
	float fConst317;
	float fConst318;
	float fConst319;
	float fConst320;
	float fRec56[3];
	float fConst321;
	float fConst322;
	float fConst323;
	float fRec55[3];
	float fConst324;
	float fConst325;
	float fConst326;
	float fRec54[3];
	float fConst327;
	float fRec53[2];
	FAUSTFLOAT fVbargraph8;
	float fConst328;
	float fConst329;
	float fConst330;
	float fConst331;
	float fConst332;
	float fConst333;
	float fConst334;
	float fConst335;
	float fConst336;
	float fConst337;
	float fConst338;
	float fConst339;
	float fConst340;
	float fConst341;
	float fConst342;
	float fConst343;
	float fConst344;
	float fConst345;
	float fConst346;
	float fConst347;
	float fConst348;
	float fRec66[3];
	float fConst349;
	float fConst350;
	float fConst351;
	float fRec65[3];
	float fConst352;
	float fConst353;
	float fConst354;
	float fRec64[3];
	float fConst355;
	float fConst356;
	float fConst357;
	float fConst358;
	float fRec63[3];
	float fConst359;
	float fConst360;
	float fConst361;
	float fRec62[3];
	float fConst362;
	float fConst363;
	float fConst364;
	float fRec61[3];
	float fConst365;
	float fRec60[2];
	FAUSTFLOAT fVbargraph9;
	float fConst366;
	float fConst367;
	float fConst368;
	float fConst369;
	float fConst370;
	float fConst371;
	float fConst372;
	float fConst373;
	float fConst374;
	float fConst375;
	float fConst376;
	float fConst377;
	float fConst378;
	float fConst379;
	float fConst380;
	float fConst381;
	float fConst382;
	float fConst383;
	float fConst384;
	float fConst385;
	float fConst386;
	float fRec73[3];
	float fConst387;
	float fConst388;
	float fConst389;
	float fRec72[3];
	float fConst390;
	float fConst391;
	float fConst392;
	float fRec71[3];
	float fConst393;
	float fConst394;
	float fConst395;
	float fConst396;
	float fRec70[3];
	float fConst397;
	float fConst398;
	float fConst399;
	float fRec69[3];
	float fConst400;
	float fConst401;
	float fConst402;
	float fRec68[3];
	float fConst403;
	float fRec67[2];
	FAUSTFLOAT fVbargraph10;
	float fConst404;
	float fConst405;
	float fConst406;
	float fConst407;
	float fConst408;
	float fConst409;
	float fConst410;
	float fConst411;
	float fConst412;
	float fConst413;
	float fConst414;
	float fConst415;
	float fConst416;
	float fConst417;
	float fConst418;
	float fConst419;
	float fConst420;
	float fConst421;
	float fConst422;
	float fConst423;
	float fConst424;
	float fRec80[3];
	float fConst425;
	float fConst426;
	float fConst427;
	float fRec79[3];
	float fConst428;
	float fConst429;
	float fConst430;
	float fRec78[3];
	float fConst431;
	float fConst432;
	float fConst433;
	float fConst434;
	float fRec77[3];
	float fConst435;
	float fConst436;
	float fConst437;
	float fRec76[3];
	float fConst438;
	float fConst439;
	float fConst440;
	float fRec75[3];
	float fConst441;
	float fRec74[2];
	FAUSTFLOAT fVbargraph11;
	float fConst442;
	float fConst443;
	float fConst444;
	float fConst445;
	float fConst446;
	float fConst447;
	float fConst448;
	float fConst449;
	float fConst450;
	float fConst451;
	float fConst452;
	float fConst453;
	float fConst454;
	float fConst455;
	float fConst456;
	float fConst457;
	float fConst458;
	float fConst459;
	float fConst460;
	float fConst461;
	float fConst462;
	float fRec87[3];
	float fConst463;
	float fConst464;
	float fConst465;
	float fRec86[3];
	float fConst466;
	float fConst467;
	float fConst468;
	float fRec85[3];
	float fConst469;
	float fConst470;
	float fConst471;
	float fConst472;
	float fRec84[3];
	float fConst473;
	float fConst474;
	float fConst475;
	float fRec83[3];
	float fConst476;
	float fConst477;
	float fConst478;
	float fRec82[3];
	float fConst479;
	float fRec81[2];
	FAUSTFLOAT fVbargraph12;
	float fConst480;
	float fConst481;
	float fConst482;
	float fConst483;
	float fConst484;
	float fConst485;
	float fConst486;
	float fConst487;
	float fConst488;
	float fConst489;
	float fConst490;
	float fConst491;
	float fConst492;
	float fConst493;
	float fConst494;
	float fConst495;
	float fConst496;
	float fConst497;
	float fConst498;
	float fConst499;
	float fConst500;
	float fRec94[3];
	float fConst501;
	float fConst502;
	float fConst503;
	float fRec93[3];
	float fConst504;
	float fConst505;
	float fConst506;
	float fRec92[3];
	float fConst507;
	float fConst508;
	float fConst509;
	float fConst510;
	float fRec91[3];
	float fConst511;
	float fConst512;
	float fConst513;
	float fRec90[3];
	float fConst514;
	float fConst515;
	float fConst516;
	float fRec89[3];
	float fConst517;
	float fRec88[2];
	FAUSTFLOAT fVbargraph13;
	float fConst518;
	float fConst519;
	float fConst520;
	float fConst521;
	float fConst522;
	float fConst523;
	float fConst524;
	float fConst525;
	float fConst526;
	float fConst527;
	float fConst528;
	float fConst529;
	float fConst530;
	float fConst531;
	float fConst532;
	float fConst533;
	float fConst534;
	float fConst535;
	float fConst536;
	float fConst537;
	float fConst538;
	float fRec101[3];
	float fConst539;
	float fConst540;
	float fConst541;
	float fRec100[3];
	float fConst542;
	float fConst543;
	float fConst544;
	float fRec99[3];
	float fConst545;
	float fConst546;
	float fConst547;
	float fConst548;
	float fRec98[3];
	float fConst549;
	float fConst550;
	float fConst551;
	float fRec97[3];
	float fConst552;
	float fConst553;
	float fConst554;
	float fRec96[3];
	float fConst555;
	float fRec95[2];
	FAUSTFLOAT fVbargraph14;
	float fConst556;
	float fConst557;
	float fConst558;
	float fConst559;
	float fConst560;
	float fConst561;
	float fConst562;
	float fConst563;
	float fConst564;
	float fConst565;
	float fConst566;
	float fConst567;
	float fConst568;
	float fConst569;
	float fConst570;
	float fConst571;
	float fConst572;
	float fConst573;
	float fConst574;
	float fConst575;
	float fConst576;
	float fRec108[3];
	float fConst577;
	float fConst578;
	float fConst579;
	float fRec107[3];
	float fConst580;
	float fConst581;
	float fConst582;
	float fRec106[3];
	float fConst583;
	float fConst584;
	float fConst585;
	float fConst586;
	float fRec105[3];
	float fConst587;
	float fConst588;
	float fConst589;
	float fRec104[3];
	float fConst590;
	float fConst591;
	float fConst592;
	float fRec103[3];
	float fConst593;
	float fRec102[2];
	FAUSTFLOAT fVbargraph15;
	float fConst594;
	float fConst595;
	float fConst596;
	float fConst597;
	float fConst598;
	float fConst599;
	float fConst600;
	float fConst601;
	float fConst602;
	float fConst603;
	float fConst604;
	float fConst605;
	float fConst606;
	float fConst607;
	float fConst608;
	float fConst609;
	float fConst610;
	float fConst611;
	float fConst612;
	float fConst613;
	float fConst614;
	float fRec115[3];
	float fConst615;
	float fConst616;
	float fConst617;
	float fRec114[3];
	float fConst618;
	float fConst619;
	float fConst620;
	float fRec113[3];
	float fConst621;
	float fConst622;
	float fConst623;
	float fConst624;
	float fRec112[3];
	float fConst625;
	float fConst626;
	float fConst627;
	float fRec111[3];
	float fConst628;
	float fConst629;
	float fConst630;
	float fRec110[3];
	float fConst631;
	float fRec109[2];
	FAUSTFLOAT fVbargraph16;
	float fConst632;
	float fConst633;
	float fConst634;
	float fConst635;
	float fConst636;
	float fConst637;
	float fConst638;
	float fConst639;
	float fConst640;
	float fConst641;
	float fConst642;
	float fConst643;
	float fConst644;
	float fConst645;
	float fConst646;
	float fConst647;
	float fConst648;
	float fConst649;
	float fConst650;
	float fConst651;
	float fConst652;
	float fRec122[3];
	float fConst653;
	float fConst654;
	float fConst655;
	float fRec121[3];
	float fConst656;
	float fConst657;
	float fConst658;
	float fRec120[3];
	float fConst659;
	float fConst660;
	float fConst661;
	float fConst662;
	float fRec119[3];
	float fConst663;
	float fConst664;
	float fConst665;
	float fRec118[3];
	float fConst666;
	float fConst667;
	float fConst668;
	float fRec117[3];
	float fConst669;
	float fRec116[2];
	FAUSTFLOAT fVbargraph17;
	float fConst670;
	float fConst671;
	float fConst672;
	float fConst673;
	float fConst674;
	float fConst675;
	float fConst676;
	float fConst677;
	float fConst678;
	float fConst679;
	float fConst680;
	float fConst681;
	float fConst682;
	float fConst683;
	float fConst684;
	float fConst685;
	float fConst686;
	float fConst687;
	float fConst688;
	float fConst689;
	float fConst690;
	float fRec129[3];
	float fConst691;
	float fConst692;
	float fConst693;
	float fRec128[3];
	float fConst694;
	float fConst695;
	float fConst696;
	float fRec127[3];
	float fConst697;
	float fConst698;
	float fConst699;
	float fConst700;
	float fRec126[3];
	float fConst701;
	float fConst702;
	float fConst703;
	float fRec125[3];
	float fConst704;
	float fConst705;
	float fConst706;
	float fRec124[3];
	float fConst707;
	float fRec123[2];
	FAUSTFLOAT fVbargraph18;
	float fConst708;
	float fConst709;
	float fConst710;
	float fConst711;
	float fConst712;
	float fConst713;
	float fConst714;
	float fConst715;
	float fConst716;
	float fConst717;
	float fConst718;
	float fConst719;
	float fConst720;
	float fConst721;
	float fConst722;
	float fConst723;
	float fConst724;
	float fConst725;
	float fConst726;
	float fConst727;
	float fConst728;
	float fRec136[3];
	float fConst729;
	float fConst730;
	float fConst731;
	float fRec135[3];
	float fConst732;
	float fConst733;
	float fConst734;
	float fRec134[3];
	float fConst735;
	float fConst736;
	float fConst737;
	float fConst738;
	float fRec133[3];
	float fConst739;
	float fConst740;
	float fConst741;
	float fRec132[3];
	float fConst742;
	float fConst743;
	float fConst744;
	float fRec131[3];
	float fConst745;
	float fRec130[2];
	FAUSTFLOAT fVbargraph19;
	float fConst746;
	float fConst747;
	float fConst748;
	float fConst749;
	float fConst750;
	float fConst751;
	float fConst752;
	float fConst753;
	float fConst754;
	float fConst755;
	float fConst756;
	float fConst757;
	float fConst758;
	float fConst759;
	float fConst760;
	float fConst761;
	float fConst762;
	float fConst763;
	float fConst764;
	float fConst765;
	float fConst766;
	float fRec143[3];
	float fConst767;
	float fConst768;
	float fConst769;
	float fRec142[3];
	float fConst770;
	float fConst771;
	float fConst772;
	float fRec141[3];
	float fConst773;
	float fConst774;
	float fConst775;
	float fConst776;
	float fRec140[3];
	float fConst777;
	float fConst778;
	float fConst779;
	float fRec139[3];
	float fConst780;
	float fConst781;
	float fConst782;
	float fRec138[3];
	float fConst783;
	float fRec137[2];
	FAUSTFLOAT fVbargraph20;
	float fConst784;
	float fConst785;
	float fConst786;
	float fConst787;
	float fConst788;
	float fConst789;
	float fConst790;
	float fConst791;
	float fConst792;
	float fConst793;
	float fConst794;
	float fConst795;
	float fConst796;
	float fConst797;
	float fConst798;
	float fConst799;
	float fConst800;
	float fConst801;
	float fConst802;
	float fConst803;
	float fConst804;
	float fRec150[3];
	float fConst805;
	float fConst806;
	float fConst807;
	float fRec149[3];
	float fConst808;
	float fConst809;
	float fConst810;
	float fRec148[3];
	float fConst811;
	float fConst812;
	float fConst813;
	float fConst814;
	float fRec147[3];
	float fConst815;
	float fConst816;
	float fConst817;
	float fRec146[3];
	float fConst818;
	float fConst819;
	float fConst820;
	float fRec145[3];
	float fConst821;
	float fRec144[2];
	FAUSTFLOAT fVbargraph21;
	float fConst822;
	float fConst823;
	float fConst824;
	float fConst825;
	float fConst826;
	float fConst827;
	float fConst828;
	float fConst829;
	float fConst830;
	float fConst831;
	float fConst832;
	float fConst833;
	float fConst834;
	float fConst835;
	float fConst836;
	float fConst837;
	float fConst838;
	float fConst839;
	float fConst840;
	float fConst841;
	float fConst842;
	float fRec157[3];
	float fConst843;
	float fConst844;
	float fConst845;
	float fRec156[3];
	float fConst846;
	float fConst847;
	float fConst848;
	float fRec155[3];
	float fConst849;
	float fConst850;
	float fConst851;
	float fConst852;
	float fRec154[3];
	float fConst853;
	float fConst854;
	float fConst855;
	float fRec153[3];
	float fConst856;
	float fConst857;
	float fConst858;
	float fRec152[3];
	float fConst859;
	float fRec151[2];
	FAUSTFLOAT fVbargraph22;
	float fConst860;
	float fConst861;
	float fConst862;
	float fConst863;
	float fConst864;
	float fConst865;
	float fConst866;
	float fConst867;
	float fConst868;
	float fConst869;
	float fConst870;
	float fConst871;
	float fConst872;
	float fConst873;
	float fConst874;
	float fConst875;
	float fConst876;
	float fConst877;
	float fConst878;
	float fConst879;
	float fConst880;
	float fRec164[3];
	float fConst881;
	float fConst882;
	float fConst883;
	float fRec163[3];
	float fConst884;
	float fConst885;
	float fConst886;
	float fRec162[3];
	float fConst887;
	float fConst888;
	float fConst889;
	float fConst890;
	float fRec161[3];
	float fConst891;
	float fConst892;
	float fConst893;
	float fRec160[3];
	float fConst894;
	float fConst895;
	float fConst896;
	float fRec159[3];
	float fConst897;
	float fRec158[2];
	FAUSTFLOAT fVbargraph23;
	float fConst898;
	float fConst899;
	float fConst900;
	float fConst901;
	float fConst902;
	float fConst903;
	float fConst904;
	float fConst905;
	float fConst906;
	float fConst907;
	float fConst908;
	float fConst909;
	float fConst910;
	float fConst911;
	float fConst912;
	float fConst913;
	float fConst914;
	float fConst915;
	float fConst916;
	float fConst917;
	float fConst918;
	float fRec171[3];
	float fConst919;
	float fConst920;
	float fConst921;
	float fRec170[3];
	float fConst922;
	float fConst923;
	float fConst924;
	float fRec169[3];
	float fConst925;
	float fConst926;
	float fConst927;
	float fConst928;
	float fRec168[3];
	float fConst929;
	float fConst930;
	float fConst931;
	float fRec167[3];
	float fConst932;
	float fConst933;
	float fConst934;
	float fRec166[3];
	float fConst935;
	float fRec165[2];
	FAUSTFLOAT fVbargraph24;
	float fConst936;
	float fConst937;
	float fConst938;
	float fConst939;
	float fConst940;
	float fConst941;
	float fConst942;
	float fConst943;
	float fConst944;
	float fConst945;
	float fConst946;
	float fConst947;
	float fConst948;
	float fConst949;
	float fConst950;
	float fConst951;
	float fConst952;
	float fConst953;
	float fConst954;
	float fConst955;
	float fConst956;
	float fRec178[3];
	float fConst957;
	float fConst958;
	float fConst959;
	float fRec177[3];
	float fConst960;
	float fConst961;
	float fConst962;
	float fRec176[3];
	float fConst963;
	float fConst964;
	float fConst965;
	float fConst966;
	float fRec175[3];
	float fConst967;
	float fConst968;
	float fConst969;
	float fRec174[3];
	float fConst970;
	float fConst971;
	float fConst972;
	float fRec173[3];
	float fConst973;
	float fRec172[2];
	FAUSTFLOAT fVbargraph25;
	float fConst974;
	float fConst975;
	float fConst976;
	float fConst977;
	float fConst978;
	float fConst979;
	float fConst980;
	float fConst981;
	float fConst982;
	float fConst983;
	float fConst984;
	float fConst985;
	float fConst986;
	float fConst987;
	float fConst988;
	float fConst989;
	float fConst990;
	float fConst991;
	float fConst992;
	float fConst993;
	float fConst994;
	float fRec185[3];
	float fConst995;
	float fConst996;
	float fConst997;
	float fRec184[3];
	float fConst998;
	float fConst999;
	float fConst1000;
	float fRec183[3];
	float fConst1001;
	float fConst1002;
	float fConst1003;
	float fConst1004;
	float fRec182[3];
	float fConst1005;
	float fConst1006;
	float fConst1007;
	float fRec181[3];
	float fConst1008;
	float fConst1009;
	float fConst1010;
	float fRec180[3];
	float fConst1011;
	float fRec179[2];
	FAUSTFLOAT fVbargraph26;
	float fConst1012;
	float fConst1013;
	float fConst1014;
	float fConst1015;
	float fConst1016;
	float fConst1017;
	float fConst1018;
	float fConst1019;
	float fConst1020;
	float fConst1021;
	float fConst1022;
	float fConst1023;
	float fConst1024;
	float fConst1025;
	float fConst1026;
	float fConst1027;
	float fConst1028;
	float fConst1029;
	float fConst1030;
	float fConst1031;
	float fConst1032;
	float fRec192[3];
	float fConst1033;
	float fConst1034;
	float fConst1035;
	float fRec191[3];
	float fConst1036;
	float fConst1037;
	float fConst1038;
	float fRec190[3];
	float fConst1039;
	float fConst1040;
	float fConst1041;
	float fConst1042;
	float fRec189[3];
	float fConst1043;
	float fConst1044;
	float fConst1045;
	float fRec188[3];
	float fConst1046;
	float fConst1047;
	float fConst1048;
	float fRec187[3];
	float fConst1049;
	float fRec186[2];
	FAUSTFLOAT fVbargraph27;
	float fConst1050;
	float fConst1051;
	float fConst1052;
	float fConst1053;
	float fConst1054;
	float fConst1055;
	float fConst1056;
	float fConst1057;
	float fConst1058;
	float fConst1059;
	float fConst1060;
	float fConst1061;
	float fConst1062;
	float fConst1063;
	float fConst1064;
	float fConst1065;
	float fConst1066;
	float fConst1067;
	float fConst1068;
	float fConst1069;
	float fConst1070;
	float fRec199[3];
	float fConst1071;
	float fConst1072;
	float fConst1073;
	float fRec198[3];
	float fConst1074;
	float fConst1075;
	float fConst1076;
	float fRec197[3];
	float fConst1077;
	float fConst1078;
	float fConst1079;
	float fConst1080;
	float fRec196[3];
	float fConst1081;
	float fConst1082;
	float fConst1083;
	float fRec195[3];
	float fConst1084;
	float fConst1085;
	float fConst1086;
	float fRec194[3];
	float fConst1087;
	float fRec193[2];
	FAUSTFLOAT fVbargraph28;
	float fConst1088;
	float fConst1089;
	float fConst1090;
	float fConst1091;
	float fConst1092;
	float fConst1093;
	float fConst1094;
	float fConst1095;
	float fConst1096;
	float fConst1097;
	float fConst1098;
	float fConst1099;
	float fConst1100;
	float fConst1101;
	float fConst1102;
	float fConst1103;
	float fConst1104;
	float fConst1105;
	float fConst1106;
	float fConst1107;
	float fConst1108;
	float fRec206[3];
	float fConst1109;
	float fConst1110;
	float fConst1111;
	float fRec205[3];
	float fConst1112;
	float fConst1113;
	float fConst1114;
	float fRec204[3];
	float fConst1115;
	float fConst1116;
	float fConst1117;
	float fConst1118;
	float fRec203[3];
	float fConst1119;
	float fConst1120;
	float fConst1121;
	float fRec202[3];
	float fConst1122;
	float fConst1123;
	float fConst1124;
	float fRec201[3];
	float fConst1125;
	float fRec200[2];
	FAUSTFLOAT fVbargraph29;
	float fConst1126;
	float fConst1127;
	float fConst1128;
	float fConst1129;
	float fConst1130;
	float fConst1131;
	float fConst1132;
	float fConst1133;
	float fConst1134;
	float fConst1135;
	float fConst1136;
	float fConst1137;
	float fConst1138;
	float fConst1139;
	float fConst1140;
	float fConst1141;
	float fConst1142;
	float fConst1143;
	float fConst1144;
	float fConst1145;
	float fConst1146;
	float fRec213[3];
	float fConst1147;
	float fConst1148;
	float fConst1149;
	float fRec212[3];
	float fConst1150;
	float fConst1151;
	float fConst1152;
	float fRec211[3];
	float fConst1153;
	float fConst1154;
	float fConst1155;
	float fConst1156;
	float fRec210[3];
	float fConst1157;
	float fConst1158;
	float fConst1159;
	float fRec209[3];
	float fConst1160;
	float fConst1161;
	float fConst1162;
	float fRec208[3];
	float fConst1163;
	float fRec207[2];
	FAUSTFLOAT fVbargraph30;
	float fConst1164;
	float fConst1165;
	float fConst1166;
	float fConst1167;
	float fConst1168;
	float fConst1169;
	float fConst1170;
	float fConst1171;
	float fConst1172;
	float fConst1173;
	float fConst1174;
	float fConst1175;
	float fConst1176;
	float fConst1177;
	float fConst1178;
	float fConst1179;
	float fConst1180;
	float fConst1181;
	float fConst1182;
	float fConst1183;
	float fConst1184;
	float fRec220[3];
	float fConst1185;
	float fConst1186;
	float fConst1187;
	float fRec219[3];
	float fConst1188;
	float fConst1189;
	float fConst1190;
	float fRec218[3];
	float fConst1191;
	float fConst1192;
	float fConst1193;
	float fConst1194;
	float fRec217[3];
	float fConst1195;
	float fConst1196;
	float fConst1197;
	float fRec216[3];
	float fConst1198;
	float fConst1199;
	float fConst1200;
	float fRec215[3];
	float fConst1201;
	float fRec214[2];
	FAUSTFLOAT fVbargraph31;
	float fConst1202;
	float fConst1203;
	float fConst1204;
	float fConst1205;
	float fConst1206;
	float fConst1207;
	float fConst1208;
	float fConst1209;
	float fConst1210;
	float fConst1211;
	float fConst1212;
	float fConst1213;
	float fConst1214;
	float fConst1215;
	float fConst1216;
	float fConst1217;
	float fConst1218;
	float fConst1219;
	float fConst1220;
	float fConst1221;
	float fConst1222;
	float fRec227[3];
	float fConst1223;
	float fConst1224;
	float fConst1225;
	float fRec226[3];
	float fConst1226;
	float fConst1227;
	float fConst1228;
	float fRec225[3];
	float fConst1229;
	float fConst1230;
	float fConst1231;
	float fConst1232;
	float fRec224[3];
	float fConst1233;
	float fConst1234;
	float fConst1235;
	float fRec223[3];
	float fConst1236;
	float fConst1237;
	float fConst1238;
	float fRec222[3];
	float fConst1239;
	float fRec221[2];
	FAUSTFLOAT fVbargraph32;
	float fConst1240;
	float fConst1241;
	float fConst1242;
	float fConst1243;
	float fConst1244;
	float fConst1245;
	float fConst1246;
	float fConst1247;
	float fConst1248;
	float fConst1249;
	float fConst1250;
	float fConst1251;
	float fConst1252;
	float fConst1253;
	float fConst1254;
	float fConst1255;
	float fConst1256;
	float fConst1257;
	float fConst1258;
	float fConst1259;
	float fConst1260;
	float fRec234[3];
	float fConst1261;
	float fConst1262;
	float fConst1263;
	float fRec233[3];
	float fConst1264;
	float fConst1265;
	float fConst1266;
	float fRec232[3];
	float fConst1267;
	float fConst1268;
	float fConst1269;
	float fConst1270;
	float fRec231[3];
	float fConst1271;
	float fConst1272;
	float fConst1273;
	float fRec230[3];
	float fConst1274;
	float fConst1275;
	float fConst1276;
	float fRec229[3];
	float fConst1277;
	float fRec228[2];
	FAUSTFLOAT fVbargraph33;
	float fConst1278;
	float fConst1279;
	float fConst1280;
	float fConst1281;
	float fConst1282;
	float fConst1283;
	float fConst1284;
	float fConst1285;
	float fConst1286;
	float fConst1287;
	float fConst1288;
	float fConst1289;
	float fConst1290;
	float fConst1291;
	float fConst1292;
	float fConst1293;
	float fConst1294;
	float fConst1295;
	float fConst1296;
	float fConst1297;
	float fConst1298;
	float fRec241[3];
	float fConst1299;
	float fConst1300;
	float fConst1301;
	float fRec240[3];
	float fConst1302;
	float fConst1303;
	float fConst1304;
	float fRec239[3];
	float fConst1305;
	float fConst1306;
	float fConst1307;
	float fConst1308;
	float fRec238[3];
	float fConst1309;
	float fConst1310;
	float fConst1311;
	float fRec237[3];
	float fConst1312;
	float fConst1313;
	float fConst1314;
	float fRec236[3];
	float fConst1315;
	float fRec235[2];
	FAUSTFLOAT fVbargraph34;
	float fConst1316;
	float fConst1317;
	float fConst1318;
	float fConst1319;
	float fConst1320;
	float fConst1321;
	float fConst1322;
	float fConst1323;
	float fConst1324;
	float fConst1325;
	float fConst1326;
	float fConst1327;
	float fConst1328;
	float fConst1329;
	float fConst1330;
	float fConst1331;
	float fConst1332;
	float fConst1333;
	float fConst1334;
	float fConst1335;
	float fConst1336;
	float fRec248[3];
	float fConst1337;
	float fConst1338;
	float fConst1339;
	float fRec247[3];
	float fConst1340;
	float fConst1341;
	float fConst1342;
	float fRec246[3];
	float fConst1343;
	float fConst1344;
	float fConst1345;
	float fConst1346;
	float fRec245[3];
	float fConst1347;
	float fConst1348;
	float fConst1349;
	float fRec244[3];
	float fConst1350;
	float fConst1351;
	float fConst1352;
	float fRec243[3];
	float fConst1353;
	float fRec242[2];
	FAUSTFLOAT fVbargraph35;
	float fConst1354;
	float fConst1355;
	float fConst1356;
	float fConst1357;
	float fConst1358;
	float fConst1359;
	float fConst1360;
	float fConst1361;
	float fConst1362;
	float fConst1363;
	float fConst1364;
	float fConst1365;
	float fConst1366;
	float fConst1367;
	float fConst1368;
	float fConst1369;
	float fConst1370;
	float fConst1371;
	float fConst1372;
	float fConst1373;
	float fConst1374;
	float fRec255[3];
	float fConst1375;
	float fConst1376;
	float fConst1377;
	float fRec254[3];
	float fConst1378;
	float fConst1379;
	float fConst1380;
	float fRec253[3];
	float fConst1381;
	float fConst1382;
	float fConst1383;
	float fConst1384;
	float fRec252[3];
	float fConst1385;
	float fConst1386;
	float fConst1387;
	float fRec251[3];
	float fConst1388;
	float fConst1389;
	float fConst1390;
	float fRec250[3];
	float fConst1391;
	float fRec249[2];
	FAUSTFLOAT fVbargraph36;
	float fConst1392;
	float fConst1393;
	float fConst1394;
	float fConst1395;
	float fConst1396;
	float fConst1397;
	float fConst1398;
	float fConst1399;
	float fConst1400;
	float fConst1401;
	float fConst1402;
	float fConst1403;
	float fConst1404;
	float fConst1405;
	float fConst1406;
	float fConst1407;
	float fConst1408;
	float fConst1409;
	float fConst1410;
	float fConst1411;
	float fConst1412;
	float fRec262[3];
	float fConst1413;
	float fConst1414;
	float fConst1415;
	float fRec261[3];
	float fConst1416;
	float fConst1417;
	float fConst1418;
	float fRec260[3];
	float fConst1419;
	float fConst1420;
	float fConst1421;
	float fConst1422;
	float fRec259[3];
	float fConst1423;
	float fConst1424;
	float fConst1425;
	float fRec258[3];
	float fConst1426;
	float fConst1427;
	float fConst1428;
	float fRec257[3];
	float fConst1429;
	float fRec256[2];
	FAUSTFLOAT fVbargraph37;
	float fConst1430;
	float fConst1431;
	float fConst1432;
	float fConst1433;
	float fConst1434;
	float fConst1435;
	float fConst1436;
	float fConst1437;
	float fConst1438;
	float fConst1439;
	float fConst1440;
	float fConst1441;
	float fConst1442;
	float fConst1443;
	float fConst1444;
	float fConst1445;
	float fConst1446;
	float fConst1447;
	float fConst1448;
	float fConst1449;
	float fConst1450;
	float fRec269[3];
	float fConst1451;
	float fConst1452;
	float fConst1453;
	float fRec268[3];
	float fConst1454;
	float fConst1455;
	float fConst1456;
	float fRec267[3];
	float fConst1457;
	float fConst1458;
	float fConst1459;
	float fConst1460;
	float fRec266[3];
	float fConst1461;
	float fConst1462;
	float fConst1463;
	float fRec265[3];
	float fConst1464;
	float fConst1465;
	float fConst1466;
	float fRec264[3];
	float fConst1467;
	float fRec263[2];
	FAUSTFLOAT fVbargraph38;
	float fConst1468;
	float fConst1469;
	float fConst1470;
	float fConst1471;
	float fConst1472;
	float fConst1473;
	float fConst1474;
	float fConst1475;
	float fConst1476;
	float fConst1477;
	float fConst1478;
	float fConst1479;
	float fConst1480;
	float fConst1481;
	float fConst1482;
	float fConst1483;
	float fConst1484;
	float fConst1485;
	float fConst1486;
	float fConst1487;
	float fConst1488;
	float fRec276[3];
	float fConst1489;
	float fConst1490;
	float fConst1491;
	float fRec275[3];
	float fConst1492;
	float fConst1493;
	float fConst1494;
	float fRec274[3];
	float fConst1495;
	float fConst1496;
	float fConst1497;
	float fConst1498;
	float fRec273[3];
	float fConst1499;
	float fConst1500;
	float fConst1501;
	float fRec272[3];
	float fConst1502;
	float fConst1503;
	float fConst1504;
	float fRec271[3];
	float fConst1505;
	float fRec270[2];
	FAUSTFLOAT fVbargraph39;
	float fConst1506;
	float fConst1507;
	float fConst1508;
	float fConst1509;
	float fConst1510;
	float fConst1511;
	float fConst1512;
	float fConst1513;
	float fConst1514;
	float fConst1515;
	float fConst1516;
	float fConst1517;
	float fConst1518;
	float fConst1519;
	float fConst1520;
	float fConst1521;
	float fConst1522;
	float fConst1523;
	float fConst1524;
	float fConst1525;
	float fConst1526;
	float fRec283[3];
	float fConst1527;
	float fConst1528;
	float fConst1529;
	float fRec282[3];
	float fConst1530;
	float fConst1531;
	float fConst1532;
	float fRec281[3];
	float fConst1533;
	float fConst1534;
	float fConst1535;
	float fConst1536;
	float fRec280[3];
	float fConst1537;
	float fConst1538;
	float fConst1539;
	float fRec279[3];
	float fConst1540;
	float fConst1541;
	float fConst1542;
	float fRec278[3];
	float fConst1543;
	float fRec277[2];
	FAUSTFLOAT fVbargraph40;
	float fConst1544;
	float fConst1545;
	float fConst1546;
	float fConst1547;
	float fConst1548;
	float fConst1549;
	float fConst1550;
	float fConst1551;
	float fConst1552;
	float fConst1553;
	float fConst1554;
	float fConst1555;
	float fConst1556;
	float fConst1557;
	float fConst1558;
	float fConst1559;
	float fConst1560;
	float fConst1561;
	float fConst1562;
	float fConst1563;
	float fConst1564;
	float fRec290[3];
	float fConst1565;
	float fConst1566;
	float fConst1567;
	float fRec289[3];
	float fConst1568;
	float fConst1569;
	float fConst1570;
	float fRec288[3];
	float fConst1571;
	float fConst1572;
	float fConst1573;
	float fConst1574;
	float fRec287[3];
	float fConst1575;
	float fConst1576;
	float fConst1577;
	float fRec286[3];
	float fConst1578;
	float fConst1579;
	float fConst1580;
	float fRec285[3];
	float fConst1581;
	float fRec284[2];
	FAUSTFLOAT fVbargraph41;
	float fConst1582;
	float fConst1583;
	float fConst1584;
	float fConst1585;
	float fConst1586;
	float fConst1587;
	float fConst1588;
	float fConst1589;
	float fConst1590;
	float fConst1591;
	float fConst1592;
	float fConst1593;
	float fConst1594;
	float fConst1595;
	float fConst1596;
	float fConst1597;
	float fConst1598;
	float fConst1599;
	float fConst1600;
	float fConst1601;
	float fConst1602;
	float fRec297[3];
	float fConst1603;
	float fConst1604;
	float fConst1605;
	float fRec296[3];
	float fConst1606;
	float fConst1607;
	float fConst1608;
	float fRec295[3];
	float fConst1609;
	float fConst1610;
	float fConst1611;
	float fConst1612;
	float fRec294[3];
	float fConst1613;
	float fConst1614;
	float fConst1615;
	float fRec293[3];
	float fConst1616;
	float fConst1617;
	float fConst1618;
	float fRec292[3];
	float fConst1619;
	float fRec291[2];
	FAUSTFLOAT fVbargraph42;
	float fConst1620;
	float fConst1621;
	float fConst1622;
	float fConst1623;
	float fConst1624;
	float fConst1625;
	float fConst1626;
	float fConst1627;
	float fConst1628;
	float fConst1629;
	float fConst1630;
	float fConst1631;
	float fConst1632;
	float fConst1633;
	float fConst1634;
	float fConst1635;
	float fConst1636;
	float fConst1637;
	float fConst1638;
	float fConst1639;
	float fConst1640;
	float fRec304[3];
	float fConst1641;
	float fConst1642;
	float fConst1643;
	float fRec303[3];
	float fConst1644;
	float fConst1645;
	float fConst1646;
	float fRec302[3];
	float fConst1647;
	float fConst1648;
	float fConst1649;
	float fConst1650;
	float fRec301[3];
	float fConst1651;
	float fConst1652;
	float fConst1653;
	float fRec300[3];
	float fConst1654;
	float fConst1655;
	float fConst1656;
	float fRec299[3];
	float fConst1657;
	float fRec298[2];
	FAUSTFLOAT fVbargraph43;
	float fConst1658;
	float fConst1659;
	float fConst1660;
	float fConst1661;
	float fConst1662;
	float fConst1663;
	float fConst1664;
	float fConst1665;
	float fConst1666;
	float fConst1667;
	float fConst1668;
	float fConst1669;
	float fConst1670;
	float fConst1671;
	float fConst1672;
	float fConst1673;
	float fConst1674;
	float fConst1675;
	float fConst1676;
	float fConst1677;
	float fConst1678;
	float fRec311[3];
	float fConst1679;
	float fConst1680;
	float fConst1681;
	float fRec310[3];
	float fConst1682;
	float fConst1683;
	float fConst1684;
	float fRec309[3];
	float fConst1685;
	float fConst1686;
	float fConst1687;
	float fConst1688;
	float fRec308[3];
	float fConst1689;
	float fConst1690;
	float fConst1691;
	float fRec307[3];
	float fConst1692;
	float fConst1693;
	float fConst1694;
	float fRec306[3];
	float fConst1695;
	float fRec305[2];
	FAUSTFLOAT fVbargraph44;
	float fConst1696;
	float fConst1697;
	float fConst1698;
	float fConst1699;
	float fConst1700;
	float fConst1701;
	float fConst1702;
	float fConst1703;
	float fConst1704;
	float fConst1705;
	float fConst1706;
	float fConst1707;
	float fConst1708;
	float fConst1709;
	float fConst1710;
	float fConst1711;
	float fConst1712;
	float fConst1713;
	float fConst1714;
	float fConst1715;
	float fConst1716;
	float fRec318[3];
	float fConst1717;
	float fConst1718;
	float fConst1719;
	float fRec317[3];
	float fConst1720;
	float fConst1721;
	float fConst1722;
	float fRec316[3];
	float fConst1723;
	float fConst1724;
	float fConst1725;
	float fConst1726;
	float fRec315[3];
	float fConst1727;
	float fConst1728;
	float fConst1729;
	float fRec314[3];
	float fConst1730;
	float fConst1731;
	float fConst1732;
	float fRec313[3];
	float fConst1733;
	float fRec312[2];
	FAUSTFLOAT fVbargraph45;
	float fConst1734;
	float fConst1735;
	float fConst1736;
	float fConst1737;
	float fConst1738;
	float fConst1739;
	float fConst1740;
	float fConst1741;
	float fConst1742;
	float fConst1743;
	float fConst1744;
	float fConst1745;
	float fConst1746;
	float fConst1747;
	float fConst1748;
	float fConst1749;
	float fConst1750;
	float fConst1751;
	float fConst1752;
	float fConst1753;
	float fConst1754;
	float fRec325[3];
	float fConst1755;
	float fConst1756;
	float fConst1757;
	float fRec324[3];
	float fConst1758;
	float fConst1759;
	float fConst1760;
	float fRec323[3];
	float fConst1761;
	float fConst1762;
	float fConst1763;
	float fConst1764;
	float fRec322[3];
	float fConst1765;
	float fConst1766;
	float fConst1767;
	float fRec321[3];
	float fConst1768;
	float fConst1769;
	float fConst1770;
	float fRec320[3];
	float fConst1771;
	float fRec319[2];
	FAUSTFLOAT fVbargraph46;
	float fConst1772;
	float fConst1773;
	float fConst1774;
	float fConst1775;
	float fConst1776;
	float fConst1777;
	float fConst1778;
	float fConst1779;
	float fConst1780;
	float fConst1781;
	float fConst1782;
	float fConst1783;
	float fConst1784;
	float fConst1785;
	float fConst1786;
	float fConst1787;
	float fConst1788;
	float fConst1789;
	float fConst1790;
	float fConst1791;
	float fConst1792;
	float fRec332[3];
	float fConst1793;
	float fConst1794;
	float fConst1795;
	float fRec331[3];
	float fConst1796;
	float fConst1797;
	float fConst1798;
	float fRec330[3];
	float fConst1799;
	float fConst1800;
	float fConst1801;
	float fConst1802;
	float fRec329[3];
	float fConst1803;
	float fConst1804;
	float fConst1805;
	float fRec328[3];
	float fConst1806;
	float fConst1807;
	float fConst1808;
	float fRec327[3];
	float fConst1809;
	float fRec326[2];
	FAUSTFLOAT fVbargraph47;
	float fConst1810;
	float fConst1811;
	float fConst1812;
	float fConst1813;
	float fConst1814;
	float fConst1815;
	float fConst1816;
	float fConst1817;
	float fConst1818;
	float fConst1819;
	float fConst1820;
	float fConst1821;
	float fConst1822;
	float fConst1823;
	float fConst1824;
	float fConst1825;
	float fConst1826;
	float fConst1827;
	float fConst1828;
	float fConst1829;
	float fConst1830;
	float fRec339[3];
	float fConst1831;
	float fConst1832;
	float fConst1833;
	float fRec338[3];
	float fConst1834;
	float fConst1835;
	float fConst1836;
	float fRec337[3];
	float fConst1837;
	float fConst1838;
	float fConst1839;
	float fConst1840;
	float fRec336[3];
	float fConst1841;
	float fConst1842;
	float fConst1843;
	float fRec335[3];
	float fConst1844;
	float fConst1845;
	float fConst1846;
	float fRec334[3];
	float fConst1847;
	float fRec333[2];
	FAUSTFLOAT fVbargraph48;
	float fConst1848;
	float fConst1849;
	float fConst1850;
	float fConst1851;
	float fConst1852;
	float fConst1853;
	float fConst1854;
	float fConst1855;
	float fConst1856;
	float fConst1857;
	float fConst1858;
	float fConst1859;
	float fConst1860;
	float fConst1861;
	float fConst1862;
	float fConst1863;
	float fConst1864;
	float fConst1865;
	float fConst1866;
	float fConst1867;
	float fConst1868;
	float fRec346[3];
	float fConst1869;
	float fConst1870;
	float fConst1871;
	float fRec345[3];
	float fConst1872;
	float fConst1873;
	float fConst1874;
	float fRec344[3];
	float fConst1875;
	float fConst1876;
	float fConst1877;
	float fConst1878;
	float fRec343[3];
	float fConst1879;
	float fConst1880;
	float fConst1881;
	float fRec342[3];
	float fConst1882;
	float fConst1883;
	float fConst1884;
	float fRec341[3];
	float fConst1885;
	float fRec340[2];
	FAUSTFLOAT fVbargraph49;
	float fConst1886;
	float fConst1887;
	float fConst1888;
	float fConst1889;
	float fConst1890;
	float fConst1891;
	float fConst1892;
	float fConst1893;
	float fConst1894;
	float fConst1895;
	float fConst1896;
	float fConst1897;
	float fConst1898;
	float fConst1899;
	float fConst1900;
	float fConst1901;
	float fConst1902;
	float fConst1903;
	float fConst1904;
	float fConst1905;
	float fConst1906;
	float fRec353[3];
	float fConst1907;
	float fConst1908;
	float fConst1909;
	float fRec352[3];
	float fConst1910;
	float fConst1911;
	float fConst1912;
	float fRec351[3];
	float fConst1913;
	float fConst1914;
	float fConst1915;
	float fConst1916;
	float fRec350[3];
	float fConst1917;
	float fConst1918;
	float fConst1919;
	float fRec349[3];
	float fConst1920;
	float fConst1921;
	float fConst1922;
	float fRec348[3];
	float fConst1923;
	float fRec347[2];
	FAUSTFLOAT fVbargraph50;
	float fConst1924;
	float fConst1925;
	float fConst1926;
	float fConst1927;
	float fConst1928;
	float fConst1929;
	float fConst1930;
	float fConst1931;
	float fConst1932;
	float fConst1933;
	float fConst1934;
	float fConst1935;
	float fConst1936;
	float fConst1937;
	float fConst1938;
	float fConst1939;
	float fConst1940;
	float fConst1941;
	float fConst1942;
	float fConst1943;
	float fConst1944;
	float fRec360[3];
	float fConst1945;
	float fConst1946;
	float fConst1947;
	float fRec359[3];
	float fConst1948;
	float fConst1949;
	float fConst1950;
	float fRec358[3];
	float fConst1951;
	float fConst1952;
	float fConst1953;
	float fConst1954;
	float fRec357[3];
	float fConst1955;
	float fConst1956;
	float fConst1957;
	float fRec356[3];
	float fConst1958;
	float fConst1959;
	float fConst1960;
	float fRec355[3];
	float fConst1961;
	float fRec354[2];
	FAUSTFLOAT fVbargraph51;
	float fConst1962;
	float fConst1963;
	float fConst1964;
	float fConst1965;
	float fConst1966;
	float fConst1967;
	float fConst1968;
	float fConst1969;
	float fConst1970;
	float fConst1971;
	float fConst1972;
	float fConst1973;
	float fConst1974;
	float fConst1975;
	float fConst1976;
	float fConst1977;
	float fConst1978;
	float fConst1979;
	float fConst1980;
	float fConst1981;
	float fConst1982;
	float fRec367[3];
	float fConst1983;
	float fConst1984;
	float fConst1985;
	float fRec366[3];
	float fConst1986;
	float fConst1987;
	float fConst1988;
	float fRec365[3];
	float fConst1989;
	float fConst1990;
	float fConst1991;
	float fConst1992;
	float fRec364[3];
	float fConst1993;
	float fConst1994;
	float fConst1995;
	float fRec363[3];
	float fConst1996;
	float fConst1997;
	float fConst1998;
	float fRec362[3];
	float fConst1999;
	float fRec361[2];
	FAUSTFLOAT fVbargraph52;
	float fConst2000;
	float fConst2001;
	float fConst2002;
	float fConst2003;
	float fConst2004;
	float fConst2005;
	float fConst2006;
	float fConst2007;
	float fConst2008;
	float fConst2009;
	float fConst2010;
	float fConst2011;
	float fConst2012;
	float fConst2013;
	float fConst2014;
	float fConst2015;
	float fConst2016;
	float fConst2017;
	float fConst2018;
	float fConst2019;
	float fConst2020;
	float fRec374[3];
	float fConst2021;
	float fConst2022;
	float fConst2023;
	float fRec373[3];
	float fConst2024;
	float fConst2025;
	float fConst2026;
	float fRec372[3];
	float fConst2027;
	float fConst2028;
	float fConst2029;
	float fConst2030;
	float fRec371[3];
	float fConst2031;
	float fConst2032;
	float fConst2033;
	float fRec370[3];
	float fConst2034;
	float fConst2035;
	float fConst2036;
	float fRec369[3];
	float fConst2037;
	float fRec368[2];
	FAUSTFLOAT fVbargraph53;
	float fConst2038;
	float fConst2039;
	float fConst2040;
	float fConst2041;
	float fConst2042;
	float fConst2043;
	float fConst2044;
	float fConst2045;
	float fConst2046;
	float fConst2047;
	float fConst2048;
	float fConst2049;
	float fConst2050;
	float fConst2051;
	float fConst2052;
	float fConst2053;
	float fConst2054;
	float fConst2055;
	float fConst2056;
	float fConst2057;
	float fConst2058;
	float fRec381[3];
	float fConst2059;
	float fConst2060;
	float fConst2061;
	float fRec380[3];
	float fConst2062;
	float fConst2063;
	float fConst2064;
	float fRec379[3];
	float fConst2065;
	float fConst2066;
	float fConst2067;
	float fConst2068;
	float fRec378[3];
	float fConst2069;
	float fConst2070;
	float fConst2071;
	float fRec377[3];
	float fConst2072;
	float fConst2073;
	float fConst2074;
	float fRec376[3];
	float fConst2075;
	float fRec375[2];
	FAUSTFLOAT fVbargraph54;
	float fConst2076;
	float fConst2077;
	float fConst2078;
	float fConst2079;
	float fConst2080;
	float fConst2081;
	float fConst2082;
	float fConst2083;
	float fConst2084;
	float fConst2085;
	float fConst2086;
	float fConst2087;
	float fConst2088;
	float fConst2089;
	float fConst2090;
	float fConst2091;
	float fConst2092;
	float fConst2093;
	float fConst2094;
	float fConst2095;
	float fConst2096;
	float fRec388[3];
	float fConst2097;
	float fConst2098;
	float fConst2099;
	float fRec387[3];
	float fConst2100;
	float fConst2101;
	float fConst2102;
	float fRec386[3];
	float fConst2103;
	float fConst2104;
	float fConst2105;
	float fConst2106;
	float fRec385[3];
	float fConst2107;
	float fConst2108;
	float fConst2109;
	float fRec384[3];
	float fConst2110;
	float fConst2111;
	float fConst2112;
	float fRec383[3];
	float fConst2113;
	float fRec382[2];
	FAUSTFLOAT fVbargraph55;
	float fConst2114;
	float fConst2115;
	float fConst2116;
	float fConst2117;
	float fConst2118;
	float fConst2119;
	float fConst2120;
	float fConst2121;
	float fConst2122;
	float fConst2123;
	float fConst2124;
	float fConst2125;
	float fConst2126;
	float fConst2127;
	float fConst2128;
	float fConst2129;
	float fConst2130;
	float fConst2131;
	float fConst2132;
	float fConst2133;
	float fConst2134;
	float fRec395[3];
	float fConst2135;
	float fConst2136;
	float fConst2137;
	float fRec394[3];
	float fConst2138;
	float fConst2139;
	float fConst2140;
	float fRec393[3];
	float fConst2141;
	float fConst2142;
	float fConst2143;
	float fConst2144;
	float fRec392[3];
	float fConst2145;
	float fConst2146;
	float fConst2147;
	float fRec391[3];
	float fConst2148;
	float fConst2149;
	float fConst2150;
	float fRec390[3];
	float fConst2151;
	float fRec389[2];
	FAUSTFLOAT fVbargraph56;
	float fConst2152;
	float fConst2153;
	float fConst2154;
	float fConst2155;
	float fConst2156;
	float fConst2157;
	float fConst2158;
	float fConst2159;
	float fConst2160;
	float fConst2161;
	float fConst2162;
	float fConst2163;
	float fConst2164;
	float fConst2165;
	float fConst2166;
	float fConst2167;
	float fConst2168;
	float fConst2169;
	float fConst2170;
	float fConst2171;
	float fConst2172;
	float fRec402[3];
	float fConst2173;
	float fConst2174;
	float fConst2175;
	float fRec401[3];
	float fConst2176;
	float fConst2177;
	float fConst2178;
	float fRec400[3];
	float fConst2179;
	float fConst2180;
	float fConst2181;
	float fConst2182;
	float fRec399[3];
	float fConst2183;
	float fConst2184;
	float fConst2185;
	float fRec398[3];
	float fConst2186;
	float fConst2187;
	float fConst2188;
	float fRec397[3];
	float fConst2189;
	float fRec396[2];
	FAUSTFLOAT fVbargraph57;
	float fConst2190;
	float fConst2191;
	float fConst2192;
	float fConst2193;
	float fConst2194;
	float fConst2195;
	float fConst2196;
	float fConst2197;
	float fConst2198;
	float fConst2199;
	float fConst2200;
	float fConst2201;
	float fConst2202;
	float fConst2203;
	float fConst2204;
	float fConst2205;
	float fConst2206;
	float fConst2207;
	float fConst2208;
	float fConst2209;
	float fConst2210;
	float fRec409[3];
	float fConst2211;
	float fConst2212;
	float fConst2213;
	float fRec408[3];
	float fConst2214;
	float fConst2215;
	float fConst2216;
	float fRec407[3];
	float fConst2217;
	float fConst2218;
	float fConst2219;
	float fConst2220;
	float fRec406[3];
	float fConst2221;
	float fConst2222;
	float fConst2223;
	float fRec405[3];
	float fConst2224;
	float fConst2225;
	float fConst2226;
	float fRec404[3];
	float fConst2227;
	float fRec403[2];
	FAUSTFLOAT fVbargraph58;
	float fConst2228;
	float fConst2229;
	float fConst2230;
	float fConst2231;
	float fConst2232;
	float fConst2233;
	float fConst2234;
	float fConst2235;
	float fConst2236;
	float fConst2237;
	float fConst2238;
	float fConst2239;
	float fConst2240;
	float fConst2241;
	float fConst2242;
	float fConst2243;
	float fConst2244;
	float fConst2245;
	float fConst2246;
	float fConst2247;
	float fConst2248;
	float fRec416[3];
	float fConst2249;
	float fConst2250;
	float fConst2251;
	float fRec415[3];
	float fConst2252;
	float fConst2253;
	float fConst2254;
	float fRec414[3];
	float fConst2255;
	float fConst2256;
	float fConst2257;
	float fConst2258;
	float fRec413[3];
	float fConst2259;
	float fConst2260;
	float fConst2261;
	float fRec412[3];
	float fConst2262;
	float fConst2263;
	float fConst2264;
	float fRec411[3];
	float fConst2265;
	float fRec410[2];
	FAUSTFLOAT fVbargraph59;
	float fConst2266;
	float fConst2267;
	float fConst2268;
	float fConst2269;
	float fConst2270;
	float fConst2271;
	float fConst2272;
	float fConst2273;
	float fConst2274;
	float fConst2275;
	float fConst2276;
	float fConst2277;
	float fConst2278;
	float fConst2279;
	float fConst2280;
	float fConst2281;
	float fConst2282;
	float fConst2283;
	float fConst2284;
	float fConst2285;
	float fConst2286;
	float fRec423[3];
	float fConst2287;
	float fConst2288;
	float fConst2289;
	float fRec422[3];
	float fConst2290;
	float fConst2291;
	float fConst2292;
	float fRec421[3];
	float fConst2293;
	float fConst2294;
	float fConst2295;
	float fConst2296;
	float fRec420[3];
	float fConst2297;
	float fConst2298;
	float fConst2299;
	float fRec419[3];
	float fConst2300;
	float fConst2301;
	float fConst2302;
	float fRec418[3];
	float fConst2303;
	float fRec417[2];
	FAUSTFLOAT fVbargraph60;
	float fConst2304;
	float fConst2305;
	float fConst2306;
	float fConst2307;
	float fConst2308;
	float fConst2309;
	float fConst2310;
	float fConst2311;
	float fConst2312;
	float fConst2313;
	float fConst2314;
	float fConst2315;
	float fConst2316;
	float fConst2317;
	float fConst2318;
	float fConst2319;
	float fConst2320;
	float fConst2321;
	float fConst2322;
	float fConst2323;
	float fConst2324;
	float fRec430[3];
	float fConst2325;
	float fConst2326;
	float fConst2327;
	float fRec429[3];
	float fConst2328;
	float fConst2329;
	float fConst2330;
	float fRec428[3];
	float fConst2331;
	float fConst2332;
	float fConst2333;
	float fConst2334;
	float fRec427[3];
	float fConst2335;
	float fConst2336;
	float fConst2337;
	float fRec426[3];
	float fConst2338;
	float fConst2339;
	float fConst2340;
	float fRec425[3];
	float fConst2341;
	float fRec424[2];
	FAUSTFLOAT fVbargraph61;
	float fConst2342;
	float fConst2343;
	float fConst2344;
	float fConst2345;
	float fConst2346;
	float fConst2347;
	float fConst2348;
	float fConst2349;
	float fConst2350;
	float fConst2351;
	float fConst2352;
	float fConst2353;
	float fConst2354;
	float fConst2355;
	float fConst2356;
	float fConst2357;
	float fConst2358;
	float fConst2359;
	float fConst2360;
	float fConst2361;
	float fConst2362;
	float fRec437[3];
	float fConst2363;
	float fConst2364;
	float fConst2365;
	float fRec436[3];
	float fConst2366;
	float fConst2367;
	float fConst2368;
	float fRec435[3];
	float fConst2369;
	float fConst2370;
	float fConst2371;
	float fConst2372;
	float fRec434[3];
	float fConst2373;
	float fConst2374;
	float fConst2375;
	float fRec433[3];
	float fConst2376;
	float fConst2377;
	float fConst2378;
	float fRec432[3];
	float fConst2379;
	float fRec431[2];
	FAUSTFLOAT fVbargraph62;
	float fConst2380;
	float fConst2381;
	float fConst2382;
	float fConst2383;
	float fConst2384;
	float fConst2385;
	float fConst2386;
	float fConst2387;
	float fConst2388;
	float fConst2389;
	float fConst2390;
	float fConst2391;
	float fConst2392;
	float fConst2393;
	float fConst2394;
	float fConst2395;
	float fConst2396;
	float fConst2397;
	float fConst2398;
	float fConst2399;
	float fConst2400;
	float fRec444[3];
	float fConst2401;
	float fConst2402;
	float fConst2403;
	float fRec443[3];
	float fConst2404;
	float fConst2405;
	float fConst2406;
	float fRec442[3];
	float fConst2407;
	float fConst2408;
	float fConst2409;
	float fConst2410;
	float fRec441[3];
	float fConst2411;
	float fConst2412;
	float fConst2413;
	float fRec440[3];
	float fConst2414;
	float fConst2415;
	float fConst2416;
	float fRec439[3];
	float fConst2417;
	float fRec438[2];
	FAUSTFLOAT fVbargraph63;
	float fConst2418;
	float fConst2419;
	float fConst2420;
	float fConst2421;
	float fConst2422;
	float fConst2423;
	float fConst2424;
	float fConst2425;
	float fConst2426;
	float fConst2427;
	float fConst2428;
	float fConst2429;
	float fConst2430;
	float fConst2431;
	float fConst2432;
	float fConst2433;
	float fConst2434;
	float fConst2435;
	float fConst2436;
	float fConst2437;
	float fConst2438;
	float fRec451[3];
	float fConst2439;
	float fConst2440;
	float fConst2441;
	float fRec450[3];
	float fConst2442;
	float fConst2443;
	float fConst2444;
	float fRec449[3];
	float fConst2445;
	float fConst2446;
	float fConst2447;
	float fConst2448;
	float fRec448[3];
	float fConst2449;
	float fConst2450;
	float fConst2451;
	float fRec447[3];
	float fConst2452;
	float fConst2453;
	float fConst2454;
	float fRec446[3];
	float fConst2455;
	float fRec445[2];
	FAUSTFLOAT fVbargraph64;
	float fConst2456;
	float fConst2457;
	float fConst2458;
	float fConst2459;
	float fConst2460;
	float fConst2461;
	float fConst2462;
	float fConst2463;
	float fConst2464;
	float fConst2465;
	float fConst2466;
	float fConst2467;
	float fConst2468;
	float fConst2469;
	float fConst2470;
	float fConst2471;
	float fConst2472;
	float fConst2473;
	float fConst2474;
	float fConst2475;
	float fConst2476;
	float fRec458[3];
	float fConst2477;
	float fConst2478;
	float fConst2479;
	float fRec457[3];
	float fConst2480;
	float fConst2481;
	float fConst2482;
	float fRec456[3];
	float fConst2483;
	float fConst2484;
	float fConst2485;
	float fConst2486;
	float fRec455[3];
	float fConst2487;
	float fConst2488;
	float fConst2489;
	float fRec454[3];
	float fConst2490;
	float fConst2491;
	float fConst2492;
	float fRec453[3];
	float fConst2493;
	float fRec452[2];
	FAUSTFLOAT fVbargraph65;
	float fConst2494;
	float fConst2495;
	float fConst2496;
	float fConst2497;
	float fConst2498;
	float fConst2499;
	float fConst2500;
	float fConst2501;
	float fConst2502;
	float fConst2503;
	float fConst2504;
	float fConst2505;
	float fConst2506;
	float fConst2507;
	float fConst2508;
	float fConst2509;
	float fConst2510;
	float fConst2511;
	float fConst2512;
	float fConst2513;
	float fConst2514;
	float fRec465[3];
	float fConst2515;
	float fConst2516;
	float fConst2517;
	float fRec464[3];
	float fConst2518;
	float fConst2519;
	float fConst2520;
	float fRec463[3];
	float fConst2521;
	float fConst2522;
	float fConst2523;
	float fConst2524;
	float fRec462[3];
	float fConst2525;
	float fConst2526;
	float fConst2527;
	float fRec461[3];
	float fConst2528;
	float fConst2529;
	float fConst2530;
	float fRec460[3];
	float fConst2531;
	float fRec459[2];
	FAUSTFLOAT fVbargraph66;
	float fConst2532;
	float fConst2533;
	float fConst2534;
	float fConst2535;
	float fConst2536;
	float fConst2537;
	float fConst2538;
	float fConst2539;
	float fConst2540;
	float fConst2541;
	float fConst2542;
	float fConst2543;
	float fConst2544;
	float fConst2545;
	float fConst2546;
	float fConst2547;
	float fConst2548;
	float fConst2549;
	float fConst2550;
	float fConst2551;
	float fConst2552;
	float fRec472[3];
	float fConst2553;
	float fConst2554;
	float fConst2555;
	float fRec471[3];
	float fConst2556;
	float fConst2557;
	float fConst2558;
	float fRec470[3];
	float fConst2559;
	float fConst2560;
	float fConst2561;
	float fConst2562;
	float fRec469[3];
	float fConst2563;
	float fConst2564;
	float fConst2565;
	float fRec468[3];
	float fConst2566;
	float fConst2567;
	float fConst2568;
	float fRec467[3];
	float fConst2569;
	float fRec466[2];
	FAUSTFLOAT fVbargraph67;
	float fConst2570;
	float fConst2571;
	float fConst2572;
	float fConst2573;
	float fConst2574;
	float fConst2575;
	float fConst2576;
	float fConst2577;
	float fConst2578;
	float fConst2579;
	float fConst2580;
	float fConst2581;
	float fConst2582;
	float fConst2583;
	float fConst2584;
	float fConst2585;
	float fConst2586;
	float fConst2587;
	float fConst2588;
	float fConst2589;
	float fConst2590;
	float fRec479[3];
	float fConst2591;
	float fConst2592;
	float fConst2593;
	float fRec478[3];
	float fConst2594;
	float fConst2595;
	float fConst2596;
	float fRec477[3];
	float fConst2597;
	float fConst2598;
	float fConst2599;
	float fConst2600;
	float fRec476[3];
	float fConst2601;
	float fConst2602;
	float fConst2603;
	float fRec475[3];
	float fConst2604;
	float fConst2605;
	float fConst2606;
	float fRec474[3];
	float fConst2607;
	float fRec473[2];
	FAUSTFLOAT fVbargraph68;
	float fConst2608;
	float fConst2609;
	float fConst2610;
	float fConst2611;
	float fConst2612;
	float fConst2613;
	float fConst2614;
	float fConst2615;
	float fConst2616;
	float fConst2617;
	float fConst2618;
	float fConst2619;
	float fConst2620;
	float fConst2621;
	float fConst2622;
	float fConst2623;
	float fConst2624;
	float fConst2625;
	float fConst2626;
	float fConst2627;
	float fConst2628;
	float fRec486[3];
	float fConst2629;
	float fConst2630;
	float fConst2631;
	float fRec485[3];
	float fConst2632;
	float fConst2633;
	float fConst2634;
	float fRec484[3];
	float fConst2635;
	float fConst2636;
	float fConst2637;
	float fConst2638;
	float fRec483[3];
	float fConst2639;
	float fConst2640;
	float fConst2641;
	float fRec482[3];
	float fConst2642;
	float fConst2643;
	float fConst2644;
	float fRec481[3];
	float fConst2645;
	float fRec480[2];
	FAUSTFLOAT fVbargraph69;
	float fConst2646;
	float fConst2647;
	float fConst2648;
	float fConst2649;
	float fConst2650;
	float fConst2651;
	float fConst2652;
	float fConst2653;
	float fConst2654;
	float fConst2655;
	float fConst2656;
	float fConst2657;
	float fConst2658;
	float fConst2659;
	float fConst2660;
	float fConst2661;
	float fConst2662;
	float fConst2663;
	float fConst2664;
	float fConst2665;
	float fConst2666;
	float fRec493[3];
	float fConst2667;
	float fConst2668;
	float fConst2669;
	float fRec492[3];
	float fConst2670;
	float fConst2671;
	float fConst2672;
	float fRec491[3];
	float fConst2673;
	float fConst2674;
	float fConst2675;
	float fConst2676;
	float fRec490[3];
	float fConst2677;
	float fConst2678;
	float fConst2679;
	float fRec489[3];
	float fConst2680;
	float fConst2681;
	float fConst2682;
	float fRec488[3];
	float fConst2683;
	float fRec487[2];
	FAUSTFLOAT fVbargraph70;
	float fConst2684;
	float fConst2685;
	float fConst2686;
	float fConst2687;
	float fConst2688;
	float fConst2689;
	float fConst2690;
	float fConst2691;
	float fConst2692;
	float fConst2693;
	float fConst2694;
	float fConst2695;
	float fConst2696;
	float fConst2697;
	float fConst2698;
	float fConst2699;
	float fConst2700;
	float fConst2701;
	float fConst2702;
	float fConst2703;
	float fConst2704;
	float fRec500[3];
	float fConst2705;
	float fConst2706;
	float fConst2707;
	float fRec499[3];
	float fConst2708;
	float fConst2709;
	float fConst2710;
	float fRec498[3];
	float fConst2711;
	float fConst2712;
	float fConst2713;
	float fConst2714;
	float fRec497[3];
	float fConst2715;
	float fConst2716;
	float fConst2717;
	float fRec496[3];
	float fConst2718;
	float fConst2719;
	float fConst2720;
	float fRec495[3];
	float fConst2721;
	float fRec494[2];
	FAUSTFLOAT fVbargraph71;
	float fConst2722;
	float fConst2723;
	float fConst2724;
	float fConst2725;
	float fConst2726;
	float fConst2727;
	float fConst2728;
	float fConst2729;
	float fConst2730;
	float fConst2731;
	float fConst2732;
	float fConst2733;
	float fConst2734;
	float fConst2735;
	float fConst2736;
	float fConst2737;
	float fConst2738;
	float fConst2739;
	float fConst2740;
	float fConst2741;
	float fConst2742;
	float fRec507[3];
	float fConst2743;
	float fConst2744;
	float fConst2745;
	float fRec506[3];
	float fConst2746;
	float fConst2747;
	float fConst2748;
	float fRec505[3];
	float fConst2749;
	float fConst2750;
	float fConst2751;
	float fConst2752;
	float fRec504[3];
	float fConst2753;
	float fConst2754;
	float fConst2755;
	float fRec503[3];
	float fConst2756;
	float fConst2757;
	float fConst2758;
	float fRec502[3];
	float fConst2759;
	float fRec501[2];
	FAUSTFLOAT fVbargraph72;
	float fConst2760;
	float fConst2761;
	float fConst2762;
	float fConst2763;
	float fConst2764;
	float fConst2765;
	float fConst2766;
	float fConst2767;
	float fConst2768;
	float fConst2769;
	float fConst2770;
	float fConst2771;
	float fConst2772;
	float fConst2773;
	float fConst2774;
	float fConst2775;
	float fConst2776;
	float fConst2777;
	float fConst2778;
	float fConst2779;
	float fConst2780;
	float fRec514[3];
	float fConst2781;
	float fConst2782;
	float fConst2783;
	float fRec513[3];
	float fConst2784;
	float fConst2785;
	float fConst2786;
	float fRec512[3];
	float fConst2787;
	float fConst2788;
	float fConst2789;
	float fConst2790;
	float fRec511[3];
	float fConst2791;
	float fConst2792;
	float fConst2793;
	float fRec510[3];
	float fConst2794;
	float fConst2795;
	float fConst2796;
	float fRec509[3];
	float fConst2797;
	float fRec508[2];
	FAUSTFLOAT fVbargraph73;
	float fConst2798;
	float fConst2799;
	float fConst2800;
	float fConst2801;
	float fConst2802;
	float fConst2803;
	float fConst2804;
	float fConst2805;
	float fConst2806;
	float fConst2807;
	float fConst2808;
	float fConst2809;
	float fConst2810;
	float fConst2811;
	float fConst2812;
	float fConst2813;
	float fConst2814;
	float fConst2815;
	float fConst2816;
	float fConst2817;
	float fConst2818;
	float fRec521[3];
	float fConst2819;
	float fConst2820;
	float fConst2821;
	float fRec520[3];
	float fConst2822;
	float fConst2823;
	float fConst2824;
	float fRec519[3];
	float fConst2825;
	float fConst2826;
	float fConst2827;
	float fConst2828;
	float fRec518[3];
	float fConst2829;
	float fConst2830;
	float fConst2831;
	float fRec517[3];
	float fConst2832;
	float fConst2833;
	float fConst2834;
	float fRec516[3];
	float fConst2835;
	float fRec515[2];
	FAUSTFLOAT fVbargraph74;
	float fConst2836;
	float fConst2837;
	float fConst2838;
	float fConst2839;
	float fConst2840;
	float fConst2841;
	float fConst2842;
	float fConst2843;
	float fConst2844;
	float fConst2845;
	float fConst2846;
	float fConst2847;
	float fConst2848;
	float fConst2849;
	float fConst2850;
	float fConst2851;
	float fConst2852;
	float fConst2853;
	float fConst2854;
	float fConst2855;
	float fConst2856;
	float fRec528[3];
	float fConst2857;
	float fConst2858;
	float fConst2859;
	float fRec527[3];
	float fConst2860;
	float fConst2861;
	float fConst2862;
	float fRec526[3];
	float fConst2863;
	float fConst2864;
	float fConst2865;
	float fConst2866;
	float fRec525[3];
	float fConst2867;
	float fConst2868;
	float fConst2869;
	float fRec524[3];
	float fConst2870;
	float fConst2871;
	float fConst2872;
	float fRec523[3];
	float fConst2873;
	float fRec522[2];
	FAUSTFLOAT fVbargraph75;
	float fConst2874;
	float fConst2875;
	float fConst2876;
	float fConst2877;
	float fConst2878;
	float fConst2879;
	float fConst2880;
	float fConst2881;
	float fConst2882;
	float fConst2883;
	float fConst2884;
	float fConst2885;
	float fConst2886;
	float fConst2887;
	float fConst2888;
	float fConst2889;
	float fConst2890;
	float fConst2891;
	float fConst2892;
	float fConst2893;
	float fConst2894;
	float fRec535[3];
	float fConst2895;
	float fConst2896;
	float fConst2897;
	float fRec534[3];
	float fConst2898;
	float fConst2899;
	float fConst2900;
	float fRec533[3];
	float fConst2901;
	float fConst2902;
	float fConst2903;
	float fConst2904;
	float fRec532[3];
	float fConst2905;
	float fConst2906;
	float fConst2907;
	float fRec531[3];
	float fConst2908;
	float fConst2909;
	float fConst2910;
	float fRec530[3];
	float fConst2911;
	float fRec529[2];
	FAUSTFLOAT fVbargraph76;
	float fConst2912;
	float fConst2913;
	float fConst2914;
	float fConst2915;
	float fConst2916;
	float fConst2917;
	float fConst2918;
	float fConst2919;
	float fConst2920;
	float fConst2921;
	float fConst2922;
	float fConst2923;
	float fConst2924;
	float fConst2925;
	float fConst2926;
	float fConst2927;
	float fConst2928;
	float fConst2929;
	float fConst2930;
	float fConst2931;
	float fConst2932;
	float fRec542[3];
	float fConst2933;
	float fConst2934;
	float fConst2935;
	float fRec541[3];
	float fConst2936;
	float fConst2937;
	float fConst2938;
	float fRec540[3];
	float fConst2939;
	float fConst2940;
	float fConst2941;
	float fConst2942;
	float fRec539[3];
	float fConst2943;
	float fConst2944;
	float fConst2945;
	float fRec538[3];
	float fConst2946;
	float fConst2947;
	float fConst2948;
	float fRec537[3];
	float fConst2949;
	float fRec536[2];
	FAUSTFLOAT fVbargraph77;
	float fConst2950;
	float fConst2951;
	float fConst2952;
	float fConst2953;
	float fConst2954;
	float fConst2955;
	float fConst2956;
	float fConst2957;
	float fConst2958;
	float fConst2959;
	float fConst2960;
	float fConst2961;
	float fConst2962;
	float fConst2963;
	float fConst2964;
	float fConst2965;
	float fConst2966;
	float fConst2967;
	float fConst2968;
	float fConst2969;
	float fConst2970;
	float fRec549[3];
	float fConst2971;
	float fConst2972;
	float fConst2973;
	float fRec548[3];
	float fConst2974;
	float fConst2975;
	float fConst2976;
	float fRec547[3];
	float fConst2977;
	float fConst2978;
	float fConst2979;
	float fConst2980;
	float fRec546[3];
	float fConst2981;
	float fConst2982;
	float fConst2983;
	float fRec545[3];
	float fConst2984;
	float fConst2985;
	float fConst2986;
	float fRec544[3];
	float fConst2987;
	float fRec543[2];
	FAUSTFLOAT fVbargraph78;
	float fConst2988;
	float fConst2989;
	float fConst2990;
	float fConst2991;
	float fConst2992;
	float fConst2993;
	float fConst2994;
	float fConst2995;
	float fConst2996;
	float fConst2997;
	float fConst2998;
	float fConst2999;
	float fConst3000;
	float fConst3001;
	float fConst3002;
	float fConst3003;
	float fConst3004;
	float fConst3005;
	float fConst3006;
	float fConst3007;
	float fConst3008;
	float fRec556[3];
	float fConst3009;
	float fConst3010;
	float fConst3011;
	float fRec555[3];
	float fConst3012;
	float fConst3013;
	float fConst3014;
	float fRec554[3];
	float fConst3015;
	float fConst3016;
	float fConst3017;
	float fConst3018;
	float fRec553[3];
	float fConst3019;
	float fConst3020;
	float fConst3021;
	float fRec552[3];
	float fConst3022;
	float fConst3023;
	float fConst3024;
	float fRec551[3];
	float fConst3025;
	float fRec550[2];
	FAUSTFLOAT fVbargraph79;
	float fConst3026;
	float fConst3027;
	float fConst3028;
	float fConst3029;
	float fConst3030;
	float fConst3031;
	float fConst3032;
	float fConst3033;
	float fConst3034;
	float fConst3035;
	float fConst3036;
	float fConst3037;
	float fConst3038;
	float fConst3039;
	float fConst3040;
	float fConst3041;
	float fConst3042;
	float fConst3043;
	float fConst3044;
	float fConst3045;
	float fConst3046;
	float fRec563[3];
	float fConst3047;
	float fConst3048;
	float fConst3049;
	float fRec562[3];
	float fConst3050;
	float fConst3051;
	float fConst3052;
	float fRec561[3];
	float fConst3053;
	float fConst3054;
	float fConst3055;
	float fConst3056;
	float fRec560[3];
	float fConst3057;
	float fConst3058;
	float fConst3059;
	float fRec559[3];
	float fConst3060;
	float fConst3061;
	float fConst3062;
	float fRec558[3];
	float fConst3063;
	float fRec557[2];
	FAUSTFLOAT fVbargraph80;
	float fConst3064;
	float fConst3065;
	float fConst3066;
	float fConst3067;
	float fConst3068;
	float fConst3069;
	float fConst3070;
	float fConst3071;
	float fConst3072;
	float fConst3073;
	float fConst3074;
	float fConst3075;
	float fConst3076;
	float fConst3077;
	float fConst3078;
	float fConst3079;
	float fConst3080;
	float fConst3081;
	float fConst3082;
	float fConst3083;
	float fConst3084;
	float fRec570[3];
	float fConst3085;
	float fConst3086;
	float fConst3087;
	float fRec569[3];
	float fConst3088;
	float fConst3089;
	float fConst3090;
	float fRec568[3];
	float fConst3091;
	float fConst3092;
	float fConst3093;
	float fConst3094;
	float fRec567[3];
	float fConst3095;
	float fConst3096;
	float fConst3097;
	float fRec566[3];
	float fConst3098;
	float fConst3099;
	float fConst3100;
	float fRec565[3];
	float fConst3101;
	float fRec564[2];
	FAUSTFLOAT fVbargraph81;
	float fConst3102;
	float fConst3103;
	float fConst3104;
	float fConst3105;
	float fConst3106;
	float fConst3107;
	float fConst3108;
	float fConst3109;
	float fConst3110;
	float fConst3111;
	float fConst3112;
	float fConst3113;
	float fConst3114;
	float fConst3115;
	float fConst3116;
	float fConst3117;
	float fConst3118;
	float fConst3119;
	float fConst3120;
	float fConst3121;
	float fConst3122;
	float fRec577[3];
	float fConst3123;
	float fConst3124;
	float fConst3125;
	float fRec576[3];
	float fConst3126;
	float fConst3127;
	float fConst3128;
	float fRec575[3];
	float fConst3129;
	float fConst3130;
	float fConst3131;
	float fConst3132;
	float fRec574[3];
	float fConst3133;
	float fConst3134;
	float fConst3135;
	float fRec573[3];
	float fConst3136;
	float fConst3137;
	float fConst3138;
	float fRec572[3];
	float fConst3139;
	float fRec571[2];
	FAUSTFLOAT fVbargraph82;
	float fConst3140;
	float fConst3141;
	float fConst3142;
	float fConst3143;
	float fConst3144;
	float fConst3145;
	float fConst3146;
	float fConst3147;
	float fConst3148;
	float fConst3149;
	float fConst3150;
	float fConst3151;
	float fConst3152;
	float fConst3153;
	float fConst3154;
	float fConst3155;
	float fConst3156;
	float fConst3157;
	float fConst3158;
	float fConst3159;
	float fConst3160;
	float fRec584[3];
	float fConst3161;
	float fConst3162;
	float fConst3163;
	float fRec583[3];
	float fConst3164;
	float fConst3165;
	float fConst3166;
	float fRec582[3];
	float fConst3167;
	float fConst3168;
	float fConst3169;
	float fConst3170;
	float fRec581[3];
	float fConst3171;
	float fConst3172;
	float fConst3173;
	float fRec580[3];
	float fConst3174;
	float fConst3175;
	float fConst3176;
	float fRec579[3];
	float fConst3177;
	float fRec578[2];
	FAUSTFLOAT fVbargraph83;
	float fConst3178;
	float fConst3179;
	float fConst3180;
	float fConst3181;
	float fConst3182;
	float fConst3183;
	float fConst3184;
	float fConst3185;
	float fConst3186;
	float fConst3187;
	float fConst3188;
	float fConst3189;
	float fConst3190;
	float fConst3191;
	float fConst3192;
	float fConst3193;
	float fConst3194;
	float fConst3195;
	float fConst3196;
	float fConst3197;
	float fConst3198;
	float fRec591[3];
	float fConst3199;
	float fConst3200;
	float fConst3201;
	float fRec590[3];
	float fConst3202;
	float fConst3203;
	float fConst3204;
	float fRec589[3];
	float fConst3205;
	float fConst3206;
	float fConst3207;
	float fConst3208;
	float fRec588[3];
	float fConst3209;
	float fConst3210;
	float fConst3211;
	float fRec587[3];
	float fConst3212;
	float fConst3213;
	float fConst3214;
	float fRec586[3];
	float fConst3215;
	float fRec585[2];
	FAUSTFLOAT fVbargraph84;
	float fConst3216;
	float fConst3217;
	float fConst3218;
	float fConst3219;
	float fConst3220;
	float fConst3221;
	float fConst3222;
	float fConst3223;
	float fConst3224;
	float fConst3225;
	float fConst3226;
	float fConst3227;
	float fConst3228;
	float fConst3229;
	float fConst3230;
	float fConst3231;
	float fConst3232;
	float fConst3233;
	float fConst3234;
	float fConst3235;
	float fConst3236;
	float fRec598[3];
	float fConst3237;
	float fConst3238;
	float fConst3239;
	float fRec597[3];
	float fConst3240;
	float fConst3241;
	float fConst3242;
	float fRec596[3];
	float fConst3243;
	float fConst3244;
	float fConst3245;
	float fConst3246;
	float fRec595[3];
	float fConst3247;
	float fConst3248;
	float fConst3249;
	float fRec594[3];
	float fConst3250;
	float fConst3251;
	float fConst3252;
	float fRec593[3];
	float fConst3253;
	float fRec592[2];
	FAUSTFLOAT fVbargraph85;
	float fConst3254;
	float fConst3255;
	float fConst3256;
	float fConst3257;
	float fConst3258;
	float fConst3259;
	float fConst3260;
	float fConst3261;
	float fConst3262;
	float fConst3263;
	float fConst3264;
	float fConst3265;
	float fConst3266;
	float fConst3267;
	float fConst3268;
	float fConst3269;
	float fConst3270;
	float fConst3271;
	float fConst3272;
	float fConst3273;
	float fConst3274;
	float fRec605[3];
	float fConst3275;
	float fConst3276;
	float fConst3277;
	float fRec604[3];
	float fConst3278;
	float fConst3279;
	float fConst3280;
	float fRec603[3];
	float fConst3281;
	float fConst3282;
	float fConst3283;
	float fConst3284;
	float fRec602[3];
	float fConst3285;
	float fConst3286;
	float fConst3287;
	float fRec601[3];
	float fConst3288;
	float fConst3289;
	float fConst3290;
	float fRec600[3];
	float fConst3291;
	float fRec599[2];
	FAUSTFLOAT fVbargraph86;
	float fConst3292;
	float fConst3293;
	float fConst3294;
	float fConst3295;
	float fConst3296;
	float fConst3297;
	float fConst3298;
	float fConst3299;
	float fConst3300;
	float fConst3301;
	float fConst3302;
	float fConst3303;
	float fConst3304;
	float fConst3305;
	float fConst3306;
	float fConst3307;
	float fConst3308;
	float fConst3309;
	float fConst3310;
	float fConst3311;
	float fConst3312;
	float fRec612[3];
	float fConst3313;
	float fConst3314;
	float fConst3315;
	float fRec611[3];
	float fConst3316;
	float fConst3317;
	float fConst3318;
	float fRec610[3];
	float fConst3319;
	float fConst3320;
	float fConst3321;
	float fConst3322;
	float fRec609[3];
	float fConst3323;
	float fConst3324;
	float fConst3325;
	float fRec608[3];
	float fConst3326;
	float fConst3327;
	float fConst3328;
	float fRec607[3];
	float fConst3329;
	float fRec606[2];
	FAUSTFLOAT fVbargraph87;
	float fConst3330;
	float fConst3331;
	float fConst3332;
	float fConst3333;
	float fConst3334;
	float fConst3335;
	float fConst3336;
	float fConst3337;
	float fConst3338;
	float fConst3339;
	float fConst3340;
	float fConst3341;
	float fConst3342;
	float fConst3343;
	float fConst3344;
	float fConst3345;
	float fConst3346;
	float fConst3347;
	float fConst3348;
	float fConst3349;
	float fConst3350;
	float fRec619[3];
	float fConst3351;
	float fConst3352;
	float fConst3353;
	float fRec618[3];
	float fConst3354;
	float fConst3355;
	float fConst3356;
	float fRec617[3];
	float fConst3357;
	float fConst3358;
	float fConst3359;
	float fConst3360;
	float fRec616[3];
	float fConst3361;
	float fConst3362;
	float fConst3363;
	float fRec615[3];
	float fConst3364;
	float fConst3365;
	float fConst3366;
	float fRec614[3];
	float fConst3367;
	float fRec613[2];
	FAUSTFLOAT fVbargraph88;
	float fConst3368;
	float fConst3369;
	float fConst3370;
	float fConst3371;
	float fConst3372;
	float fConst3373;
	float fConst3374;
	float fConst3375;
	float fConst3376;
	float fConst3377;
	float fConst3378;
	float fConst3379;
	float fConst3380;
	float fConst3381;
	float fConst3382;
	float fConst3383;
	float fConst3384;
	float fConst3385;
	float fConst3386;
	float fConst3387;
	float fConst3388;
	float fRec626[3];
	float fConst3389;
	float fConst3390;
	float fConst3391;
	float fRec625[3];
	float fConst3392;
	float fConst3393;
	float fConst3394;
	float fRec624[3];
	float fConst3395;
	float fConst3396;
	float fConst3397;
	float fConst3398;
	float fRec623[3];
	float fConst3399;
	float fConst3400;
	float fConst3401;
	float fRec622[3];
	float fConst3402;
	float fConst3403;
	float fConst3404;
	float fRec621[3];
	float fConst3405;
	float fRec620[2];
	FAUSTFLOAT fVbargraph89;
	float fConst3406;
	float fConst3407;
	float fConst3408;
	float fConst3409;
	float fConst3410;
	float fConst3411;
	float fConst3412;
	float fConst3413;
	float fConst3414;
	float fConst3415;
	float fConst3416;
	float fConst3417;
	float fConst3418;
	float fConst3419;
	float fConst3420;
	float fConst3421;
	float fConst3422;
	float fConst3423;
	float fConst3424;
	float fConst3425;
	float fConst3426;
	float fRec633[3];
	float fConst3427;
	float fConst3428;
	float fConst3429;
	float fRec632[3];
	float fConst3430;
	float fConst3431;
	float fConst3432;
	float fRec631[3];
	float fConst3433;
	float fConst3434;
	float fConst3435;
	float fConst3436;
	float fRec630[3];
	float fConst3437;
	float fConst3438;
	float fConst3439;
	float fRec629[3];
	float fConst3440;
	float fConst3441;
	float fConst3442;
	float fRec628[3];
	float fConst3443;
	float fRec627[2];
	FAUSTFLOAT fVbargraph90;
	float fConst3444;
	float fConst3445;
	float fConst3446;
	float fConst3447;
	float fConst3448;
	float fConst3449;
	float fConst3450;
	float fConst3451;
	float fConst3452;
	float fConst3453;
	float fConst3454;
	float fConst3455;
	float fConst3456;
	float fConst3457;
	float fConst3458;
	float fConst3459;
	float fConst3460;
	float fConst3461;
	float fConst3462;
	float fConst3463;
	float fConst3464;
	float fRec640[3];
	float fConst3465;
	float fConst3466;
	float fConst3467;
	float fRec639[3];
	float fConst3468;
	float fConst3469;
	float fConst3470;
	float fRec638[3];
	float fConst3471;
	float fConst3472;
	float fConst3473;
	float fConst3474;
	float fRec637[3];
	float fConst3475;
	float fConst3476;
	float fConst3477;
	float fRec636[3];
	float fConst3478;
	float fConst3479;
	float fConst3480;
	float fRec635[3];
	float fConst3481;
	float fRec634[2];
	FAUSTFLOAT fVbargraph91;
	float fConst3482;
	float fConst3483;
	float fConst3484;
	float fConst3485;
	float fConst3486;
	float fConst3487;
	float fConst3488;
	float fConst3489;
	float fConst3490;
	float fConst3491;
	float fConst3492;
	float fConst3493;
	float fConst3494;
	float fConst3495;
	float fConst3496;
	float fConst3497;
	float fConst3498;
	float fConst3499;
	float fConst3500;
	float fConst3501;
	float fConst3502;
	float fRec647[3];
	float fConst3503;
	float fConst3504;
	float fConst3505;
	float fRec646[3];
	float fConst3506;
	float fConst3507;
	float fConst3508;
	float fRec645[3];
	float fConst3509;
	float fConst3510;
	float fConst3511;
	float fConst3512;
	float fRec644[3];
	float fConst3513;
	float fConst3514;
	float fConst3515;
	float fRec643[3];
	float fConst3516;
	float fConst3517;
	float fConst3518;
	float fRec642[3];
	float fConst3519;
	float fRec641[2];
	FAUSTFLOAT fVbargraph92;
	float fConst3520;
	float fConst3521;
	float fConst3522;
	float fConst3523;
	float fConst3524;
	float fConst3525;
	float fConst3526;
	float fConst3527;
	float fConst3528;
	float fConst3529;
	float fConst3530;
	float fConst3531;
	float fConst3532;
	float fConst3533;
	float fConst3534;
	float fConst3535;
	float fConst3536;
	float fConst3537;
	float fConst3538;
	float fConst3539;
	float fConst3540;
	float fRec654[3];
	float fConst3541;
	float fConst3542;
	float fConst3543;
	float fRec653[3];
	float fConst3544;
	float fConst3545;
	float fConst3546;
	float fRec652[3];
	float fConst3547;
	float fConst3548;
	float fConst3549;
	float fConst3550;
	float fRec651[3];
	float fConst3551;
	float fConst3552;
	float fConst3553;
	float fRec650[3];
	float fConst3554;
	float fConst3555;
	float fConst3556;
	float fRec649[3];
	float fConst3557;
	float fRec648[2];
	FAUSTFLOAT fVbargraph93;
	float fConst3558;
	float fConst3559;
	float fConst3560;
	float fConst3561;
	float fConst3562;
	float fConst3563;
	float fConst3564;
	float fConst3565;
	float fConst3566;
	float fConst3567;
	float fConst3568;
	float fConst3569;
	float fConst3570;
	float fConst3571;
	float fConst3572;
	float fConst3573;
	float fConst3574;
	float fConst3575;
	float fConst3576;
	float fConst3577;
	float fConst3578;
	float fRec661[3];
	float fConst3579;
	float fConst3580;
	float fConst3581;
	float fRec660[3];
	float fConst3582;
	float fConst3583;
	float fConst3584;
	float fRec659[3];
	float fConst3585;
	float fConst3586;
	float fConst3587;
	float fConst3588;
	float fRec658[3];
	float fConst3589;
	float fConst3590;
	float fConst3591;
	float fRec657[3];
	float fConst3592;
	float fConst3593;
	float fConst3594;
	float fRec656[3];
	float fConst3595;
	float fRec655[2];
	FAUSTFLOAT fVbargraph94;
	float fConst3596;
	float fConst3597;
	float fConst3598;
	float fConst3599;
	float fConst3600;
	float fConst3601;
	float fConst3602;
	float fConst3603;
	float fConst3604;
	float fConst3605;
	float fConst3606;
	float fConst3607;
	float fConst3608;
	float fConst3609;
	float fConst3610;
	float fConst3611;
	float fConst3612;
	float fConst3613;
	float fConst3614;
	float fConst3615;
	float fConst3616;
	float fRec668[3];
	float fConst3617;
	float fConst3618;
	float fConst3619;
	float fRec667[3];
	float fConst3620;
	float fConst3621;
	float fConst3622;
	float fRec666[3];
	float fConst3623;
	float fConst3624;
	float fConst3625;
	float fConst3626;
	float fRec665[3];
	float fConst3627;
	float fConst3628;
	float fConst3629;
	float fRec664[3];
	float fConst3630;
	float fConst3631;
	float fConst3632;
	float fRec663[3];
	float fConst3633;
	float fRec662[2];
	FAUSTFLOAT fVbargraph95;
	float fConst3634;
	float fConst3635;
	float fConst3636;
	float fConst3637;
	float fConst3638;
	float fConst3639;
	float fConst3640;
	float fConst3641;
	float fConst3642;
	float fConst3643;
	float fConst3644;
	float fConst3645;
	float fConst3646;
	float fConst3647;
	float fConst3648;
	float fConst3649;
	float fConst3650;
	float fConst3651;
	float fConst3652;
	float fConst3653;
	float fConst3654;
	float fRec675[3];
	float fConst3655;
	float fConst3656;
	float fConst3657;
	float fRec674[3];
	float fConst3658;
	float fConst3659;
	float fConst3660;
	float fRec673[3];
	float fConst3661;
	float fConst3662;
	float fConst3663;
	float fConst3664;
	float fRec672[3];
	float fConst3665;
	float fConst3666;
	float fConst3667;
	float fRec671[3];
	float fConst3668;
	float fConst3669;
	float fConst3670;
	float fRec670[3];
	float fConst3671;
	float fRec669[2];
	FAUSTFLOAT fVbargraph96;
	float fConst3672;
	float fConst3673;
	float fConst3674;
	float fConst3675;
	float fConst3676;
	float fConst3677;
	float fConst3678;
	float fConst3679;
	float fConst3680;
	float fConst3681;
	float fConst3682;
	float fConst3683;
	float fConst3684;
	float fConst3685;
	float fConst3686;
	float fConst3687;
	float fConst3688;
	float fConst3689;
	float fConst3690;
	float fConst3691;
	float fConst3692;
	float fRec682[3];
	float fConst3693;
	float fConst3694;
	float fConst3695;
	float fRec681[3];
	float fConst3696;
	float fConst3697;
	float fConst3698;
	float fRec680[3];
	float fConst3699;
	float fConst3700;
	float fConst3701;
	float fConst3702;
	float fRec679[3];
	float fConst3703;
	float fConst3704;
	float fConst3705;
	float fRec678[3];
	float fConst3706;
	float fConst3707;
	float fConst3708;
	float fRec677[3];
	float fConst3709;
	float fRec676[2];
	FAUSTFLOAT fVbargraph97;
	float fConst3710;
	float fConst3711;
	float fConst3712;
	float fConst3713;
	float fConst3714;
	float fConst3715;
	float fConst3716;
	float fConst3717;
	float fConst3718;
	float fConst3719;
	float fConst3720;
	float fConst3721;
	float fConst3722;
	float fConst3723;
	float fConst3724;
	float fConst3725;
	float fConst3726;
	float fConst3727;
	float fConst3728;
	float fConst3729;
	float fConst3730;
	float fRec689[3];
	float fConst3731;
	float fConst3732;
	float fConst3733;
	float fRec688[3];
	float fConst3734;
	float fConst3735;
	float fConst3736;
	float fRec687[3];
	float fConst3737;
	float fConst3738;
	float fConst3739;
	float fConst3740;
	float fRec686[3];
	float fConst3741;
	float fConst3742;
	float fConst3743;
	float fRec685[3];
	float fConst3744;
	float fConst3745;
	float fConst3746;
	float fRec684[3];
	float fConst3747;
	float fRec683[2];
	FAUSTFLOAT fVbargraph98;
	float fConst3748;
	float fConst3749;
	float fConst3750;
	float fConst3751;
	float fConst3752;
	float fConst3753;
	float fConst3754;
	float fConst3755;
	float fConst3756;
	float fConst3757;
	float fConst3758;
	float fConst3759;
	float fConst3760;
	float fConst3761;
	float fConst3762;
	float fConst3763;
	float fConst3764;
	float fConst3765;
	float fConst3766;
	float fConst3767;
	float fConst3768;
	float fRec696[3];
	float fConst3769;
	float fConst3770;
	float fConst3771;
	float fRec695[3];
	float fConst3772;
	float fConst3773;
	float fConst3774;
	float fRec694[3];
	float fConst3775;
	float fConst3776;
	float fConst3777;
	float fConst3778;
	float fRec693[3];
	float fConst3779;
	float fConst3780;
	float fConst3781;
	float fRec692[3];
	float fConst3782;
	float fConst3783;
	float fConst3784;
	float fRec691[3];
	float fConst3785;
	float fRec690[2];
	FAUSTFLOAT fVbargraph99;
	float fConst3786;
	float fConst3787;
	float fConst3788;
	float fConst3789;
	float fConst3790;
	float fConst3791;
	float fConst3792;
	float fConst3793;
	float fConst3794;
	float fConst3795;
	float fConst3796;
	float fConst3797;
	float fConst3798;
	float fConst3799;
	float fConst3800;
	float fConst3801;
	float fConst3802;
	float fConst3803;
	float fConst3804;
	float fConst3805;
	float fConst3806;
	float fRec703[3];
	float fConst3807;
	float fConst3808;
	float fConst3809;
	float fRec702[3];
	float fConst3810;
	float fConst3811;
	float fConst3812;
	float fRec701[3];
	float fConst3813;
	float fConst3814;
	float fConst3815;
	float fConst3816;
	float fRec700[3];
	float fConst3817;
	float fConst3818;
	float fConst3819;
	float fRec699[3];
	float fConst3820;
	float fConst3821;
	float fConst3822;
	float fRec698[3];
	float fConst3823;
	float fRec697[2];
	FAUSTFLOAT fVbargraph100;
	float fConst3824;
	float fConst3825;
	float fConst3826;
	float fConst3827;
	float fConst3828;
	float fConst3829;
	float fConst3830;
	float fConst3831;
	float fConst3832;
	float fConst3833;
	float fConst3834;
	float fConst3835;
	float fConst3836;
	float fConst3837;
	float fConst3838;
	float fConst3839;
	float fConst3840;
	float fConst3841;
	float fConst3842;
	float fConst3843;
	float fConst3844;
	float fRec710[3];
	float fConst3845;
	float fConst3846;
	float fConst3847;
	float fRec709[3];
	float fConst3848;
	float fConst3849;
	float fConst3850;
	float fRec708[3];
	float fConst3851;
	float fConst3852;
	float fConst3853;
	float fConst3854;
	float fRec707[3];
	float fConst3855;
	float fConst3856;
	float fConst3857;
	float fRec706[3];
	float fConst3858;
	float fConst3859;
	float fConst3860;
	float fRec705[3];
	float fConst3861;
	float fRec704[2];
	FAUSTFLOAT fVbargraph101;
	float fConst3862;
	float fConst3863;
	float fConst3864;
	float fConst3865;
	float fConst3866;
	float fConst3867;
	float fConst3868;
	float fConst3869;
	float fConst3870;
	float fConst3871;
	float fConst3872;
	float fConst3873;
	float fConst3874;
	float fConst3875;
	float fConst3876;
	float fConst3877;
	float fConst3878;
	float fConst3879;
	float fConst3880;
	float fConst3881;
	float fConst3882;
	float fRec717[3];
	float fConst3883;
	float fConst3884;
	float fConst3885;
	float fRec716[3];
	float fConst3886;
	float fConst3887;
	float fConst3888;
	float fRec715[3];
	float fConst3889;
	float fConst3890;
	float fConst3891;
	float fConst3892;
	float fRec714[3];
	float fConst3893;
	float fConst3894;
	float fConst3895;
	float fRec713[3];
	float fConst3896;
	float fConst3897;
	float fConst3898;
	float fRec712[3];
	float fConst3899;
	float fRec711[2];
	FAUSTFLOAT fVbargraph102;
	float fConst3900;
	float fConst3901;
	float fConst3902;
	float fConst3903;
	float fConst3904;
	float fConst3905;
	float fConst3906;
	float fConst3907;
	float fConst3908;
	float fConst3909;
	float fConst3910;
	float fConst3911;
	float fConst3912;
	float fConst3913;
	float fConst3914;
	float fConst3915;
	float fConst3916;
	float fConst3917;
	float fConst3918;
	float fConst3919;
	float fConst3920;
	float fRec724[3];
	float fConst3921;
	float fConst3922;
	float fConst3923;
	float fRec723[3];
	float fConst3924;
	float fConst3925;
	float fConst3926;
	float fRec722[3];
	float fConst3927;
	float fConst3928;
	float fConst3929;
	float fConst3930;
	float fRec721[3];
	float fConst3931;
	float fConst3932;
	float fConst3933;
	float fRec720[3];
	float fConst3934;
	float fConst3935;
	float fConst3936;
	float fRec719[3];
	float fConst3937;
	float fRec718[2];
	FAUSTFLOAT fVbargraph103;
	float fConst3938;
	float fConst3939;
	float fConst3940;
	float fConst3941;
	float fConst3942;
	float fConst3943;
	float fConst3944;
	float fConst3945;
	float fConst3946;
	float fConst3947;
	float fConst3948;
	float fConst3949;
	float fConst3950;
	float fConst3951;
	float fConst3952;
	float fConst3953;
	float fConst3954;
	float fConst3955;
	float fConst3956;
	float fConst3957;
	float fConst3958;
	float fRec731[3];
	float fConst3959;
	float fConst3960;
	float fConst3961;
	float fRec730[3];
	float fConst3962;
	float fConst3963;
	float fConst3964;
	float fRec729[3];
	float fConst3965;
	float fConst3966;
	float fConst3967;
	float fConst3968;
	float fRec728[3];
	float fConst3969;
	float fConst3970;
	float fConst3971;
	float fRec727[3];
	float fConst3972;
	float fConst3973;
	float fConst3974;
	float fRec726[3];
	float fConst3975;
	float fRec725[2];
	FAUSTFLOAT fVbargraph104;
	float fConst3976;
	float fConst3977;
	float fConst3978;
	float fConst3979;
	float fConst3980;
	float fConst3981;
	float fConst3982;
	float fConst3983;
	float fConst3984;
	float fConst3985;
	float fConst3986;
	float fConst3987;
	float fConst3988;
	float fConst3989;
	float fConst3990;
	float fConst3991;
	float fConst3992;
	float fConst3993;
	float fConst3994;
	float fConst3995;
	float fConst3996;
	float fRec738[3];
	float fConst3997;
	float fConst3998;
	float fConst3999;
	float fRec737[3];
	float fConst4000;
	float fConst4001;
	float fConst4002;
	float fRec736[3];
	float fConst4003;
	float fConst4004;
	float fConst4005;
	float fConst4006;
	float fRec735[3];
	float fConst4007;
	float fConst4008;
	float fConst4009;
	float fRec734[3];
	float fConst4010;
	float fConst4011;
	float fConst4012;
	float fRec733[3];
	float fConst4013;
	float fRec732[2];
	FAUSTFLOAT fVbargraph105;
	float fConst4014;
	float fConst4015;
	float fConst4016;
	float fConst4017;
	float fConst4018;
	float fConst4019;
	float fConst4020;
	float fConst4021;
	float fConst4022;
	float fConst4023;
	float fConst4024;
	float fConst4025;
	float fConst4026;
	float fConst4027;
	float fConst4028;
	float fConst4029;
	float fConst4030;
	float fConst4031;
	float fConst4032;
	float fConst4033;
	float fConst4034;
	float fRec745[3];
	float fConst4035;
	float fConst4036;
	float fConst4037;
	float fRec744[3];
	float fConst4038;
	float fConst4039;
	float fConst4040;
	float fRec743[3];
	float fConst4041;
	float fConst4042;
	float fConst4043;
	float fConst4044;
	float fRec742[3];
	float fConst4045;
	float fConst4046;
	float fConst4047;
	float fRec741[3];
	float fConst4048;
	float fConst4049;
	float fConst4050;
	float fRec740[3];
	float fConst4051;
	float fRec739[2];
	FAUSTFLOAT fVbargraph106;
	float fConst4052;
	float fConst4053;
	float fConst4054;
	float fConst4055;
	float fConst4056;
	float fConst4057;
	float fConst4058;
	float fConst4059;
	float fConst4060;
	float fConst4061;
	float fConst4062;
	float fConst4063;
	float fConst4064;
	float fConst4065;
	float fConst4066;
	float fConst4067;
	float fConst4068;
	float fConst4069;
	float fConst4070;
	float fConst4071;
	float fConst4072;
	float fRec752[3];
	float fConst4073;
	float fConst4074;
	float fConst4075;
	float fRec751[3];
	float fConst4076;
	float fConst4077;
	float fConst4078;
	float fRec750[3];
	float fConst4079;
	float fConst4080;
	float fConst4081;
	float fConst4082;
	float fRec749[3];
	float fConst4083;
	float fConst4084;
	float fConst4085;
	float fRec748[3];
	float fConst4086;
	float fConst4087;
	float fConst4088;
	float fRec747[3];
	float fConst4089;
	float fRec746[2];
	FAUSTFLOAT fVbargraph107;
	float fConst4090;
	float fConst4091;
	float fConst4092;
	float fConst4093;
	float fConst4094;
	float fConst4095;
	float fConst4096;
	float fConst4097;
	float fConst4098;
	float fConst4099;
	float fConst4100;
	float fConst4101;
	float fConst4102;
	float fConst4103;
	float fConst4104;
	float fConst4105;
	float fConst4106;
	float fConst4107;
	float fConst4108;
	float fConst4109;
	float fConst4110;
	float fRec759[3];
	float fConst4111;
	float fConst4112;
	float fConst4113;
	float fRec758[3];
	float fConst4114;
	float fConst4115;
	float fConst4116;
	float fRec757[3];
	float fConst4117;
	float fConst4118;
	float fConst4119;
	float fConst4120;
	float fRec756[3];
	float fConst4121;
	float fConst4122;
	float fConst4123;
	float fRec755[3];
	float fConst4124;
	float fConst4125;
	float fConst4126;
	float fRec754[3];
	float fConst4127;
	float fRec753[2];
	FAUSTFLOAT fVbargraph108;
	float fConst4128;
	float fConst4129;
	float fConst4130;
	float fConst4131;
	float fConst4132;
	float fConst4133;
	float fConst4134;
	float fConst4135;
	float fConst4136;
	float fConst4137;
	float fConst4138;
	float fConst4139;
	float fConst4140;
	float fConst4141;
	float fConst4142;
	float fConst4143;
	float fConst4144;
	float fConst4145;
	float fConst4146;
	float fConst4147;
	float fConst4148;
	float fRec766[3];
	float fConst4149;
	float fConst4150;
	float fConst4151;
	float fRec765[3];
	float fConst4152;
	float fConst4153;
	float fConst4154;
	float fRec764[3];
	float fConst4155;
	float fConst4156;
	float fConst4157;
	float fConst4158;
	float fRec763[3];
	float fConst4159;
	float fConst4160;
	float fConst4161;
	float fRec762[3];
	float fConst4162;
	float fConst4163;
	float fConst4164;
	float fRec761[3];
	float fConst4165;
	float fRec760[2];
	FAUSTFLOAT fVbargraph109;
	float fConst4166;
	float fConst4167;
	float fConst4168;
	float fConst4169;
	float fConst4170;
	float fConst4171;
	float fConst4172;
	float fConst4173;
	float fConst4174;
	float fConst4175;
	float fConst4176;
	float fConst4177;
	float fConst4178;
	float fConst4179;
	float fConst4180;
	float fConst4181;
	float fConst4182;
	float fConst4183;
	float fConst4184;
	float fConst4185;
	float fConst4186;
	float fRec773[3];
	float fConst4187;
	float fConst4188;
	float fConst4189;
	float fRec772[3];
	float fConst4190;
	float fConst4191;
	float fConst4192;
	float fRec771[3];
	float fConst4193;
	float fConst4194;
	float fConst4195;
	float fConst4196;
	float fRec770[3];
	float fConst4197;
	float fConst4198;
	float fConst4199;
	float fRec769[3];
	float fConst4200;
	float fConst4201;
	float fConst4202;
	float fRec768[3];
	float fConst4203;
	float fRec767[2];
	FAUSTFLOAT fVbargraph110;
	float fConst4204;
	float fConst4205;
	float fConst4206;
	float fConst4207;
	float fConst4208;
	float fConst4209;
	float fConst4210;
	float fConst4211;
	float fConst4212;
	float fConst4213;
	float fConst4214;
	float fConst4215;
	float fConst4216;
	float fConst4217;
	float fConst4218;
	float fConst4219;
	float fConst4220;
	float fConst4221;
	float fConst4222;
	float fConst4223;
	float fConst4224;
	float fRec780[3];
	float fConst4225;
	float fConst4226;
	float fConst4227;
	float fRec779[3];
	float fConst4228;
	float fConst4229;
	float fConst4230;
	float fRec778[3];
	float fConst4231;
	float fConst4232;
	float fConst4233;
	float fConst4234;
	float fRec777[3];
	float fConst4235;
	float fConst4236;
	float fConst4237;
	float fRec776[3];
	float fConst4238;
	float fConst4239;
	float fConst4240;
	float fRec775[3];
	float fConst4241;
	float fRec774[2];
	FAUSTFLOAT fVbargraph111;
	float fConst4242;
	float fConst4243;
	float fConst4244;
	float fConst4245;
	float fConst4246;
	float fConst4247;
	float fConst4248;
	float fConst4249;
	float fConst4250;
	float fConst4251;
	float fConst4252;
	float fConst4253;
	float fConst4254;
	float fConst4255;
	float fConst4256;
	float fConst4257;
	float fConst4258;
	float fConst4259;
	float fConst4260;
	float fConst4261;
	float fConst4262;
	float fRec787[3];
	float fConst4263;
	float fConst4264;
	float fConst4265;
	float fRec786[3];
	float fConst4266;
	float fConst4267;
	float fConst4268;
	float fRec785[3];
	float fConst4269;
	float fConst4270;
	float fConst4271;
	float fConst4272;
	float fRec784[3];
	float fConst4273;
	float fConst4274;
	float fConst4275;
	float fRec783[3];
	float fConst4276;
	float fConst4277;
	float fConst4278;
	float fRec782[3];
	float fConst4279;
	float fRec781[2];
	FAUSTFLOAT fVbargraph112;
	float fConst4280;
	float fConst4281;
	float fConst4282;
	float fConst4283;
	float fConst4284;
	float fConst4285;
	float fConst4286;
	float fConst4287;
	float fConst4288;
	float fConst4289;
	float fConst4290;
	float fConst4291;
	float fConst4292;
	float fConst4293;
	float fConst4294;
	float fConst4295;
	float fConst4296;
	float fConst4297;
	float fConst4298;
	float fConst4299;
	float fConst4300;
	float fRec794[3];
	float fConst4301;
	float fConst4302;
	float fConst4303;
	float fRec793[3];
	float fConst4304;
	float fConst4305;
	float fConst4306;
	float fRec792[3];
	float fConst4307;
	float fConst4308;
	float fConst4309;
	float fConst4310;
	float fRec791[3];
	float fConst4311;
	float fConst4312;
	float fConst4313;
	float fRec790[3];
	float fConst4314;
	float fConst4315;
	float fConst4316;
	float fRec789[3];
	float fConst4317;
	float fRec788[2];
	FAUSTFLOAT fVbargraph113;
	float fConst4318;
	float fConst4319;
	float fConst4320;
	float fConst4321;
	float fConst4322;
	float fConst4323;
	float fConst4324;
	float fConst4325;
	float fConst4326;
	float fConst4327;
	float fConst4328;
	float fConst4329;
	float fConst4330;
	float fConst4331;
	float fConst4332;
	float fConst4333;
	float fConst4334;
	float fConst4335;
	float fConst4336;
	float fConst4337;
	float fConst4338;
	float fRec801[3];
	float fConst4339;
	float fConst4340;
	float fConst4341;
	float fRec800[3];
	float fConst4342;
	float fConst4343;
	float fConst4344;
	float fRec799[3];
	float fConst4345;
	float fConst4346;
	float fConst4347;
	float fConst4348;
	float fRec798[3];
	float fConst4349;
	float fConst4350;
	float fConst4351;
	float fRec797[3];
	float fConst4352;
	float fConst4353;
	float fConst4354;
	float fRec796[3];
	float fConst4355;
	float fRec795[2];
	FAUSTFLOAT fVbargraph114;
	float fConst4356;
	float fConst4357;
	float fConst4358;
	float fConst4359;
	float fConst4360;
	float fConst4361;
	float fConst4362;
	float fConst4363;
	float fConst4364;
	float fConst4365;
	float fConst4366;
	float fConst4367;
	float fConst4368;
	float fConst4369;
	float fConst4370;
	float fConst4371;
	float fConst4372;
	float fConst4373;
	float fConst4374;
	float fConst4375;
	float fConst4376;
	float fRec808[3];
	float fConst4377;
	float fConst4378;
	float fConst4379;
	float fRec807[3];
	float fConst4380;
	float fConst4381;
	float fConst4382;
	float fRec806[3];
	float fConst4383;
	float fConst4384;
	float fConst4385;
	float fConst4386;
	float fRec805[3];
	float fConst4387;
	float fConst4388;
	float fConst4389;
	float fRec804[3];
	float fConst4390;
	float fConst4391;
	float fConst4392;
	float fRec803[3];
	float fConst4393;
	float fRec802[2];
	FAUSTFLOAT fVbargraph115;
	float fConst4394;
	float fConst4395;
	float fConst4396;
	float fConst4397;
	float fConst4398;
	float fConst4399;
	float fConst4400;
	float fConst4401;
	float fConst4402;
	float fConst4403;
	float fConst4404;
	float fConst4405;
	float fConst4406;
	float fConst4407;
	float fConst4408;
	float fConst4409;
	float fConst4410;
	float fConst4411;
	float fConst4412;
	float fConst4413;
	float fConst4414;
	float fRec815[3];
	float fConst4415;
	float fConst4416;
	float fConst4417;
	float fRec814[3];
	float fConst4418;
	float fConst4419;
	float fConst4420;
	float fRec813[3];
	float fConst4421;
	float fConst4422;
	float fConst4423;
	float fConst4424;
	float fRec812[3];
	float fConst4425;
	float fConst4426;
	float fConst4427;
	float fRec811[3];
	float fConst4428;
	float fConst4429;
	float fConst4430;
	float fRec810[3];
	float fConst4431;
	float fRec809[2];
	FAUSTFLOAT fVbargraph116;
	float fConst4432;
	float fConst4433;
	float fConst4434;
	float fConst4435;
	float fConst4436;
	float fConst4437;
	float fConst4438;
	float fConst4439;
	float fConst4440;
	float fConst4441;
	float fConst4442;
	float fConst4443;
	float fConst4444;
	float fConst4445;
	float fConst4446;
	float fConst4447;
	float fConst4448;
	float fConst4449;
	float fConst4450;
	float fConst4451;
	float fConst4452;
	float fRec822[3];
	float fConst4453;
	float fConst4454;
	float fConst4455;
	float fRec821[3];
	float fConst4456;
	float fConst4457;
	float fConst4458;
	float fRec820[3];
	float fConst4459;
	float fConst4460;
	float fConst4461;
	float fConst4462;
	float fRec819[3];
	float fConst4463;
	float fConst4464;
	float fConst4465;
	float fRec818[3];
	float fConst4466;
	float fConst4467;
	float fConst4468;
	float fRec817[3];
	float fConst4469;
	float fRec816[2];
	FAUSTFLOAT fVbargraph117;
	float fConst4470;
	float fConst4471;
	float fConst4472;
	float fConst4473;
	float fConst4474;
	float fConst4475;
	float fConst4476;
	float fConst4477;
	float fConst4478;
	float fConst4479;
	float fConst4480;
	float fConst4481;
	float fConst4482;
	float fConst4483;
	float fConst4484;
	float fConst4485;
	float fConst4486;
	float fConst4487;
	float fConst4488;
	float fConst4489;
	float fConst4490;
	float fRec829[3];
	float fConst4491;
	float fConst4492;
	float fConst4493;
	float fRec828[3];
	float fConst4494;
	float fConst4495;
	float fConst4496;
	float fRec827[3];
	float fConst4497;
	float fConst4498;
	float fConst4499;
	float fConst4500;
	float fRec826[3];
	float fConst4501;
	float fConst4502;
	float fConst4503;
	float fRec825[3];
	float fConst4504;
	float fConst4505;
	float fConst4506;
	float fRec824[3];
	float fConst4507;
	float fRec823[2];
	FAUSTFLOAT fVbargraph118;
	float fConst4508;
	float fConst4509;
	float fConst4510;
	float fConst4511;
	float fConst4512;
	float fConst4513;
	float fConst4514;
	float fConst4515;
	float fConst4516;
	float fRec833[3];
	float fConst4517;
	float fConst4518;
	float fConst4519;
	float fRec832[3];
	float fConst4520;
	float fConst4521;
	float fConst4522;
	float fRec831[3];
	float fConst4523;
	float fRec830[2];
	FAUSTFLOAT fVbargraph119;
	FAUSTFLOAT allsamples[120];
	
	FAUSTFLOAT max;


 public:
	
	void metadata(Meta* m) { 
		m->declare("analyzers.lib/name", "Faust Analyzer Library");
		m->declare("analyzers.lib/version", "0.0");
		m->declare("basics.lib/name", "Faust Basic Element Library");
		m->declare("basics.lib/version", "0.0");
		m->declare("filename", "octave_sample_code.dsp");
		m->declare("filters.lib/name", "Faust Filters Library");
		m->declare("filters.lib/version", "0.0");
		m->declare("maths.lib/author", "GRAME");
		m->declare("maths.lib/copyright", "GRAME");
		m->declare("maths.lib/license", "LGPL with exception");
		m->declare("maths.lib/name", "Faust Math Library");
		m->declare("maths.lib/version", "2.1");
		m->declare("name", "octave_sample_code");
		m->declare("signals.lib/name", "Faust Signal Routing Library");
		m->declare("signals.lib/version", "0.0");
	}

	virtual int getNumInputs() {
		return 1;
		
	}
	virtual int getNumOutputs() {
		return 1;
		
	}
	virtual int getInputRate(int channel) {
		int rate;
		switch (channel) {
			case 0: {
				rate = 1;
				break;
			}
			default: {
				rate = -1;
				break;
			}
			
		}
		return rate;
		
	}
	virtual int getOutputRate(int channel) {
		int rate;
		switch (channel) {
			case 0: {
				rate = 1;
				break;
			}
			default: {
				rate = -1;
				break;
			}
			
		}
		return rate;
		
	}
	
	static void classInit(int sample_rate) {
		
	}
	
	virtual void instanceConstants(int sample_rate) {
		fSampleRate = sample_rate;
		fConst0 = std::min<float>(192000.0f, std::max<float>(1.0f, float(fSampleRate)));
		fConst1 = (1000.0f / fConst0);
		fConst2 = std::tan((62831.8516f / fConst0));
		fConst3 = (1.0f / fConst2);
		fConst4 = (1.0f / (((fConst3 + 0.157482162f) / fConst2) + 0.935140193f));
		fConst5 = mydsp_faustpower2_f(fConst2);
		fConst6 = (50.0638084f / fConst5);
		fConst7 = (fConst6 + 0.935140193f);
		fConst8 = (1.0f / (((fConst3 + 0.743130445f) / fConst2) + 1.4500711f));
		fConst9 = (11.0520525f / fConst5);
		fConst10 = (fConst9 + 1.4500711f);
		fConst11 = (1.0f / (((fConst3 + 3.18972731f) / fConst2) + 4.07678175f));
		fConst12 = (0.00176617282f / fConst5);
		fConst13 = (fConst12 + 0.000407678192f);
		fConst14 = (((fConst3 + -3.18972731f) / fConst2) + 4.07678175f);
		fConst15 = (1.0f / fConst5);
		fConst16 = (2.0f * (4.07678175f - fConst15));
		fConst17 = (2.0f * (0.000407678192f - fConst12));
		fConst18 = (((fConst3 + -0.743130445f) / fConst2) + 1.4500711f);
		fConst19 = (2.0f * (1.4500711f - fConst15));
		fConst20 = (2.0f * (1.4500711f - fConst9));
		fConst21 = (((fConst3 + -0.157482162f) / fConst2) + 0.935140193f);
		fConst22 = (2.0f * (0.935140193f - fConst15));
		fConst23 = (2.0f * (0.935140193f - fConst6));
		fConst24 = std::tan((59305.3711f / fConst0));
		fConst25 = (1.0f / fConst24);
		fConst26 = (1.0f / (((fConst25 + 0.157482162f) / fConst24) + 0.935140193f));
		fConst27 = mydsp_faustpower2_f(fConst24);
		fConst28 = (50.0638084f / fConst27);
		fConst29 = (fConst28 + 0.935140193f);
		fConst30 = (1.0f / (((fConst25 + 0.743130445f) / fConst24) + 1.4500711f));
		fConst31 = (11.0520525f / fConst27);
		fConst32 = (fConst31 + 1.4500711f);
		fConst33 = (1.0f / (((fConst25 + 3.18972731f) / fConst24) + 4.07678175f));
		fConst34 = (0.00176617282f / fConst27);
		fConst35 = (fConst34 + 0.000407678192f);
		fConst36 = (1.0f / (((fConst3 + 0.168404877f) / fConst2) + 1.06935835f));
		fConst37 = (fConst15 + 53.5361519f);
		fConst38 = (1.0f / (((fConst3 + 0.51247865f) / fConst2) + 0.689621389f));
		fConst39 = (fConst15 + 7.62173128f);
		fConst40 = (1.0f / (((fConst3 + 0.782413065f) / fConst2) + 0.245291501f));
		fConst41 = (9.99999975e-05f / fConst5);
		fConst42 = (fConst41 + 0.000433227193f);
		fConst43 = (((fConst3 + -0.782413065f) / fConst2) + 0.245291501f);
		fConst44 = (2.0f * (0.245291501f - fConst15));
		fConst45 = (2.0f * (0.000433227193f - fConst41));
		fConst46 = (((fConst3 + -0.51247865f) / fConst2) + 0.689621389f);
		fConst47 = (2.0f * (0.689621389f - fConst15));
		fConst48 = (2.0f * (7.62173128f - fConst15));
		fConst49 = (((fConst3 + -0.168404877f) / fConst2) + 1.06935835f);
		fConst50 = (2.0f * (1.06935835f - fConst15));
		fConst51 = (2.0f * (53.5361519f - fConst15));
		fConst52 = (((fConst25 + -3.18972731f) / fConst24) + 4.07678175f);
		fConst53 = (1.0f / fConst27);
		fConst54 = (2.0f * (4.07678175f - fConst53));
		fConst55 = (2.0f * (0.000407678192f - fConst34));
		fConst56 = (((fConst25 + -0.743130445f) / fConst24) + 1.4500711f);
		fConst57 = (2.0f * (1.4500711f - fConst53));
		fConst58 = (2.0f * (1.4500711f - fConst31));
		fConst59 = (((fConst25 + -0.157482162f) / fConst24) + 0.935140193f);
		fConst60 = (2.0f * (0.935140193f - fConst53));
		fConst61 = (2.0f * (0.935140193f - fConst28));
		fConst62 = std::tan((55976.8164f / fConst0));
		fConst63 = (1.0f / fConst62);
		fConst64 = (1.0f / (((fConst63 + 0.157482162f) / fConst62) + 0.935140193f));
		fConst65 = mydsp_faustpower2_f(fConst62);
		fConst66 = (50.0638084f / fConst65);
		fConst67 = (fConst66 + 0.935140193f);
		fConst68 = (1.0f / (((fConst63 + 0.743130445f) / fConst62) + 1.4500711f));
		fConst69 = (11.0520525f / fConst65);
		fConst70 = (fConst69 + 1.4500711f);
		fConst71 = (1.0f / (((fConst63 + 3.18972731f) / fConst62) + 4.07678175f));
		fConst72 = (0.00176617282f / fConst65);
		fConst73 = (fConst72 + 0.000407678192f);
		fConst74 = (1.0f / (((fConst25 + 0.168404877f) / fConst24) + 1.06935835f));
		fConst75 = (fConst53 + 53.5361519f);
		fConst76 = (1.0f / (((fConst25 + 0.51247865f) / fConst24) + 0.689621389f));
		fConst77 = (fConst53 + 7.62173128f);
		fConst78 = (1.0f / (((fConst25 + 0.782413065f) / fConst24) + 0.245291501f));
		fConst79 = (9.99999975e-05f / fConst27);
		fConst80 = (fConst79 + 0.000433227193f);
		fConst81 = (((fConst25 + -0.782413065f) / fConst24) + 0.245291501f);
		fConst82 = (2.0f * (0.245291501f - fConst53));
		fConst83 = (2.0f * (0.000433227193f - fConst79));
		fConst84 = (((fConst25 + -0.51247865f) / fConst24) + 0.689621389f);
		fConst85 = (2.0f * (0.689621389f - fConst53));
		fConst86 = (2.0f * (7.62173128f - fConst53));
		fConst87 = (((fConst25 + -0.168404877f) / fConst24) + 1.06935835f);
		fConst88 = (2.0f * (1.06935835f - fConst53));
		fConst89 = (2.0f * (53.5361519f - fConst53));
		fConst90 = (((fConst63 + -3.18972731f) / fConst62) + 4.07678175f);
		fConst91 = (1.0f / fConst65);
		fConst92 = (2.0f * (4.07678175f - fConst91));
		fConst93 = (2.0f * (0.000407678192f - fConst72));
		fConst94 = (((fConst63 + -0.743130445f) / fConst62) + 1.4500711f);
		fConst95 = (2.0f * (1.4500711f - fConst91));
		fConst96 = (2.0f * (1.4500711f - fConst69));
		fConst97 = (((fConst63 + -0.157482162f) / fConst62) + 0.935140193f);
		fConst98 = (2.0f * (0.935140193f - fConst91));
		fConst99 = (2.0f * (0.935140193f - fConst66));
		fConst100 = std::tan((52835.0781f / fConst0));
		fConst101 = (1.0f / fConst100);
		fConst102 = (1.0f / (((fConst101 + 0.157482162f) / fConst100) + 0.935140193f));
		fConst103 = mydsp_faustpower2_f(fConst100);
		fConst104 = (50.0638084f / fConst103);
		fConst105 = (fConst104 + 0.935140193f);
		fConst106 = (1.0f / (((fConst101 + 0.743130445f) / fConst100) + 1.4500711f));
		fConst107 = (11.0520525f / fConst103);
		fConst108 = (fConst107 + 1.4500711f);
		fConst109 = (1.0f / (((fConst101 + 3.18972731f) / fConst100) + 4.07678175f));
		fConst110 = (0.00176617282f / fConst103);
		fConst111 = (fConst110 + 0.000407678192f);
		fConst112 = (1.0f / (((fConst63 + 0.168404877f) / fConst62) + 1.06935835f));
		fConst113 = (fConst91 + 53.5361519f);
		fConst114 = (1.0f / (((fConst63 + 0.51247865f) / fConst62) + 0.689621389f));
		fConst115 = (fConst91 + 7.62173128f);
		fConst116 = (1.0f / (((fConst63 + 0.782413065f) / fConst62) + 0.245291501f));
		fConst117 = (9.99999975e-05f / fConst65);
		fConst118 = (fConst117 + 0.000433227193f);
		fConst119 = (((fConst63 + -0.782413065f) / fConst62) + 0.245291501f);
		fConst120 = (2.0f * (0.245291501f - fConst91));
		fConst121 = (2.0f * (0.000433227193f - fConst117));
		fConst122 = (((fConst63 + -0.51247865f) / fConst62) + 0.689621389f);
		fConst123 = (2.0f * (0.689621389f - fConst91));
		fConst124 = (2.0f * (7.62173128f - fConst91));
		fConst125 = (((fConst63 + -0.168404877f) / fConst62) + 1.06935835f);
		fConst126 = (2.0f * (1.06935835f - fConst91));
		fConst127 = (2.0f * (53.5361519f - fConst91));
		fConst128 = (((fConst101 + -3.18972731f) / fConst100) + 4.07678175f);
		fConst129 = (1.0f / fConst103);
		fConst130 = (2.0f * (4.07678175f - fConst129));
		fConst131 = (2.0f * (0.000407678192f - fConst110));
		fConst132 = (((fConst101 + -0.743130445f) / fConst100) + 1.4500711f);
		fConst133 = (2.0f * (1.4500711f - fConst129));
		fConst134 = (2.0f * (1.4500711f - fConst107));
		fConst135 = (((fConst101 + -0.157482162f) / fConst100) + 0.935140193f);
		fConst136 = (2.0f * (0.935140193f - fConst129));
		fConst137 = (2.0f * (0.935140193f - fConst104));
		fConst138 = std::tan((49869.6758f / fConst0));
		fConst139 = (1.0f / fConst138);
		fConst140 = (1.0f / (((fConst139 + 0.157482162f) / fConst138) + 0.935140193f));
		fConst141 = mydsp_faustpower2_f(fConst138);
		fConst142 = (50.0638084f / fConst141);
		fConst143 = (fConst142 + 0.935140193f);
		fConst144 = (1.0f / (((fConst139 + 0.743130445f) / fConst138) + 1.4500711f));
		fConst145 = (11.0520525f / fConst141);
		fConst146 = (fConst145 + 1.4500711f);
		fConst147 = (1.0f / (((fConst139 + 3.18972731f) / fConst138) + 4.07678175f));
		fConst148 = (0.00176617282f / fConst141);
		fConst149 = (fConst148 + 0.000407678192f);
		fConst150 = (1.0f / (((fConst101 + 0.168404877f) / fConst100) + 1.06935835f));
		fConst151 = (fConst129 + 53.5361519f);
		fConst152 = (1.0f / (((fConst101 + 0.51247865f) / fConst100) + 0.689621389f));
		fConst153 = (fConst129 + 7.62173128f);
		fConst154 = (1.0f / (((fConst101 + 0.782413065f) / fConst100) + 0.245291501f));
		fConst155 = (9.99999975e-05f / fConst103);
		fConst156 = (fConst155 + 0.000433227193f);
		fConst157 = (((fConst101 + -0.782413065f) / fConst100) + 0.245291501f);
		fConst158 = (2.0f * (0.245291501f - fConst129));
		fConst159 = (2.0f * (0.000433227193f - fConst155));
		fConst160 = (((fConst101 + -0.51247865f) / fConst100) + 0.689621389f);
		fConst161 = (2.0f * (0.689621389f - fConst129));
		fConst162 = (2.0f * (7.62173128f - fConst129));
		fConst163 = (((fConst101 + -0.168404877f) / fConst100) + 1.06935835f);
		fConst164 = (2.0f * (1.06935835f - fConst129));
		fConst165 = (2.0f * (53.5361519f - fConst129));
		fConst166 = (((fConst139 + -3.18972731f) / fConst138) + 4.07678175f);
		fConst167 = (1.0f / fConst141);
		fConst168 = (2.0f * (4.07678175f - fConst167));
		fConst169 = (2.0f * (0.000407678192f - fConst148));
		fConst170 = (((fConst139 + -0.743130445f) / fConst138) + 1.4500711f);
		fConst171 = (2.0f * (1.4500711f - fConst167));
		fConst172 = (2.0f * (1.4500711f - fConst145));
		fConst173 = (((fConst139 + -0.157482162f) / fConst138) + 0.935140193f);
		fConst174 = (2.0f * (0.935140193f - fConst167));
		fConst175 = (2.0f * (0.935140193f - fConst142));
		fConst176 = std::tan((47070.7031f / fConst0));
		fConst177 = (1.0f / fConst176);
		fConst178 = (1.0f / (((fConst177 + 0.157482162f) / fConst176) + 0.935140193f));
		fConst179 = mydsp_faustpower2_f(fConst176);
		fConst180 = (50.0638084f / fConst179);
		fConst181 = (fConst180 + 0.935140193f);
		fConst182 = (1.0f / (((fConst177 + 0.743130445f) / fConst176) + 1.4500711f));
		fConst183 = (11.0520525f / fConst179);
		fConst184 = (fConst183 + 1.4500711f);
		fConst185 = (1.0f / (((fConst177 + 3.18972731f) / fConst176) + 4.07678175f));
		fConst186 = (0.00176617282f / fConst179);
		fConst187 = (fConst186 + 0.000407678192f);
		fConst188 = (1.0f / (((fConst139 + 0.168404877f) / fConst138) + 1.06935835f));
		fConst189 = (fConst167 + 53.5361519f);
		fConst190 = (1.0f / (((fConst139 + 0.51247865f) / fConst138) + 0.689621389f));
		fConst191 = (fConst167 + 7.62173128f);
		fConst192 = (1.0f / (((fConst139 + 0.782413065f) / fConst138) + 0.245291501f));
		fConst193 = (9.99999975e-05f / fConst141);
		fConst194 = (fConst193 + 0.000433227193f);
		fConst195 = (((fConst139 + -0.782413065f) / fConst138) + 0.245291501f);
		fConst196 = (2.0f * (0.245291501f - fConst167));
		fConst197 = (2.0f * (0.000433227193f - fConst193));
		fConst198 = (((fConst139 + -0.51247865f) / fConst138) + 0.689621389f);
		fConst199 = (2.0f * (0.689621389f - fConst167));
		fConst200 = (2.0f * (7.62173128f - fConst167));
		fConst201 = (((fConst139 + -0.168404877f) / fConst138) + 1.06935835f);
		fConst202 = (2.0f * (1.06935835f - fConst167));
		fConst203 = (2.0f * (53.5361519f - fConst167));
		fConst204 = (((fConst177 + -3.18972731f) / fConst176) + 4.07678175f);
		fConst205 = (1.0f / fConst179);
		fConst206 = (2.0f * (4.07678175f - fConst205));
		fConst207 = (2.0f * (0.000407678192f - fConst186));
		fConst208 = (((fConst177 + -0.743130445f) / fConst176) + 1.4500711f);
		fConst209 = (2.0f * (1.4500711f - fConst205));
		fConst210 = (2.0f * (1.4500711f - fConst183));
		fConst211 = (((fConst177 + -0.157482162f) / fConst176) + 0.935140193f);
		fConst212 = (2.0f * (0.935140193f - fConst205));
		fConst213 = (2.0f * (0.935140193f - fConst180));
		fConst214 = std::tan((44428.8281f / fConst0));
		fConst215 = (1.0f / fConst214);
		fConst216 = (1.0f / (((fConst215 + 0.157482162f) / fConst214) + 0.935140193f));
		fConst217 = mydsp_faustpower2_f(fConst214);
		fConst218 = (50.0638084f / fConst217);
		fConst219 = (fConst218 + 0.935140193f);
		fConst220 = (1.0f / (((fConst215 + 0.743130445f) / fConst214) + 1.4500711f));
		fConst221 = (11.0520525f / fConst217);
		fConst222 = (fConst221 + 1.4500711f);
		fConst223 = (1.0f / (((fConst215 + 3.18972731f) / fConst214) + 4.07678175f));
		fConst224 = (0.00176617282f / fConst217);
		fConst225 = (fConst224 + 0.000407678192f);
		fConst226 = (1.0f / (((fConst177 + 0.168404877f) / fConst176) + 1.06935835f));
		fConst227 = (fConst205 + 53.5361519f);
		fConst228 = (1.0f / (((fConst177 + 0.51247865f) / fConst176) + 0.689621389f));
		fConst229 = (fConst205 + 7.62173128f);
		fConst230 = (1.0f / (((fConst177 + 0.782413065f) / fConst176) + 0.245291501f));
		fConst231 = (9.99999975e-05f / fConst179);
		fConst232 = (fConst231 + 0.000433227193f);
		fConst233 = (((fConst177 + -0.782413065f) / fConst176) + 0.245291501f);
		fConst234 = (2.0f * (0.245291501f - fConst205));
		fConst235 = (2.0f * (0.000433227193f - fConst231));
		fConst236 = (((fConst177 + -0.51247865f) / fConst176) + 0.689621389f);
		fConst237 = (2.0f * (0.689621389f - fConst205));
		fConst238 = (2.0f * (7.62173128f - fConst205));
		fConst239 = (((fConst177 + -0.168404877f) / fConst176) + 1.06935835f);
		fConst240 = (2.0f * (1.06935835f - fConst205));
		fConst241 = (2.0f * (53.5361519f - fConst205));
		fConst242 = (((fConst215 + -3.18972731f) / fConst214) + 4.07678175f);
		fConst243 = (1.0f / fConst217);
		fConst244 = (2.0f * (4.07678175f - fConst243));
		fConst245 = (2.0f * (0.000407678192f - fConst224));
		fConst246 = (((fConst215 + -0.743130445f) / fConst214) + 1.4500711f);
		fConst247 = (2.0f * (1.4500711f - fConst243));
		fConst248 = (2.0f * (1.4500711f - fConst221));
		fConst249 = (((fConst215 + -0.157482162f) / fConst214) + 0.935140193f);
		fConst250 = (2.0f * (0.935140193f - fConst243));
		fConst251 = (2.0f * (0.935140193f - fConst218));
		fConst252 = std::tan((41935.2305f / fConst0));
		fConst253 = (1.0f / fConst252);
		fConst254 = (1.0f / (((fConst253 + 0.157482162f) / fConst252) + 0.935140193f));
		fConst255 = mydsp_faustpower2_f(fConst252);
		fConst256 = (50.0638084f / fConst255);
		fConst257 = (fConst256 + 0.935140193f);
		fConst258 = (1.0f / (((fConst253 + 0.743130445f) / fConst252) + 1.4500711f));
		fConst259 = (11.0520525f / fConst255);
		fConst260 = (fConst259 + 1.4500711f);
		fConst261 = (1.0f / (((fConst253 + 3.18972731f) / fConst252) + 4.07678175f));
		fConst262 = (0.00176617282f / fConst255);
		fConst263 = (fConst262 + 0.000407678192f);
		fConst264 = (1.0f / (((fConst215 + 0.168404877f) / fConst214) + 1.06935835f));
		fConst265 = (fConst243 + 53.5361519f);
		fConst266 = (1.0f / (((fConst215 + 0.51247865f) / fConst214) + 0.689621389f));
		fConst267 = (fConst243 + 7.62173128f);
		fConst268 = (1.0f / (((fConst215 + 0.782413065f) / fConst214) + 0.245291501f));
		fConst269 = (9.99999975e-05f / fConst217);
		fConst270 = (fConst269 + 0.000433227193f);
		fConst271 = (((fConst215 + -0.782413065f) / fConst214) + 0.245291501f);
		fConst272 = (2.0f * (0.245291501f - fConst243));
		fConst273 = (2.0f * (0.000433227193f - fConst269));
		fConst274 = (((fConst215 + -0.51247865f) / fConst214) + 0.689621389f);
		fConst275 = (2.0f * (0.689621389f - fConst243));
		fConst276 = (2.0f * (7.62173128f - fConst243));
		fConst277 = (((fConst215 + -0.168404877f) / fConst214) + 1.06935835f);
		fConst278 = (2.0f * (1.06935835f - fConst243));
		fConst279 = (2.0f * (53.5361519f - fConst243));
		fConst280 = (((fConst253 + -3.18972731f) / fConst252) + 4.07678175f);
		fConst281 = (1.0f / fConst255);
		fConst282 = (2.0f * (4.07678175f - fConst281));
		fConst283 = (2.0f * (0.000407678192f - fConst262));
		fConst284 = (((fConst253 + -0.743130445f) / fConst252) + 1.4500711f);
		fConst285 = (2.0f * (1.4500711f - fConst281));
		fConst286 = (2.0f * (1.4500711f - fConst259));
		fConst287 = (((fConst253 + -0.157482162f) / fConst252) + 0.935140193f);
		fConst288 = (2.0f * (0.935140193f - fConst281));
		fConst289 = (2.0f * (0.935140193f - fConst256));
		fConst290 = std::tan((39581.5859f / fConst0));
		fConst291 = (1.0f / fConst290);
		fConst292 = (1.0f / (((fConst291 + 0.157482162f) / fConst290) + 0.935140193f));
		fConst293 = mydsp_faustpower2_f(fConst290);
		fConst294 = (50.0638084f / fConst293);
		fConst295 = (fConst294 + 0.935140193f);
		fConst296 = (1.0f / (((fConst291 + 0.743130445f) / fConst290) + 1.4500711f));
		fConst297 = (11.0520525f / fConst293);
		fConst298 = (fConst297 + 1.4500711f);
		fConst299 = (1.0f / (((fConst291 + 3.18972731f) / fConst290) + 4.07678175f));
		fConst300 = (0.00176617282f / fConst293);
		fConst301 = (fConst300 + 0.000407678192f);
		fConst302 = (1.0f / (((fConst253 + 0.168404877f) / fConst252) + 1.06935835f));
		fConst303 = (fConst281 + 53.5361519f);
		fConst304 = (1.0f / (((fConst253 + 0.51247865f) / fConst252) + 0.689621389f));
		fConst305 = (fConst281 + 7.62173128f);
		fConst306 = (1.0f / (((fConst253 + 0.782413065f) / fConst252) + 0.245291501f));
		fConst307 = (9.99999975e-05f / fConst255);
		fConst308 = (fConst307 + 0.000433227193f);
		fConst309 = (((fConst253 + -0.782413065f) / fConst252) + 0.245291501f);
		fConst310 = (2.0f * (0.245291501f - fConst281));
		fConst311 = (2.0f * (0.000433227193f - fConst307));
		fConst312 = (((fConst253 + -0.51247865f) / fConst252) + 0.689621389f);
		fConst313 = (2.0f * (0.689621389f - fConst281));
		fConst314 = (2.0f * (7.62173128f - fConst281));
		fConst315 = (((fConst253 + -0.168404877f) / fConst252) + 1.06935835f);
		fConst316 = (2.0f * (1.06935835f - fConst281));
		fConst317 = (2.0f * (53.5361519f - fConst281));
		fConst318 = (((fConst291 + -3.18972731f) / fConst290) + 4.07678175f);
		fConst319 = (1.0f / fConst293);
		fConst320 = (2.0f * (4.07678175f - fConst319));
		fConst321 = (2.0f * (0.000407678192f - fConst300));
		fConst322 = (((fConst291 + -0.743130445f) / fConst290) + 1.4500711f);
		fConst323 = (2.0f * (1.4500711f - fConst319));
		fConst324 = (2.0f * (1.4500711f - fConst297));
		fConst325 = (((fConst291 + -0.157482162f) / fConst290) + 0.935140193f);
		fConst326 = (2.0f * (0.935140193f - fConst319));
		fConst327 = (2.0f * (0.935140193f - fConst294));
		fConst328 = std::tan((37360.043f / fConst0));
		fConst329 = (1.0f / fConst328);
		fConst330 = (1.0f / (((fConst329 + 0.157482162f) / fConst328) + 0.935140193f));
		fConst331 = mydsp_faustpower2_f(fConst328);
		fConst332 = (50.0638084f / fConst331);
		fConst333 = (fConst332 + 0.935140193f);
		fConst334 = (1.0f / (((fConst329 + 0.743130445f) / fConst328) + 1.4500711f));
		fConst335 = (11.0520525f / fConst331);
		fConst336 = (fConst335 + 1.4500711f);
		fConst337 = (1.0f / (((fConst329 + 3.18972731f) / fConst328) + 4.07678175f));
		fConst338 = (0.00176617282f / fConst331);
		fConst339 = (fConst338 + 0.000407678192f);
		fConst340 = (1.0f / (((fConst291 + 0.168404877f) / fConst290) + 1.06935835f));
		fConst341 = (fConst319 + 53.5361519f);
		fConst342 = (1.0f / (((fConst291 + 0.51247865f) / fConst290) + 0.689621389f));
		fConst343 = (fConst319 + 7.62173128f);
		fConst344 = (1.0f / (((fConst291 + 0.782413065f) / fConst290) + 0.245291501f));
		fConst345 = (9.99999975e-05f / fConst293);
		fConst346 = (fConst345 + 0.000433227193f);
		fConst347 = (((fConst291 + -0.782413065f) / fConst290) + 0.245291501f);
		fConst348 = (2.0f * (0.245291501f - fConst319));
		fConst349 = (2.0f * (0.000433227193f - fConst345));
		fConst350 = (((fConst291 + -0.51247865f) / fConst290) + 0.689621389f);
		fConst351 = (2.0f * (0.689621389f - fConst319));
		fConst352 = (2.0f * (7.62173128f - fConst319));
		fConst353 = (((fConst291 + -0.168404877f) / fConst290) + 1.06935835f);
		fConst354 = (2.0f * (1.06935835f - fConst319));
		fConst355 = (2.0f * (53.5361519f - fConst319));
		fConst356 = (((fConst329 + -3.18972731f) / fConst328) + 4.07678175f);
		fConst357 = (1.0f / fConst331);
		fConst358 = (2.0f * (4.07678175f - fConst357));
		fConst359 = (2.0f * (0.000407678192f - fConst338));
		fConst360 = (((fConst329 + -0.743130445f) / fConst328) + 1.4500711f);
		fConst361 = (2.0f * (1.4500711f - fConst357));
		fConst362 = (2.0f * (1.4500711f - fConst335));
		fConst363 = (((fConst329 + -0.157482162f) / fConst328) + 0.935140193f);
		fConst364 = (2.0f * (0.935140193f - fConst357));
		fConst365 = (2.0f * (0.935140193f - fConst332));
		fConst366 = std::tan((35263.1836f / fConst0));
		fConst367 = (1.0f / fConst366);
		fConst368 = (1.0f / (((fConst367 + 0.157482162f) / fConst366) + 0.935140193f));
		fConst369 = mydsp_faustpower2_f(fConst366);
		fConst370 = (50.0638084f / fConst369);
		fConst371 = (fConst370 + 0.935140193f);
		fConst372 = (1.0f / (((fConst367 + 0.743130445f) / fConst366) + 1.4500711f));
		fConst373 = (11.0520525f / fConst369);
		fConst374 = (fConst373 + 1.4500711f);
		fConst375 = (1.0f / (((fConst367 + 3.18972731f) / fConst366) + 4.07678175f));
		fConst376 = (0.00176617282f / fConst369);
		fConst377 = (fConst376 + 0.000407678192f);
		fConst378 = (1.0f / (((fConst329 + 0.168404877f) / fConst328) + 1.06935835f));
		fConst379 = (fConst357 + 53.5361519f);
		fConst380 = (1.0f / (((fConst329 + 0.51247865f) / fConst328) + 0.689621389f));
		fConst381 = (fConst357 + 7.62173128f);
		fConst382 = (1.0f / (((fConst329 + 0.782413065f) / fConst328) + 0.245291501f));
		fConst383 = (9.99999975e-05f / fConst331);
		fConst384 = (fConst383 + 0.000433227193f);
		fConst385 = (((fConst329 + -0.782413065f) / fConst328) + 0.245291501f);
		fConst386 = (2.0f * (0.245291501f - fConst357));
		fConst387 = (2.0f * (0.000433227193f - fConst383));
		fConst388 = (((fConst329 + -0.51247865f) / fConst328) + 0.689621389f);
		fConst389 = (2.0f * (0.689621389f - fConst357));
		fConst390 = (2.0f * (7.62173128f - fConst357));
		fConst391 = (((fConst329 + -0.168404877f) / fConst328) + 1.06935835f);
		fConst392 = (2.0f * (1.06935835f - fConst357));
		fConst393 = (2.0f * (53.5361519f - fConst357));
		fConst394 = (((fConst367 + -3.18972731f) / fConst366) + 4.07678175f);
		fConst395 = (1.0f / fConst369);
		fConst396 = (2.0f * (4.07678175f - fConst395));
		fConst397 = (2.0f * (0.000407678192f - fConst376));
		fConst398 = (((fConst367 + -0.743130445f) / fConst366) + 1.4500711f);
		fConst399 = (2.0f * (1.4500711f - fConst395));
		fConst400 = (2.0f * (1.4500711f - fConst373));
		fConst401 = (((fConst367 + -0.157482162f) / fConst366) + 0.935140193f);
		fConst402 = (2.0f * (0.935140193f - fConst395));
		fConst403 = (2.0f * (0.935140193f - fConst370));
		fConst404 = std::tan((33284.0156f / fConst0));
		fConst405 = (1.0f / fConst404);
		fConst406 = (1.0f / (((fConst405 + 0.157482162f) / fConst404) + 0.935140193f));
		fConst407 = mydsp_faustpower2_f(fConst404);
		fConst408 = (50.0638084f / fConst407);
		fConst409 = (fConst408 + 0.935140193f);
		fConst410 = (1.0f / (((fConst405 + 0.743130445f) / fConst404) + 1.4500711f));
		fConst411 = (11.0520525f / fConst407);
		fConst412 = (fConst411 + 1.4500711f);
		fConst413 = (1.0f / (((fConst405 + 3.18972731f) / fConst404) + 4.07678175f));
		fConst414 = (0.00176617282f / fConst407);
		fConst415 = (fConst414 + 0.000407678192f);
		fConst416 = (1.0f / (((fConst367 + 0.168404877f) / fConst366) + 1.06935835f));
		fConst417 = (fConst395 + 53.5361519f);
		fConst418 = (1.0f / (((fConst367 + 0.51247865f) / fConst366) + 0.689621389f));
		fConst419 = (fConst395 + 7.62173128f);
		fConst420 = (1.0f / (((fConst367 + 0.782413065f) / fConst366) + 0.245291501f));
		fConst421 = (9.99999975e-05f / fConst369);
		fConst422 = (fConst421 + 0.000433227193f);
		fConst423 = (((fConst367 + -0.782413065f) / fConst366) + 0.245291501f);
		fConst424 = (2.0f * (0.245291501f - fConst395));
		fConst425 = (2.0f * (0.000433227193f - fConst421));
		fConst426 = (((fConst367 + -0.51247865f) / fConst366) + 0.689621389f);
		fConst427 = (2.0f * (0.689621389f - fConst395));
		fConst428 = (2.0f * (7.62173128f - fConst395));
		fConst429 = (((fConst367 + -0.168404877f) / fConst366) + 1.06935835f);
		fConst430 = (2.0f * (1.06935835f - fConst395));
		fConst431 = (2.0f * (53.5361519f - fConst395));
		fConst432 = (((fConst405 + -3.18972731f) / fConst404) + 4.07678175f);
		fConst433 = (1.0f / fConst407);
		fConst434 = (2.0f * (4.07678175f - fConst433));
		fConst435 = (2.0f * (0.000407678192f - fConst414));
		fConst436 = (((fConst405 + -0.743130445f) / fConst404) + 1.4500711f);
		fConst437 = (2.0f * (1.4500711f - fConst433));
		fConst438 = (2.0f * (1.4500711f - fConst411));
		fConst439 = (((fConst405 + -0.157482162f) / fConst404) + 0.935140193f);
		fConst440 = (2.0f * (0.935140193f - fConst433));
		fConst441 = (2.0f * (0.935140193f - fConst408));
		fConst442 = std::tan((31415.9258f / fConst0));
		fConst443 = (1.0f / fConst442);
		fConst444 = (1.0f / (((fConst443 + 0.157482162f) / fConst442) + 0.935140193f));
		fConst445 = mydsp_faustpower2_f(fConst442);
		fConst446 = (50.0638084f / fConst445);
		fConst447 = (fConst446 + 0.935140193f);
		fConst448 = (1.0f / (((fConst443 + 0.743130445f) / fConst442) + 1.4500711f));
		fConst449 = (11.0520525f / fConst445);
		fConst450 = (fConst449 + 1.4500711f);
		fConst451 = (1.0f / (((fConst443 + 3.18972731f) / fConst442) + 4.07678175f));
		fConst452 = (0.00176617282f / fConst445);
		fConst453 = (fConst452 + 0.000407678192f);
		fConst454 = (1.0f / (((fConst405 + 0.168404877f) / fConst404) + 1.06935835f));
		fConst455 = (fConst433 + 53.5361519f);
		fConst456 = (1.0f / (((fConst405 + 0.51247865f) / fConst404) + 0.689621389f));
		fConst457 = (fConst433 + 7.62173128f);
		fConst458 = (1.0f / (((fConst405 + 0.782413065f) / fConst404) + 0.245291501f));
		fConst459 = (9.99999975e-05f / fConst407);
		fConst460 = (fConst459 + 0.000433227193f);
		fConst461 = (((fConst405 + -0.782413065f) / fConst404) + 0.245291501f);
		fConst462 = (2.0f * (0.245291501f - fConst433));
		fConst463 = (2.0f * (0.000433227193f - fConst459));
		fConst464 = (((fConst405 + -0.51247865f) / fConst404) + 0.689621389f);
		fConst465 = (2.0f * (0.689621389f - fConst433));
		fConst466 = (2.0f * (7.62173128f - fConst433));
		fConst467 = (((fConst405 + -0.168404877f) / fConst404) + 1.06935835f);
		fConst468 = (2.0f * (1.06935835f - fConst433));
		fConst469 = (2.0f * (53.5361519f - fConst433));
		fConst470 = (((fConst443 + -3.18972731f) / fConst442) + 4.07678175f);
		fConst471 = (1.0f / fConst445);
		fConst472 = (2.0f * (4.07678175f - fConst471));
		fConst473 = (2.0f * (0.000407678192f - fConst452));
		fConst474 = (((fConst443 + -0.743130445f) / fConst442) + 1.4500711f);
		fConst475 = (2.0f * (1.4500711f - fConst471));
		fConst476 = (2.0f * (1.4500711f - fConst449));
		fConst477 = (((fConst443 + -0.157482162f) / fConst442) + 0.935140193f);
		fConst478 = (2.0f * (0.935140193f - fConst471));
		fConst479 = (2.0f * (0.935140193f - fConst446));
		fConst480 = std::tan((29652.6855f / fConst0));
		fConst481 = (1.0f / fConst480);
		fConst482 = (1.0f / (((fConst481 + 0.157482162f) / fConst480) + 0.935140193f));
		fConst483 = mydsp_faustpower2_f(fConst480);
		fConst484 = (50.0638084f / fConst483);
		fConst485 = (fConst484 + 0.935140193f);
		fConst486 = (1.0f / (((fConst481 + 0.743130445f) / fConst480) + 1.4500711f));
		fConst487 = (11.0520525f / fConst483);
		fConst488 = (fConst487 + 1.4500711f);
		fConst489 = (1.0f / (((fConst481 + 3.18972731f) / fConst480) + 4.07678175f));
		fConst490 = (0.00176617282f / fConst483);
		fConst491 = (fConst490 + 0.000407678192f);
		fConst492 = (1.0f / (((fConst443 + 0.168404877f) / fConst442) + 1.06935835f));
		fConst493 = (fConst471 + 53.5361519f);
		fConst494 = (1.0f / (((fConst443 + 0.51247865f) / fConst442) + 0.689621389f));
		fConst495 = (fConst471 + 7.62173128f);
		fConst496 = (1.0f / (((fConst443 + 0.782413065f) / fConst442) + 0.245291501f));
		fConst497 = (9.99999975e-05f / fConst445);
		fConst498 = (fConst497 + 0.000433227193f);
		fConst499 = (((fConst443 + -0.782413065f) / fConst442) + 0.245291501f);
		fConst500 = (2.0f * (0.245291501f - fConst471));
		fConst501 = (2.0f * (0.000433227193f - fConst497));
		fConst502 = (((fConst443 + -0.51247865f) / fConst442) + 0.689621389f);
		fConst503 = (2.0f * (0.689621389f - fConst471));
		fConst504 = (2.0f * (7.62173128f - fConst471));
		fConst505 = (((fConst443 + -0.168404877f) / fConst442) + 1.06935835f);
		fConst506 = (2.0f * (1.06935835f - fConst471));
		fConst507 = (2.0f * (53.5361519f - fConst471));
		fConst508 = (((fConst481 + -3.18972731f) / fConst480) + 4.07678175f);
		fConst509 = (1.0f / fConst483);
		fConst510 = (2.0f * (4.07678175f - fConst509));
		fConst511 = (2.0f * (0.000407678192f - fConst490));
		fConst512 = (((fConst481 + -0.743130445f) / fConst480) + 1.4500711f);
		fConst513 = (2.0f * (1.4500711f - fConst509));
		fConst514 = (2.0f * (1.4500711f - fConst487));
		fConst515 = (((fConst481 + -0.157482162f) / fConst480) + 0.935140193f);
		fConst516 = (2.0f * (0.935140193f - fConst509));
		fConst517 = (2.0f * (0.935140193f - fConst484));
		fConst518 = std::tan((27988.4082f / fConst0));
		fConst519 = (1.0f / fConst518);
		fConst520 = (1.0f / (((fConst519 + 0.157482162f) / fConst518) + 0.935140193f));
		fConst521 = mydsp_faustpower2_f(fConst518);
		fConst522 = (50.0638084f / fConst521);
		fConst523 = (fConst522 + 0.935140193f);
		fConst524 = (1.0f / (((fConst519 + 0.743130445f) / fConst518) + 1.4500711f));
		fConst525 = (11.0520525f / fConst521);
		fConst526 = (fConst525 + 1.4500711f);
		fConst527 = (1.0f / (((fConst519 + 3.18972731f) / fConst518) + 4.07678175f));
		fConst528 = (0.00176617282f / fConst521);
		fConst529 = (fConst528 + 0.000407678192f);
		fConst530 = (1.0f / (((fConst481 + 0.168404877f) / fConst480) + 1.06935835f));
		fConst531 = (fConst509 + 53.5361519f);
		fConst532 = (1.0f / (((fConst481 + 0.51247865f) / fConst480) + 0.689621389f));
		fConst533 = (fConst509 + 7.62173128f);
		fConst534 = (1.0f / (((fConst481 + 0.782413065f) / fConst480) + 0.245291501f));
		fConst535 = (9.99999975e-05f / fConst483);
		fConst536 = (fConst535 + 0.000433227193f);
		fConst537 = (((fConst481 + -0.782413065f) / fConst480) + 0.245291501f);
		fConst538 = (2.0f * (0.245291501f - fConst509));
		fConst539 = (2.0f * (0.000433227193f - fConst535));
		fConst540 = (((fConst481 + -0.51247865f) / fConst480) + 0.689621389f);
		fConst541 = (2.0f * (0.689621389f - fConst509));
		fConst542 = (2.0f * (7.62173128f - fConst509));
		fConst543 = (((fConst481 + -0.168404877f) / fConst480) + 1.06935835f);
		fConst544 = (2.0f * (1.06935835f - fConst509));
		fConst545 = (2.0f * (53.5361519f - fConst509));
		fConst546 = (((fConst519 + -3.18972731f) / fConst518) + 4.07678175f);
		fConst547 = (1.0f / fConst521);
		fConst548 = (2.0f * (4.07678175f - fConst547));
		fConst549 = (2.0f * (0.000407678192f - fConst528));
		fConst550 = (((fConst519 + -0.743130445f) / fConst518) + 1.4500711f);
		fConst551 = (2.0f * (1.4500711f - fConst547));
		fConst552 = (2.0f * (1.4500711f - fConst525));
		fConst553 = (((fConst519 + -0.157482162f) / fConst518) + 0.935140193f);
		fConst554 = (2.0f * (0.935140193f - fConst547));
		fConst555 = (2.0f * (0.935140193f - fConst522));
		fConst556 = std::tan((26417.5391f / fConst0));
		fConst557 = (1.0f / fConst556);
		fConst558 = (1.0f / (((fConst557 + 0.157482162f) / fConst556) + 0.935140193f));
		fConst559 = mydsp_faustpower2_f(fConst556);
		fConst560 = (50.0638084f / fConst559);
		fConst561 = (fConst560 + 0.935140193f);
		fConst562 = (1.0f / (((fConst557 + 0.743130445f) / fConst556) + 1.4500711f));
		fConst563 = (11.0520525f / fConst559);
		fConst564 = (fConst563 + 1.4500711f);
		fConst565 = (1.0f / (((fConst557 + 3.18972731f) / fConst556) + 4.07678175f));
		fConst566 = (0.00176617282f / fConst559);
		fConst567 = (fConst566 + 0.000407678192f);
		fConst568 = (1.0f / (((fConst519 + 0.168404877f) / fConst518) + 1.06935835f));
		fConst569 = (fConst547 + 53.5361519f);
		fConst570 = (1.0f / (((fConst519 + 0.51247865f) / fConst518) + 0.689621389f));
		fConst571 = (fConst547 + 7.62173128f);
		fConst572 = (1.0f / (((fConst519 + 0.782413065f) / fConst518) + 0.245291501f));
		fConst573 = (9.99999975e-05f / fConst521);
		fConst574 = (fConst573 + 0.000433227193f);
		fConst575 = (((fConst519 + -0.782413065f) / fConst518) + 0.245291501f);
		fConst576 = (2.0f * (0.245291501f - fConst547));
		fConst577 = (2.0f * (0.000433227193f - fConst573));
		fConst578 = (((fConst519 + -0.51247865f) / fConst518) + 0.689621389f);
		fConst579 = (2.0f * (0.689621389f - fConst547));
		fConst580 = (2.0f * (7.62173128f - fConst547));
		fConst581 = (((fConst519 + -0.168404877f) / fConst518) + 1.06935835f);
		fConst582 = (2.0f * (1.06935835f - fConst547));
		fConst583 = (2.0f * (53.5361519f - fConst547));
		fConst584 = (((fConst557 + -3.18972731f) / fConst556) + 4.07678175f);
		fConst585 = (1.0f / fConst559);
		fConst586 = (2.0f * (4.07678175f - fConst585));
		fConst587 = (2.0f * (0.000407678192f - fConst566));
		fConst588 = (((fConst557 + -0.743130445f) / fConst556) + 1.4500711f);
		fConst589 = (2.0f * (1.4500711f - fConst585));
		fConst590 = (2.0f * (1.4500711f - fConst563));
		fConst591 = (((fConst557 + -0.157482162f) / fConst556) + 0.935140193f);
		fConst592 = (2.0f * (0.935140193f - fConst585));
		fConst593 = (2.0f * (0.935140193f - fConst560));
		fConst594 = std::tan((24934.8379f / fConst0));
		fConst595 = (1.0f / fConst594);
		fConst596 = (1.0f / (((fConst595 + 0.157482162f) / fConst594) + 0.935140193f));
		fConst597 = mydsp_faustpower2_f(fConst594);
		fConst598 = (50.0638084f / fConst597);
		fConst599 = (fConst598 + 0.935140193f);
		fConst600 = (1.0f / (((fConst595 + 0.743130445f) / fConst594) + 1.4500711f));
		fConst601 = (11.0520525f / fConst597);
		fConst602 = (fConst601 + 1.4500711f);
		fConst603 = (1.0f / (((fConst595 + 3.18972731f) / fConst594) + 4.07678175f));
		fConst604 = (0.00176617282f / fConst597);
		fConst605 = (fConst604 + 0.000407678192f);
		fConst606 = (1.0f / (((fConst557 + 0.168404877f) / fConst556) + 1.06935835f));
		fConst607 = (fConst585 + 53.5361519f);
		fConst608 = (1.0f / (((fConst557 + 0.51247865f) / fConst556) + 0.689621389f));
		fConst609 = (fConst585 + 7.62173128f);
		fConst610 = (1.0f / (((fConst557 + 0.782413065f) / fConst556) + 0.245291501f));
		fConst611 = (9.99999975e-05f / fConst559);
		fConst612 = (fConst611 + 0.000433227193f);
		fConst613 = (((fConst557 + -0.782413065f) / fConst556) + 0.245291501f);
		fConst614 = (2.0f * (0.245291501f - fConst585));
		fConst615 = (2.0f * (0.000433227193f - fConst611));
		fConst616 = (((fConst557 + -0.51247865f) / fConst556) + 0.689621389f);
		fConst617 = (2.0f * (0.689621389f - fConst585));
		fConst618 = (2.0f * (7.62173128f - fConst585));
		fConst619 = (((fConst557 + -0.168404877f) / fConst556) + 1.06935835f);
		fConst620 = (2.0f * (1.06935835f - fConst585));
		fConst621 = (2.0f * (53.5361519f - fConst585));
		fConst622 = (((fConst595 + -3.18972731f) / fConst594) + 4.07678175f);
		fConst623 = (1.0f / fConst597);
		fConst624 = (2.0f * (4.07678175f - fConst623));
		fConst625 = (2.0f * (0.000407678192f - fConst604));
		fConst626 = (((fConst595 + -0.743130445f) / fConst594) + 1.4500711f);
		fConst627 = (2.0f * (1.4500711f - fConst623));
		fConst628 = (2.0f * (1.4500711f - fConst601));
		fConst629 = (((fConst595 + -0.157482162f) / fConst594) + 0.935140193f);
		fConst630 = (2.0f * (0.935140193f - fConst623));
		fConst631 = (2.0f * (0.935140193f - fConst598));
		fConst632 = std::tan((23535.3516f / fConst0));
		fConst633 = (1.0f / fConst632);
		fConst634 = (1.0f / (((fConst633 + 0.157482162f) / fConst632) + 0.935140193f));
		fConst635 = mydsp_faustpower2_f(fConst632);
		fConst636 = (50.0638084f / fConst635);
		fConst637 = (fConst636 + 0.935140193f);
		fConst638 = (1.0f / (((fConst633 + 0.743130445f) / fConst632) + 1.4500711f));
		fConst639 = (11.0520525f / fConst635);
		fConst640 = (fConst639 + 1.4500711f);
		fConst641 = (1.0f / (((fConst633 + 3.18972731f) / fConst632) + 4.07678175f));
		fConst642 = (0.00176617282f / fConst635);
		fConst643 = (fConst642 + 0.000407678192f);
		fConst644 = (1.0f / (((fConst595 + 0.168404877f) / fConst594) + 1.06935835f));
		fConst645 = (fConst623 + 53.5361519f);
		fConst646 = (1.0f / (((fConst595 + 0.51247865f) / fConst594) + 0.689621389f));
		fConst647 = (fConst623 + 7.62173128f);
		fConst648 = (1.0f / (((fConst595 + 0.782413065f) / fConst594) + 0.245291501f));
		fConst649 = (9.99999975e-05f / fConst597);
		fConst650 = (fConst649 + 0.000433227193f);
		fConst651 = (((fConst595 + -0.782413065f) / fConst594) + 0.245291501f);
		fConst652 = (2.0f * (0.245291501f - fConst623));
		fConst653 = (2.0f * (0.000433227193f - fConst649));
		fConst654 = (((fConst595 + -0.51247865f) / fConst594) + 0.689621389f);
		fConst655 = (2.0f * (0.689621389f - fConst623));
		fConst656 = (2.0f * (7.62173128f - fConst623));
		fConst657 = (((fConst595 + -0.168404877f) / fConst594) + 1.06935835f);
		fConst658 = (2.0f * (1.06935835f - fConst623));
		fConst659 = (2.0f * (53.5361519f - fConst623));
		fConst660 = (((fConst633 + -3.18972731f) / fConst632) + 4.07678175f);
		fConst661 = (1.0f / fConst635);
		fConst662 = (2.0f * (4.07678175f - fConst661));
		fConst663 = (2.0f * (0.000407678192f - fConst642));
		fConst664 = (((fConst633 + -0.743130445f) / fConst632) + 1.4500711f);
		fConst665 = (2.0f * (1.4500711f - fConst661));
		fConst666 = (2.0f * (1.4500711f - fConst639));
		fConst667 = (((fConst633 + -0.157482162f) / fConst632) + 0.935140193f);
		fConst668 = (2.0f * (0.935140193f - fConst661));
		fConst669 = (2.0f * (0.935140193f - fConst636));
		fConst670 = std::tan((22214.4141f / fConst0));
		fConst671 = (1.0f / fConst670);
		fConst672 = (1.0f / (((fConst671 + 0.157482162f) / fConst670) + 0.935140193f));
		fConst673 = mydsp_faustpower2_f(fConst670);
		fConst674 = (50.0638084f / fConst673);
		fConst675 = (fConst674 + 0.935140193f);
		fConst676 = (1.0f / (((fConst671 + 0.743130445f) / fConst670) + 1.4500711f));
		fConst677 = (11.0520525f / fConst673);
		fConst678 = (fConst677 + 1.4500711f);
		fConst679 = (1.0f / (((fConst671 + 3.18972731f) / fConst670) + 4.07678175f));
		fConst680 = (0.00176617282f / fConst673);
		fConst681 = (fConst680 + 0.000407678192f);
		fConst682 = (1.0f / (((fConst633 + 0.168404877f) / fConst632) + 1.06935835f));
		fConst683 = (fConst661 + 53.5361519f);
		fConst684 = (1.0f / (((fConst633 + 0.51247865f) / fConst632) + 0.689621389f));
		fConst685 = (fConst661 + 7.62173128f);
		fConst686 = (1.0f / (((fConst633 + 0.782413065f) / fConst632) + 0.245291501f));
		fConst687 = (9.99999975e-05f / fConst635);
		fConst688 = (fConst687 + 0.000433227193f);
		fConst689 = (((fConst633 + -0.782413065f) / fConst632) + 0.245291501f);
		fConst690 = (2.0f * (0.245291501f - fConst661));
		fConst691 = (2.0f * (0.000433227193f - fConst687));
		fConst692 = (((fConst633 + -0.51247865f) / fConst632) + 0.689621389f);
		fConst693 = (2.0f * (0.689621389f - fConst661));
		fConst694 = (2.0f * (7.62173128f - fConst661));
		fConst695 = (((fConst633 + -0.168404877f) / fConst632) + 1.06935835f);
		fConst696 = (2.0f * (1.06935835f - fConst661));
		fConst697 = (2.0f * (53.5361519f - fConst661));
		fConst698 = (((fConst671 + -3.18972731f) / fConst670) + 4.07678175f);
		fConst699 = (1.0f / fConst673);
		fConst700 = (2.0f * (4.07678175f - fConst699));
		fConst701 = (2.0f * (0.000407678192f - fConst680));
		fConst702 = (((fConst671 + -0.743130445f) / fConst670) + 1.4500711f);
		fConst703 = (2.0f * (1.4500711f - fConst699));
		fConst704 = (2.0f * (1.4500711f - fConst677));
		fConst705 = (((fConst671 + -0.157482162f) / fConst670) + 0.935140193f);
		fConst706 = (2.0f * (0.935140193f - fConst699));
		fConst707 = (2.0f * (0.935140193f - fConst674));
		fConst708 = std::tan((20967.6152f / fConst0));
		fConst709 = (1.0f / fConst708);
		fConst710 = (1.0f / (((fConst709 + 0.157482162f) / fConst708) + 0.935140193f));
		fConst711 = mydsp_faustpower2_f(fConst708);
		fConst712 = (50.0638084f / fConst711);
		fConst713 = (fConst712 + 0.935140193f);
		fConst714 = (1.0f / (((fConst709 + 0.743130445f) / fConst708) + 1.4500711f));
		fConst715 = (11.0520525f / fConst711);
		fConst716 = (fConst715 + 1.4500711f);
		fConst717 = (1.0f / (((fConst709 + 3.18972731f) / fConst708) + 4.07678175f));
		fConst718 = (0.00176617282f / fConst711);
		fConst719 = (fConst718 + 0.000407678192f);
		fConst720 = (1.0f / (((fConst671 + 0.168404877f) / fConst670) + 1.06935835f));
		fConst721 = (fConst699 + 53.5361519f);
		fConst722 = (1.0f / (((fConst671 + 0.51247865f) / fConst670) + 0.689621389f));
		fConst723 = (fConst699 + 7.62173128f);
		fConst724 = (1.0f / (((fConst671 + 0.782413065f) / fConst670) + 0.245291501f));
		fConst725 = (9.99999975e-05f / fConst673);
		fConst726 = (fConst725 + 0.000433227193f);
		fConst727 = (((fConst671 + -0.782413065f) / fConst670) + 0.245291501f);
		fConst728 = (2.0f * (0.245291501f - fConst699));
		fConst729 = (2.0f * (0.000433227193f - fConst725));
		fConst730 = (((fConst671 + -0.51247865f) / fConst670) + 0.689621389f);
		fConst731 = (2.0f * (0.689621389f - fConst699));
		fConst732 = (2.0f * (7.62173128f - fConst699));
		fConst733 = (((fConst671 + -0.168404877f) / fConst670) + 1.06935835f);
		fConst734 = (2.0f * (1.06935835f - fConst699));
		fConst735 = (2.0f * (53.5361519f - fConst699));
		fConst736 = (((fConst709 + -3.18972731f) / fConst708) + 4.07678175f);
		fConst737 = (1.0f / fConst711);
		fConst738 = (2.0f * (4.07678175f - fConst737));
		fConst739 = (2.0f * (0.000407678192f - fConst718));
		fConst740 = (((fConst709 + -0.743130445f) / fConst708) + 1.4500711f);
		fConst741 = (2.0f * (1.4500711f - fConst737));
		fConst742 = (2.0f * (1.4500711f - fConst715));
		fConst743 = (((fConst709 + -0.157482162f) / fConst708) + 0.935140193f);
		fConst744 = (2.0f * (0.935140193f - fConst737));
		fConst745 = (2.0f * (0.935140193f - fConst712));
		fConst746 = std::tan((19790.793f / fConst0));
		fConst747 = (1.0f / fConst746);
		fConst748 = (1.0f / (((fConst747 + 0.157482162f) / fConst746) + 0.935140193f));
		fConst749 = mydsp_faustpower2_f(fConst746);
		fConst750 = (50.0638084f / fConst749);
		fConst751 = (fConst750 + 0.935140193f);
		fConst752 = (1.0f / (((fConst747 + 0.743130445f) / fConst746) + 1.4500711f));
		fConst753 = (11.0520525f / fConst749);
		fConst754 = (fConst753 + 1.4500711f);
		fConst755 = (1.0f / (((fConst747 + 3.18972731f) / fConst746) + 4.07678175f));
		fConst756 = (0.00176617282f / fConst749);
		fConst757 = (fConst756 + 0.000407678192f);
		fConst758 = (1.0f / (((fConst709 + 0.168404877f) / fConst708) + 1.06935835f));
		fConst759 = (fConst737 + 53.5361519f);
		fConst760 = (1.0f / (((fConst709 + 0.51247865f) / fConst708) + 0.689621389f));
		fConst761 = (fConst737 + 7.62173128f);
		fConst762 = (1.0f / (((fConst709 + 0.782413065f) / fConst708) + 0.245291501f));
		fConst763 = (9.99999975e-05f / fConst711);
		fConst764 = (fConst763 + 0.000433227193f);
		fConst765 = (((fConst709 + -0.782413065f) / fConst708) + 0.245291501f);
		fConst766 = (2.0f * (0.245291501f - fConst737));
		fConst767 = (2.0f * (0.000433227193f - fConst763));
		fConst768 = (((fConst709 + -0.51247865f) / fConst708) + 0.689621389f);
		fConst769 = (2.0f * (0.689621389f - fConst737));
		fConst770 = (2.0f * (7.62173128f - fConst737));
		fConst771 = (((fConst709 + -0.168404877f) / fConst708) + 1.06935835f);
		fConst772 = (2.0f * (1.06935835f - fConst737));
		fConst773 = (2.0f * (53.5361519f - fConst737));
		fConst774 = (((fConst747 + -3.18972731f) / fConst746) + 4.07678175f);
		fConst775 = (1.0f / fConst749);
		fConst776 = (2.0f * (4.07678175f - fConst775));
		fConst777 = (2.0f * (0.000407678192f - fConst756));
		fConst778 = (((fConst747 + -0.743130445f) / fConst746) + 1.4500711f);
		fConst779 = (2.0f * (1.4500711f - fConst775));
		fConst780 = (2.0f * (1.4500711f - fConst753));
		fConst781 = (((fConst747 + -0.157482162f) / fConst746) + 0.935140193f);
		fConst782 = (2.0f * (0.935140193f - fConst775));
		fConst783 = (2.0f * (0.935140193f - fConst750));
		fConst784 = std::tan((18680.0215f / fConst0));
		fConst785 = (1.0f / fConst784);
		fConst786 = (1.0f / (((fConst785 + 0.157482162f) / fConst784) + 0.935140193f));
		fConst787 = mydsp_faustpower2_f(fConst784);
		fConst788 = (50.0638084f / fConst787);
		fConst789 = (fConst788 + 0.935140193f);
		fConst790 = (1.0f / (((fConst785 + 0.743130445f) / fConst784) + 1.4500711f));
		fConst791 = (11.0520525f / fConst787);
		fConst792 = (fConst791 + 1.4500711f);
		fConst793 = (1.0f / (((fConst785 + 3.18972731f) / fConst784) + 4.07678175f));
		fConst794 = (0.00176617282f / fConst787);
		fConst795 = (fConst794 + 0.000407678192f);
		fConst796 = (1.0f / (((fConst747 + 0.168404877f) / fConst746) + 1.06935835f));
		fConst797 = (fConst775 + 53.5361519f);
		fConst798 = (1.0f / (((fConst747 + 0.51247865f) / fConst746) + 0.689621389f));
		fConst799 = (fConst775 + 7.62173128f);
		fConst800 = (1.0f / (((fConst747 + 0.782413065f) / fConst746) + 0.245291501f));
		fConst801 = (9.99999975e-05f / fConst749);
		fConst802 = (fConst801 + 0.000433227193f);
		fConst803 = (((fConst747 + -0.782413065f) / fConst746) + 0.245291501f);
		fConst804 = (2.0f * (0.245291501f - fConst775));
		fConst805 = (2.0f * (0.000433227193f - fConst801));
		fConst806 = (((fConst747 + -0.51247865f) / fConst746) + 0.689621389f);
		fConst807 = (2.0f * (0.689621389f - fConst775));
		fConst808 = (2.0f * (7.62173128f - fConst775));
		fConst809 = (((fConst747 + -0.168404877f) / fConst746) + 1.06935835f);
		fConst810 = (2.0f * (1.06935835f - fConst775));
		fConst811 = (2.0f * (53.5361519f - fConst775));
		fConst812 = (((fConst785 + -3.18972731f) / fConst784) + 4.07678175f);
		fConst813 = (1.0f / fConst787);
		fConst814 = (2.0f * (4.07678175f - fConst813));
		fConst815 = (2.0f * (0.000407678192f - fConst794));
		fConst816 = (((fConst785 + -0.743130445f) / fConst784) + 1.4500711f);
		fConst817 = (2.0f * (1.4500711f - fConst813));
		fConst818 = (2.0f * (1.4500711f - fConst791));
		fConst819 = (((fConst785 + -0.157482162f) / fConst784) + 0.935140193f);
		fConst820 = (2.0f * (0.935140193f - fConst813));
		fConst821 = (2.0f * (0.935140193f - fConst788));
		fConst822 = std::tan((17631.5918f / fConst0));
		fConst823 = (1.0f / fConst822);
		fConst824 = (1.0f / (((fConst823 + 0.157482162f) / fConst822) + 0.935140193f));
		fConst825 = mydsp_faustpower2_f(fConst822);
		fConst826 = (50.0638084f / fConst825);
		fConst827 = (fConst826 + 0.935140193f);
		fConst828 = (1.0f / (((fConst823 + 0.743130445f) / fConst822) + 1.4500711f));
		fConst829 = (11.0520525f / fConst825);
		fConst830 = (fConst829 + 1.4500711f);
		fConst831 = (1.0f / (((fConst823 + 3.18972731f) / fConst822) + 4.07678175f));
		fConst832 = (0.00176617282f / fConst825);
		fConst833 = (fConst832 + 0.000407678192f);
		fConst834 = (1.0f / (((fConst785 + 0.168404877f) / fConst784) + 1.06935835f));
		fConst835 = (fConst813 + 53.5361519f);
		fConst836 = (1.0f / (((fConst785 + 0.51247865f) / fConst784) + 0.689621389f));
		fConst837 = (fConst813 + 7.62173128f);
		fConst838 = (1.0f / (((fConst785 + 0.782413065f) / fConst784) + 0.245291501f));
		fConst839 = (9.99999975e-05f / fConst787);
		fConst840 = (fConst839 + 0.000433227193f);
		fConst841 = (((fConst785 + -0.782413065f) / fConst784) + 0.245291501f);
		fConst842 = (2.0f * (0.245291501f - fConst813));
		fConst843 = (2.0f * (0.000433227193f - fConst839));
		fConst844 = (((fConst785 + -0.51247865f) / fConst784) + 0.689621389f);
		fConst845 = (2.0f * (0.689621389f - fConst813));
		fConst846 = (2.0f * (7.62173128f - fConst813));
		fConst847 = (((fConst785 + -0.168404877f) / fConst784) + 1.06935835f);
		fConst848 = (2.0f * (1.06935835f - fConst813));
		fConst849 = (2.0f * (53.5361519f - fConst813));
		fConst850 = (((fConst823 + -3.18972731f) / fConst822) + 4.07678175f);
		fConst851 = (1.0f / fConst825);
		fConst852 = (2.0f * (4.07678175f - fConst851));
		fConst853 = (2.0f * (0.000407678192f - fConst832));
		fConst854 = (((fConst823 + -0.743130445f) / fConst822) + 1.4500711f);
		fConst855 = (2.0f * (1.4500711f - fConst851));
		fConst856 = (2.0f * (1.4500711f - fConst829));
		fConst857 = (((fConst823 + -0.157482162f) / fConst822) + 0.935140193f);
		fConst858 = (2.0f * (0.935140193f - fConst851));
		fConst859 = (2.0f * (0.935140193f - fConst826));
		fConst860 = std::tan((16642.0078f / fConst0));
		fConst861 = (1.0f / fConst860);
		fConst862 = (1.0f / (((fConst861 + 0.157482162f) / fConst860) + 0.935140193f));
		fConst863 = mydsp_faustpower2_f(fConst860);
		fConst864 = (50.0638084f / fConst863);
		fConst865 = (fConst864 + 0.935140193f);
		fConst866 = (1.0f / (((fConst861 + 0.743130445f) / fConst860) + 1.4500711f));
		fConst867 = (11.0520525f / fConst863);
		fConst868 = (fConst867 + 1.4500711f);
		fConst869 = (1.0f / (((fConst861 + 3.18972731f) / fConst860) + 4.07678175f));
		fConst870 = (0.00176617282f / fConst863);
		fConst871 = (fConst870 + 0.000407678192f);
		fConst872 = (1.0f / (((fConst823 + 0.168404877f) / fConst822) + 1.06935835f));
		fConst873 = (fConst851 + 53.5361519f);
		fConst874 = (1.0f / (((fConst823 + 0.51247865f) / fConst822) + 0.689621389f));
		fConst875 = (fConst851 + 7.62173128f);
		fConst876 = (1.0f / (((fConst823 + 0.782413065f) / fConst822) + 0.245291501f));
		fConst877 = (9.99999975e-05f / fConst825);
		fConst878 = (fConst877 + 0.000433227193f);
		fConst879 = (((fConst823 + -0.782413065f) / fConst822) + 0.245291501f);
		fConst880 = (2.0f * (0.245291501f - fConst851));
		fConst881 = (2.0f * (0.000433227193f - fConst877));
		fConst882 = (((fConst823 + -0.51247865f) / fConst822) + 0.689621389f);
		fConst883 = (2.0f * (0.689621389f - fConst851));
		fConst884 = (2.0f * (7.62173128f - fConst851));
		fConst885 = (((fConst823 + -0.168404877f) / fConst822) + 1.06935835f);
		fConst886 = (2.0f * (1.06935835f - fConst851));
		fConst887 = (2.0f * (53.5361519f - fConst851));
		fConst888 = (((fConst861 + -3.18972731f) / fConst860) + 4.07678175f);
		fConst889 = (1.0f / fConst863);
		fConst890 = (2.0f * (4.07678175f - fConst889));
		fConst891 = (2.0f * (0.000407678192f - fConst870));
		fConst892 = (((fConst861 + -0.743130445f) / fConst860) + 1.4500711f);
		fConst893 = (2.0f * (1.4500711f - fConst889));
		fConst894 = (2.0f * (1.4500711f - fConst867));
		fConst895 = (((fConst861 + -0.157482162f) / fConst860) + 0.935140193f);
		fConst896 = (2.0f * (0.935140193f - fConst889));
		fConst897 = (2.0f * (0.935140193f - fConst864));
		fConst898 = std::tan((15707.9629f / fConst0));
		fConst899 = (1.0f / fConst898);
		fConst900 = (1.0f / (((fConst899 + 0.157482162f) / fConst898) + 0.935140193f));
		fConst901 = mydsp_faustpower2_f(fConst898);
		fConst902 = (50.0638084f / fConst901);
		fConst903 = (fConst902 + 0.935140193f);
		fConst904 = (1.0f / (((fConst899 + 0.743130445f) / fConst898) + 1.4500711f));
		fConst905 = (11.0520525f / fConst901);
		fConst906 = (fConst905 + 1.4500711f);
		fConst907 = (1.0f / (((fConst899 + 3.18972731f) / fConst898) + 4.07678175f));
		fConst908 = (0.00176617282f / fConst901);
		fConst909 = (fConst908 + 0.000407678192f);
		fConst910 = (1.0f / (((fConst861 + 0.168404877f) / fConst860) + 1.06935835f));
		fConst911 = (fConst889 + 53.5361519f);
		fConst912 = (1.0f / (((fConst861 + 0.51247865f) / fConst860) + 0.689621389f));
		fConst913 = (fConst889 + 7.62173128f);
		fConst914 = (1.0f / (((fConst861 + 0.782413065f) / fConst860) + 0.245291501f));
		fConst915 = (9.99999975e-05f / fConst863);
		fConst916 = (fConst915 + 0.000433227193f);
		fConst917 = (((fConst861 + -0.782413065f) / fConst860) + 0.245291501f);
		fConst918 = (2.0f * (0.245291501f - fConst889));
		fConst919 = (2.0f * (0.000433227193f - fConst915));
		fConst920 = (((fConst861 + -0.51247865f) / fConst860) + 0.689621389f);
		fConst921 = (2.0f * (0.689621389f - fConst889));
		fConst922 = (2.0f * (7.62173128f - fConst889));
		fConst923 = (((fConst861 + -0.168404877f) / fConst860) + 1.06935835f);
		fConst924 = (2.0f * (1.06935835f - fConst889));
		fConst925 = (2.0f * (53.5361519f - fConst889));
		fConst926 = (((fConst899 + -3.18972731f) / fConst898) + 4.07678175f);
		fConst927 = (1.0f / fConst901);
		fConst928 = (2.0f * (4.07678175f - fConst927));
		fConst929 = (2.0f * (0.000407678192f - fConst908));
		fConst930 = (((fConst899 + -0.743130445f) / fConst898) + 1.4500711f);
		fConst931 = (2.0f * (1.4500711f - fConst927));
		fConst932 = (2.0f * (1.4500711f - fConst905));
		fConst933 = (((fConst899 + -0.157482162f) / fConst898) + 0.935140193f);
		fConst934 = (2.0f * (0.935140193f - fConst927));
		fConst935 = (2.0f * (0.935140193f - fConst902));
		fConst936 = std::tan((14826.3428f / fConst0));
		fConst937 = (1.0f / fConst936);
		fConst938 = (1.0f / (((fConst937 + 0.157482162f) / fConst936) + 0.935140193f));
		fConst939 = mydsp_faustpower2_f(fConst936);
		fConst940 = (50.0638084f / fConst939);
		fConst941 = (fConst940 + 0.935140193f);
		fConst942 = (1.0f / (((fConst937 + 0.743130445f) / fConst936) + 1.4500711f));
		fConst943 = (11.0520525f / fConst939);
		fConst944 = (fConst943 + 1.4500711f);
		fConst945 = (1.0f / (((fConst937 + 3.18972731f) / fConst936) + 4.07678175f));
		fConst946 = (0.00176617282f / fConst939);
		fConst947 = (fConst946 + 0.000407678192f);
		fConst948 = (1.0f / (((fConst899 + 0.168404877f) / fConst898) + 1.06935835f));
		fConst949 = (fConst927 + 53.5361519f);
		fConst950 = (1.0f / (((fConst899 + 0.51247865f) / fConst898) + 0.689621389f));
		fConst951 = (fConst927 + 7.62173128f);
		fConst952 = (1.0f / (((fConst899 + 0.782413065f) / fConst898) + 0.245291501f));
		fConst953 = (9.99999975e-05f / fConst901);
		fConst954 = (fConst953 + 0.000433227193f);
		fConst955 = (((fConst899 + -0.782413065f) / fConst898) + 0.245291501f);
		fConst956 = (2.0f * (0.245291501f - fConst927));
		fConst957 = (2.0f * (0.000433227193f - fConst953));
		fConst958 = (((fConst899 + -0.51247865f) / fConst898) + 0.689621389f);
		fConst959 = (2.0f * (0.689621389f - fConst927));
		fConst960 = (2.0f * (7.62173128f - fConst927));
		fConst961 = (((fConst899 + -0.168404877f) / fConst898) + 1.06935835f);
		fConst962 = (2.0f * (1.06935835f - fConst927));
		fConst963 = (2.0f * (53.5361519f - fConst927));
		fConst964 = (((fConst937 + -3.18972731f) / fConst936) + 4.07678175f);
		fConst965 = (1.0f / fConst939);
		fConst966 = (2.0f * (4.07678175f - fConst965));
		fConst967 = (2.0f * (0.000407678192f - fConst946));
		fConst968 = (((fConst937 + -0.743130445f) / fConst936) + 1.4500711f);
		fConst969 = (2.0f * (1.4500711f - fConst965));
		fConst970 = (2.0f * (1.4500711f - fConst943));
		fConst971 = (((fConst937 + -0.157482162f) / fConst936) + 0.935140193f);
		fConst972 = (2.0f * (0.935140193f - fConst965));
		fConst973 = (2.0f * (0.935140193f - fConst940));
		fConst974 = std::tan((13994.2041f / fConst0));
		fConst975 = (1.0f / fConst974);
		fConst976 = (1.0f / (((fConst975 + 0.157482162f) / fConst974) + 0.935140193f));
		fConst977 = mydsp_faustpower2_f(fConst974);
		fConst978 = (50.0638084f / fConst977);
		fConst979 = (fConst978 + 0.935140193f);
		fConst980 = (1.0f / (((fConst975 + 0.743130445f) / fConst974) + 1.4500711f));
		fConst981 = (11.0520525f / fConst977);
		fConst982 = (fConst981 + 1.4500711f);
		fConst983 = (1.0f / (((fConst975 + 3.18972731f) / fConst974) + 4.07678175f));
		fConst984 = (0.00176617282f / fConst977);
		fConst985 = (fConst984 + 0.000407678192f);
		fConst986 = (1.0f / (((fConst937 + 0.168404877f) / fConst936) + 1.06935835f));
		fConst987 = (fConst965 + 53.5361519f);
		fConst988 = (1.0f / (((fConst937 + 0.51247865f) / fConst936) + 0.689621389f));
		fConst989 = (fConst965 + 7.62173128f);
		fConst990 = (1.0f / (((fConst937 + 0.782413065f) / fConst936) + 0.245291501f));
		fConst991 = (9.99999975e-05f / fConst939);
		fConst992 = (fConst991 + 0.000433227193f);
		fConst993 = (((fConst937 + -0.782413065f) / fConst936) + 0.245291501f);
		fConst994 = (2.0f * (0.245291501f - fConst965));
		fConst995 = (2.0f * (0.000433227193f - fConst991));
		fConst996 = (((fConst937 + -0.51247865f) / fConst936) + 0.689621389f);
		fConst997 = (2.0f * (0.689621389f - fConst965));
		fConst998 = (2.0f * (7.62173128f - fConst965));
		fConst999 = (((fConst937 + -0.168404877f) / fConst936) + 1.06935835f);
		fConst1000 = (2.0f * (1.06935835f - fConst965));
		fConst1001 = (2.0f * (53.5361519f - fConst965));
		fConst1002 = (((fConst975 + -3.18972731f) / fConst974) + 4.07678175f);
		fConst1003 = (1.0f / fConst977);
		fConst1004 = (2.0f * (4.07678175f - fConst1003));
		fConst1005 = (2.0f * (0.000407678192f - fConst984));
		fConst1006 = (((fConst975 + -0.743130445f) / fConst974) + 1.4500711f);
		fConst1007 = (2.0f * (1.4500711f - fConst1003));
		fConst1008 = (2.0f * (1.4500711f - fConst981));
		fConst1009 = (((fConst975 + -0.157482162f) / fConst974) + 0.935140193f);
		fConst1010 = (2.0f * (0.935140193f - fConst1003));
		fConst1011 = (2.0f * (0.935140193f - fConst978));
		fConst1012 = std::tan((13208.7695f / fConst0));
		fConst1013 = (1.0f / fConst1012);
		fConst1014 = (1.0f / (((fConst1013 + 0.157482162f) / fConst1012) + 0.935140193f));
		fConst1015 = mydsp_faustpower2_f(fConst1012);
		fConst1016 = (50.0638084f / fConst1015);
		fConst1017 = (fConst1016 + 0.935140193f);
		fConst1018 = (1.0f / (((fConst1013 + 0.743130445f) / fConst1012) + 1.4500711f));
		fConst1019 = (11.0520525f / fConst1015);
		fConst1020 = (fConst1019 + 1.4500711f);
		fConst1021 = (1.0f / (((fConst1013 + 3.18972731f) / fConst1012) + 4.07678175f));
		fConst1022 = (0.00176617282f / fConst1015);
		fConst1023 = (fConst1022 + 0.000407678192f);
		fConst1024 = (1.0f / (((fConst975 + 0.168404877f) / fConst974) + 1.06935835f));
		fConst1025 = (fConst1003 + 53.5361519f);
		fConst1026 = (1.0f / (((fConst975 + 0.51247865f) / fConst974) + 0.689621389f));
		fConst1027 = (fConst1003 + 7.62173128f);
		fConst1028 = (1.0f / (((fConst975 + 0.782413065f) / fConst974) + 0.245291501f));
		fConst1029 = (9.99999975e-05f / fConst977);
		fConst1030 = (fConst1029 + 0.000433227193f);
		fConst1031 = (((fConst975 + -0.782413065f) / fConst974) + 0.245291501f);
		fConst1032 = (2.0f * (0.245291501f - fConst1003));
		fConst1033 = (2.0f * (0.000433227193f - fConst1029));
		fConst1034 = (((fConst975 + -0.51247865f) / fConst974) + 0.689621389f);
		fConst1035 = (2.0f * (0.689621389f - fConst1003));
		fConst1036 = (2.0f * (7.62173128f - fConst1003));
		fConst1037 = (((fConst975 + -0.168404877f) / fConst974) + 1.06935835f);
		fConst1038 = (2.0f * (1.06935835f - fConst1003));
		fConst1039 = (2.0f * (53.5361519f - fConst1003));
		fConst1040 = (((fConst1013 + -3.18972731f) / fConst1012) + 4.07678175f);
		fConst1041 = (1.0f / fConst1015);
		fConst1042 = (2.0f * (4.07678175f - fConst1041));
		fConst1043 = (2.0f * (0.000407678192f - fConst1022));
		fConst1044 = (((fConst1013 + -0.743130445f) / fConst1012) + 1.4500711f);
		fConst1045 = (2.0f * (1.4500711f - fConst1041));
		fConst1046 = (2.0f * (1.4500711f - fConst1019));
		fConst1047 = (((fConst1013 + -0.157482162f) / fConst1012) + 0.935140193f);
		fConst1048 = (2.0f * (0.935140193f - fConst1041));
		fConst1049 = (2.0f * (0.935140193f - fConst1016));
		fConst1050 = std::tan((12467.4189f / fConst0));
		fConst1051 = (1.0f / fConst1050);
		fConst1052 = (1.0f / (((fConst1051 + 0.157482162f) / fConst1050) + 0.935140193f));
		fConst1053 = mydsp_faustpower2_f(fConst1050);
		fConst1054 = (50.0638084f / fConst1053);
		fConst1055 = (fConst1054 + 0.935140193f);
		fConst1056 = (1.0f / (((fConst1051 + 0.743130445f) / fConst1050) + 1.4500711f));
		fConst1057 = (11.0520525f / fConst1053);
		fConst1058 = (fConst1057 + 1.4500711f);
		fConst1059 = (1.0f / (((fConst1051 + 3.18972731f) / fConst1050) + 4.07678175f));
		fConst1060 = (0.00176617282f / fConst1053);
		fConst1061 = (fConst1060 + 0.000407678192f);
		fConst1062 = (1.0f / (((fConst1013 + 0.168404877f) / fConst1012) + 1.06935835f));
		fConst1063 = (fConst1041 + 53.5361519f);
		fConst1064 = (1.0f / (((fConst1013 + 0.51247865f) / fConst1012) + 0.689621389f));
		fConst1065 = (fConst1041 + 7.62173128f);
		fConst1066 = (1.0f / (((fConst1013 + 0.782413065f) / fConst1012) + 0.245291501f));
		fConst1067 = (9.99999975e-05f / fConst1015);
		fConst1068 = (fConst1067 + 0.000433227193f);
		fConst1069 = (((fConst1013 + -0.782413065f) / fConst1012) + 0.245291501f);
		fConst1070 = (2.0f * (0.245291501f - fConst1041));
		fConst1071 = (2.0f * (0.000433227193f - fConst1067));
		fConst1072 = (((fConst1013 + -0.51247865f) / fConst1012) + 0.689621389f);
		fConst1073 = (2.0f * (0.689621389f - fConst1041));
		fConst1074 = (2.0f * (7.62173128f - fConst1041));
		fConst1075 = (((fConst1013 + -0.168404877f) / fConst1012) + 1.06935835f);
		fConst1076 = (2.0f * (1.06935835f - fConst1041));
		fConst1077 = (2.0f * (53.5361519f - fConst1041));
		fConst1078 = (((fConst1051 + -3.18972731f) / fConst1050) + 4.07678175f);
		fConst1079 = (1.0f / fConst1053);
		fConst1080 = (2.0f * (4.07678175f - fConst1079));
		fConst1081 = (2.0f * (0.000407678192f - fConst1060));
		fConst1082 = (((fConst1051 + -0.743130445f) / fConst1050) + 1.4500711f);
		fConst1083 = (2.0f * (1.4500711f - fConst1079));
		fConst1084 = (2.0f * (1.4500711f - fConst1057));
		fConst1085 = (((fConst1051 + -0.157482162f) / fConst1050) + 0.935140193f);
		fConst1086 = (2.0f * (0.935140193f - fConst1079));
		fConst1087 = (2.0f * (0.935140193f - fConst1054));
		fConst1088 = std::tan((11767.6758f / fConst0));
		fConst1089 = (1.0f / fConst1088);
		fConst1090 = (1.0f / (((fConst1089 + 0.157482162f) / fConst1088) + 0.935140193f));
		fConst1091 = mydsp_faustpower2_f(fConst1088);
		fConst1092 = (50.0638084f / fConst1091);
		fConst1093 = (fConst1092 + 0.935140193f);
		fConst1094 = (1.0f / (((fConst1089 + 0.743130445f) / fConst1088) + 1.4500711f));
		fConst1095 = (11.0520525f / fConst1091);
		fConst1096 = (fConst1095 + 1.4500711f);
		fConst1097 = (1.0f / (((fConst1089 + 3.18972731f) / fConst1088) + 4.07678175f));
		fConst1098 = (0.00176617282f / fConst1091);
		fConst1099 = (fConst1098 + 0.000407678192f);
		fConst1100 = (1.0f / (((fConst1051 + 0.168404877f) / fConst1050) + 1.06935835f));
		fConst1101 = (fConst1079 + 53.5361519f);
		fConst1102 = (1.0f / (((fConst1051 + 0.51247865f) / fConst1050) + 0.689621389f));
		fConst1103 = (fConst1079 + 7.62173128f);
		fConst1104 = (1.0f / (((fConst1051 + 0.782413065f) / fConst1050) + 0.245291501f));
		fConst1105 = (9.99999975e-05f / fConst1053);
		fConst1106 = (fConst1105 + 0.000433227193f);
		fConst1107 = (((fConst1051 + -0.782413065f) / fConst1050) + 0.245291501f);
		fConst1108 = (2.0f * (0.245291501f - fConst1079));
		fConst1109 = (2.0f * (0.000433227193f - fConst1105));
		fConst1110 = (((fConst1051 + -0.51247865f) / fConst1050) + 0.689621389f);
		fConst1111 = (2.0f * (0.689621389f - fConst1079));
		fConst1112 = (2.0f * (7.62173128f - fConst1079));
		fConst1113 = (((fConst1051 + -0.168404877f) / fConst1050) + 1.06935835f);
		fConst1114 = (2.0f * (1.06935835f - fConst1079));
		fConst1115 = (2.0f * (53.5361519f - fConst1079));
		fConst1116 = (((fConst1089 + -3.18972731f) / fConst1088) + 4.07678175f);
		fConst1117 = (1.0f / fConst1091);
		fConst1118 = (2.0f * (4.07678175f - fConst1117));
		fConst1119 = (2.0f * (0.000407678192f - fConst1098));
		fConst1120 = (((fConst1089 + -0.743130445f) / fConst1088) + 1.4500711f);
		fConst1121 = (2.0f * (1.4500711f - fConst1117));
		fConst1122 = (2.0f * (1.4500711f - fConst1095));
		fConst1123 = (((fConst1089 + -0.157482162f) / fConst1088) + 0.935140193f);
		fConst1124 = (2.0f * (0.935140193f - fConst1117));
		fConst1125 = (2.0f * (0.935140193f - fConst1092));
		fConst1126 = std::tan((11107.207f / fConst0));
		fConst1127 = (1.0f / fConst1126);
		fConst1128 = (1.0f / (((fConst1127 + 0.157482162f) / fConst1126) + 0.935140193f));
		fConst1129 = mydsp_faustpower2_f(fConst1126);
		fConst1130 = (50.0638084f / fConst1129);
		fConst1131 = (fConst1130 + 0.935140193f);
		fConst1132 = (1.0f / (((fConst1127 + 0.743130445f) / fConst1126) + 1.4500711f));
		fConst1133 = (11.0520525f / fConst1129);
		fConst1134 = (fConst1133 + 1.4500711f);
		fConst1135 = (1.0f / (((fConst1127 + 3.18972731f) / fConst1126) + 4.07678175f));
		fConst1136 = (0.00176617282f / fConst1129);
		fConst1137 = (fConst1136 + 0.000407678192f);
		fConst1138 = (1.0f / (((fConst1089 + 0.168404877f) / fConst1088) + 1.06935835f));
		fConst1139 = (fConst1117 + 53.5361519f);
		fConst1140 = (1.0f / (((fConst1089 + 0.51247865f) / fConst1088) + 0.689621389f));
		fConst1141 = (fConst1117 + 7.62173128f);
		fConst1142 = (1.0f / (((fConst1089 + 0.782413065f) / fConst1088) + 0.245291501f));
		fConst1143 = (9.99999975e-05f / fConst1091);
		fConst1144 = (fConst1143 + 0.000433227193f);
		fConst1145 = (((fConst1089 + -0.782413065f) / fConst1088) + 0.245291501f);
		fConst1146 = (2.0f * (0.245291501f - fConst1117));
		fConst1147 = (2.0f * (0.000433227193f - fConst1143));
		fConst1148 = (((fConst1089 + -0.51247865f) / fConst1088) + 0.689621389f);
		fConst1149 = (2.0f * (0.689621389f - fConst1117));
		fConst1150 = (2.0f * (7.62173128f - fConst1117));
		fConst1151 = (((fConst1089 + -0.168404877f) / fConst1088) + 1.06935835f);
		fConst1152 = (2.0f * (1.06935835f - fConst1117));
		fConst1153 = (2.0f * (53.5361519f - fConst1117));
		fConst1154 = (((fConst1127 + -3.18972731f) / fConst1126) + 4.07678175f);
		fConst1155 = (1.0f / fConst1129);
		fConst1156 = (2.0f * (4.07678175f - fConst1155));
		fConst1157 = (2.0f * (0.000407678192f - fConst1136));
		fConst1158 = (((fConst1127 + -0.743130445f) / fConst1126) + 1.4500711f);
		fConst1159 = (2.0f * (1.4500711f - fConst1155));
		fConst1160 = (2.0f * (1.4500711f - fConst1133));
		fConst1161 = (((fConst1127 + -0.157482162f) / fConst1126) + 0.935140193f);
		fConst1162 = (2.0f * (0.935140193f - fConst1155));
		fConst1163 = (2.0f * (0.935140193f - fConst1130));
		fConst1164 = std::tan((10483.8076f / fConst0));
		fConst1165 = (1.0f / fConst1164);
		fConst1166 = (1.0f / (((fConst1165 + 0.157482162f) / fConst1164) + 0.935140193f));
		fConst1167 = mydsp_faustpower2_f(fConst1164);
		fConst1168 = (50.0638084f / fConst1167);
		fConst1169 = (fConst1168 + 0.935140193f);
		fConst1170 = (1.0f / (((fConst1165 + 0.743130445f) / fConst1164) + 1.4500711f));
		fConst1171 = (11.0520525f / fConst1167);
		fConst1172 = (fConst1171 + 1.4500711f);
		fConst1173 = (1.0f / (((fConst1165 + 3.18972731f) / fConst1164) + 4.07678175f));
		fConst1174 = (0.00176617282f / fConst1167);
		fConst1175 = (fConst1174 + 0.000407678192f);
		fConst1176 = (1.0f / (((fConst1127 + 0.168404877f) / fConst1126) + 1.06935835f));
		fConst1177 = (fConst1155 + 53.5361519f);
		fConst1178 = (1.0f / (((fConst1127 + 0.51247865f) / fConst1126) + 0.689621389f));
		fConst1179 = (fConst1155 + 7.62173128f);
		fConst1180 = (1.0f / (((fConst1127 + 0.782413065f) / fConst1126) + 0.245291501f));
		fConst1181 = (9.99999975e-05f / fConst1129);
		fConst1182 = (fConst1181 + 0.000433227193f);
		fConst1183 = (((fConst1127 + -0.782413065f) / fConst1126) + 0.245291501f);
		fConst1184 = (2.0f * (0.245291501f - fConst1155));
		fConst1185 = (2.0f * (0.000433227193f - fConst1181));
		fConst1186 = (((fConst1127 + -0.51247865f) / fConst1126) + 0.689621389f);
		fConst1187 = (2.0f * (0.689621389f - fConst1155));
		fConst1188 = (2.0f * (7.62173128f - fConst1155));
		fConst1189 = (((fConst1127 + -0.168404877f) / fConst1126) + 1.06935835f);
		fConst1190 = (2.0f * (1.06935835f - fConst1155));
		fConst1191 = (2.0f * (53.5361519f - fConst1155));
		fConst1192 = (((fConst1165 + -3.18972731f) / fConst1164) + 4.07678175f);
		fConst1193 = (1.0f / fConst1167);
		fConst1194 = (2.0f * (4.07678175f - fConst1193));
		fConst1195 = (2.0f * (0.000407678192f - fConst1174));
		fConst1196 = (((fConst1165 + -0.743130445f) / fConst1164) + 1.4500711f);
		fConst1197 = (2.0f * (1.4500711f - fConst1193));
		fConst1198 = (2.0f * (1.4500711f - fConst1171));
		fConst1199 = (((fConst1165 + -0.157482162f) / fConst1164) + 0.935140193f);
		fConst1200 = (2.0f * (0.935140193f - fConst1193));
		fConst1201 = (2.0f * (0.935140193f - fConst1168));
		fConst1202 = std::tan((9895.39648f / fConst0));
		fConst1203 = (1.0f / fConst1202);
		fConst1204 = (1.0f / (((fConst1203 + 0.157482162f) / fConst1202) + 0.935140193f));
		fConst1205 = mydsp_faustpower2_f(fConst1202);
		fConst1206 = (50.0638084f / fConst1205);
		fConst1207 = (fConst1206 + 0.935140193f);
		fConst1208 = (1.0f / (((fConst1203 + 0.743130445f) / fConst1202) + 1.4500711f));
		fConst1209 = (11.0520525f / fConst1205);
		fConst1210 = (fConst1209 + 1.4500711f);
		fConst1211 = (1.0f / (((fConst1203 + 3.18972731f) / fConst1202) + 4.07678175f));
		fConst1212 = (0.00176617282f / fConst1205);
		fConst1213 = (fConst1212 + 0.000407678192f);
		fConst1214 = (1.0f / (((fConst1165 + 0.168404877f) / fConst1164) + 1.06935835f));
		fConst1215 = (fConst1193 + 53.5361519f);
		fConst1216 = (1.0f / (((fConst1165 + 0.51247865f) / fConst1164) + 0.689621389f));
		fConst1217 = (fConst1193 + 7.62173128f);
		fConst1218 = (1.0f / (((fConst1165 + 0.782413065f) / fConst1164) + 0.245291501f));
		fConst1219 = (9.99999975e-05f / fConst1167);
		fConst1220 = (fConst1219 + 0.000433227193f);
		fConst1221 = (((fConst1165 + -0.782413065f) / fConst1164) + 0.245291501f);
		fConst1222 = (2.0f * (0.245291501f - fConst1193));
		fConst1223 = (2.0f * (0.000433227193f - fConst1219));
		fConst1224 = (((fConst1165 + -0.51247865f) / fConst1164) + 0.689621389f);
		fConst1225 = (2.0f * (0.689621389f - fConst1193));
		fConst1226 = (2.0f * (7.62173128f - fConst1193));
		fConst1227 = (((fConst1165 + -0.168404877f) / fConst1164) + 1.06935835f);
		fConst1228 = (2.0f * (1.06935835f - fConst1193));
		fConst1229 = (2.0f * (53.5361519f - fConst1193));
		fConst1230 = (((fConst1203 + -3.18972731f) / fConst1202) + 4.07678175f);
		fConst1231 = (1.0f / fConst1205);
		fConst1232 = (2.0f * (4.07678175f - fConst1231));
		fConst1233 = (2.0f * (0.000407678192f - fConst1212));
		fConst1234 = (((fConst1203 + -0.743130445f) / fConst1202) + 1.4500711f);
		fConst1235 = (2.0f * (1.4500711f - fConst1231));
		fConst1236 = (2.0f * (1.4500711f - fConst1209));
		fConst1237 = (((fConst1203 + -0.157482162f) / fConst1202) + 0.935140193f);
		fConst1238 = (2.0f * (0.935140193f - fConst1231));
		fConst1239 = (2.0f * (0.935140193f - fConst1206));
		fConst1240 = std::tan((9340.01074f / fConst0));
		fConst1241 = (1.0f / fConst1240);
		fConst1242 = (1.0f / (((fConst1241 + 0.157482162f) / fConst1240) + 0.935140193f));
		fConst1243 = mydsp_faustpower2_f(fConst1240);
		fConst1244 = (50.0638084f / fConst1243);
		fConst1245 = (fConst1244 + 0.935140193f);
		fConst1246 = (1.0f / (((fConst1241 + 0.743130445f) / fConst1240) + 1.4500711f));
		fConst1247 = (11.0520525f / fConst1243);
		fConst1248 = (fConst1247 + 1.4500711f);
		fConst1249 = (1.0f / (((fConst1241 + 3.18972731f) / fConst1240) + 4.07678175f));
		fConst1250 = (0.00176617282f / fConst1243);
		fConst1251 = (fConst1250 + 0.000407678192f);
		fConst1252 = (1.0f / (((fConst1203 + 0.168404877f) / fConst1202) + 1.06935835f));
		fConst1253 = (fConst1231 + 53.5361519f);
		fConst1254 = (1.0f / (((fConst1203 + 0.51247865f) / fConst1202) + 0.689621389f));
		fConst1255 = (fConst1231 + 7.62173128f);
		fConst1256 = (1.0f / (((fConst1203 + 0.782413065f) / fConst1202) + 0.245291501f));
		fConst1257 = (9.99999975e-05f / fConst1205);
		fConst1258 = (fConst1257 + 0.000433227193f);
		fConst1259 = (((fConst1203 + -0.782413065f) / fConst1202) + 0.245291501f);
		fConst1260 = (2.0f * (0.245291501f - fConst1231));
		fConst1261 = (2.0f * (0.000433227193f - fConst1257));
		fConst1262 = (((fConst1203 + -0.51247865f) / fConst1202) + 0.689621389f);
		fConst1263 = (2.0f * (0.689621389f - fConst1231));
		fConst1264 = (2.0f * (7.62173128f - fConst1231));
		fConst1265 = (((fConst1203 + -0.168404877f) / fConst1202) + 1.06935835f);
		fConst1266 = (2.0f * (1.06935835f - fConst1231));
		fConst1267 = (2.0f * (53.5361519f - fConst1231));
		fConst1268 = (((fConst1241 + -3.18972731f) / fConst1240) + 4.07678175f);
		fConst1269 = (1.0f / fConst1243);
		fConst1270 = (2.0f * (4.07678175f - fConst1269));
		fConst1271 = (2.0f * (0.000407678192f - fConst1250));
		fConst1272 = (((fConst1241 + -0.743130445f) / fConst1240) + 1.4500711f);
		fConst1273 = (2.0f * (1.4500711f - fConst1269));
		fConst1274 = (2.0f * (1.4500711f - fConst1247));
		fConst1275 = (((fConst1241 + -0.157482162f) / fConst1240) + 0.935140193f);
		fConst1276 = (2.0f * (0.935140193f - fConst1269));
		fConst1277 = (2.0f * (0.935140193f - fConst1244));
		fConst1278 = std::tan((8815.7959f / fConst0));
		fConst1279 = (1.0f / fConst1278);
		fConst1280 = (1.0f / (((fConst1279 + 0.157482162f) / fConst1278) + 0.935140193f));
		fConst1281 = mydsp_faustpower2_f(fConst1278);
		fConst1282 = (50.0638084f / fConst1281);
		fConst1283 = (fConst1282 + 0.935140193f);
		fConst1284 = (1.0f / (((fConst1279 + 0.743130445f) / fConst1278) + 1.4500711f));
		fConst1285 = (11.0520525f / fConst1281);
		fConst1286 = (fConst1285 + 1.4500711f);
		fConst1287 = (1.0f / (((fConst1279 + 3.18972731f) / fConst1278) + 4.07678175f));
		fConst1288 = (0.00176617282f / fConst1281);
		fConst1289 = (fConst1288 + 0.000407678192f);
		fConst1290 = (1.0f / (((fConst1241 + 0.168404877f) / fConst1240) + 1.06935835f));
		fConst1291 = (fConst1269 + 53.5361519f);
		fConst1292 = (1.0f / (((fConst1241 + 0.51247865f) / fConst1240) + 0.689621389f));
		fConst1293 = (fConst1269 + 7.62173128f);
		fConst1294 = (1.0f / (((fConst1241 + 0.782413065f) / fConst1240) + 0.245291501f));
		fConst1295 = (9.99999975e-05f / fConst1243);
		fConst1296 = (fConst1295 + 0.000433227193f);
		fConst1297 = (((fConst1241 + -0.782413065f) / fConst1240) + 0.245291501f);
		fConst1298 = (2.0f * (0.245291501f - fConst1269));
		fConst1299 = (2.0f * (0.000433227193f - fConst1295));
		fConst1300 = (((fConst1241 + -0.51247865f) / fConst1240) + 0.689621389f);
		fConst1301 = (2.0f * (0.689621389f - fConst1269));
		fConst1302 = (2.0f * (7.62173128f - fConst1269));
		fConst1303 = (((fConst1241 + -0.168404877f) / fConst1240) + 1.06935835f);
		fConst1304 = (2.0f * (1.06935835f - fConst1269));
		fConst1305 = (2.0f * (53.5361519f - fConst1269));
		fConst1306 = (((fConst1279 + -3.18972731f) / fConst1278) + 4.07678175f);
		fConst1307 = (1.0f / fConst1281);
		fConst1308 = (2.0f * (4.07678175f - fConst1307));
		fConst1309 = (2.0f * (0.000407678192f - fConst1288));
		fConst1310 = (((fConst1279 + -0.743130445f) / fConst1278) + 1.4500711f);
		fConst1311 = (2.0f * (1.4500711f - fConst1307));
		fConst1312 = (2.0f * (1.4500711f - fConst1285));
		fConst1313 = (((fConst1279 + -0.157482162f) / fConst1278) + 0.935140193f);
		fConst1314 = (2.0f * (0.935140193f - fConst1307));
		fConst1315 = (2.0f * (0.935140193f - fConst1282));
		fConst1316 = std::tan((8321.00391f / fConst0));
		fConst1317 = (1.0f / fConst1316);
		fConst1318 = (1.0f / (((fConst1317 + 0.157482162f) / fConst1316) + 0.935140193f));
		fConst1319 = mydsp_faustpower2_f(fConst1316);
		fConst1320 = (50.0638084f / fConst1319);
		fConst1321 = (fConst1320 + 0.935140193f);
		fConst1322 = (1.0f / (((fConst1317 + 0.743130445f) / fConst1316) + 1.4500711f));
		fConst1323 = (11.0520525f / fConst1319);
		fConst1324 = (fConst1323 + 1.4500711f);
		fConst1325 = (1.0f / (((fConst1317 + 3.18972731f) / fConst1316) + 4.07678175f));
		fConst1326 = (0.00176617282f / fConst1319);
		fConst1327 = (fConst1326 + 0.000407678192f);
		fConst1328 = (1.0f / (((fConst1279 + 0.168404877f) / fConst1278) + 1.06935835f));
		fConst1329 = (fConst1307 + 53.5361519f);
		fConst1330 = (1.0f / (((fConst1279 + 0.51247865f) / fConst1278) + 0.689621389f));
		fConst1331 = (fConst1307 + 7.62173128f);
		fConst1332 = (1.0f / (((fConst1279 + 0.782413065f) / fConst1278) + 0.245291501f));
		fConst1333 = (9.99999975e-05f / fConst1281);
		fConst1334 = (fConst1333 + 0.000433227193f);
		fConst1335 = (((fConst1279 + -0.782413065f) / fConst1278) + 0.245291501f);
		fConst1336 = (2.0f * (0.245291501f - fConst1307));
		fConst1337 = (2.0f * (0.000433227193f - fConst1333));
		fConst1338 = (((fConst1279 + -0.51247865f) / fConst1278) + 0.689621389f);
		fConst1339 = (2.0f * (0.689621389f - fConst1307));
		fConst1340 = (2.0f * (7.62173128f - fConst1307));
		fConst1341 = (((fConst1279 + -0.168404877f) / fConst1278) + 1.06935835f);
		fConst1342 = (2.0f * (1.06935835f - fConst1307));
		fConst1343 = (2.0f * (53.5361519f - fConst1307));
		fConst1344 = (((fConst1317 + -3.18972731f) / fConst1316) + 4.07678175f);
		fConst1345 = (1.0f / fConst1319);
		fConst1346 = (2.0f * (4.07678175f - fConst1345));
		fConst1347 = (2.0f * (0.000407678192f - fConst1326));
		fConst1348 = (((fConst1317 + -0.743130445f) / fConst1316) + 1.4500711f);
		fConst1349 = (2.0f * (1.4500711f - fConst1345));
		fConst1350 = (2.0f * (1.4500711f - fConst1323));
		fConst1351 = (((fConst1317 + -0.157482162f) / fConst1316) + 0.935140193f);
		fConst1352 = (2.0f * (0.935140193f - fConst1345));
		fConst1353 = (2.0f * (0.935140193f - fConst1320));
		fConst1354 = std::tan((7853.98145f / fConst0));
		fConst1355 = (1.0f / fConst1354);
		fConst1356 = (1.0f / (((fConst1355 + 0.157482162f) / fConst1354) + 0.935140193f));
		fConst1357 = mydsp_faustpower2_f(fConst1354);
		fConst1358 = (50.0638084f / fConst1357);
		fConst1359 = (fConst1358 + 0.935140193f);
		fConst1360 = (1.0f / (((fConst1355 + 0.743130445f) / fConst1354) + 1.4500711f));
		fConst1361 = (11.0520525f / fConst1357);
		fConst1362 = (fConst1361 + 1.4500711f);
		fConst1363 = (1.0f / (((fConst1355 + 3.18972731f) / fConst1354) + 4.07678175f));
		fConst1364 = (0.00176617282f / fConst1357);
		fConst1365 = (fConst1364 + 0.000407678192f);
		fConst1366 = (1.0f / (((fConst1317 + 0.168404877f) / fConst1316) + 1.06935835f));
		fConst1367 = (fConst1345 + 53.5361519f);
		fConst1368 = (1.0f / (((fConst1317 + 0.51247865f) / fConst1316) + 0.689621389f));
		fConst1369 = (fConst1345 + 7.62173128f);
		fConst1370 = (1.0f / (((fConst1317 + 0.782413065f) / fConst1316) + 0.245291501f));
		fConst1371 = (9.99999975e-05f / fConst1319);
		fConst1372 = (fConst1371 + 0.000433227193f);
		fConst1373 = (((fConst1317 + -0.782413065f) / fConst1316) + 0.245291501f);
		fConst1374 = (2.0f * (0.245291501f - fConst1345));
		fConst1375 = (2.0f * (0.000433227193f - fConst1371));
		fConst1376 = (((fConst1317 + -0.51247865f) / fConst1316) + 0.689621389f);
		fConst1377 = (2.0f * (0.689621389f - fConst1345));
		fConst1378 = (2.0f * (7.62173128f - fConst1345));
		fConst1379 = (((fConst1317 + -0.168404877f) / fConst1316) + 1.06935835f);
		fConst1380 = (2.0f * (1.06935835f - fConst1345));
		fConst1381 = (2.0f * (53.5361519f - fConst1345));
		fConst1382 = (((fConst1355 + -3.18972731f) / fConst1354) + 4.07678175f);
		fConst1383 = (1.0f / fConst1357);
		fConst1384 = (2.0f * (4.07678175f - fConst1383));
		fConst1385 = (2.0f * (0.000407678192f - fConst1364));
		fConst1386 = (((fConst1355 + -0.743130445f) / fConst1354) + 1.4500711f);
		fConst1387 = (2.0f * (1.4500711f - fConst1383));
		fConst1388 = (2.0f * (1.4500711f - fConst1361));
		fConst1389 = (((fConst1355 + -0.157482162f) / fConst1354) + 0.935140193f);
		fConst1390 = (2.0f * (0.935140193f - fConst1383));
		fConst1391 = (2.0f * (0.935140193f - fConst1358));
		fConst1392 = std::tan((7413.17139f / fConst0));
		fConst1393 = (1.0f / fConst1392);
		fConst1394 = (1.0f / (((fConst1393 + 0.157482162f) / fConst1392) + 0.935140193f));
		fConst1395 = mydsp_faustpower2_f(fConst1392);
		fConst1396 = (50.0638084f / fConst1395);
		fConst1397 = (fConst1396 + 0.935140193f);
		fConst1398 = (1.0f / (((fConst1393 + 0.743130445f) / fConst1392) + 1.4500711f));
		fConst1399 = (11.0520525f / fConst1395);
		fConst1400 = (fConst1399 + 1.4500711f);
		fConst1401 = (1.0f / (((fConst1393 + 3.18972731f) / fConst1392) + 4.07678175f));
		fConst1402 = (0.00176617282f / fConst1395);
		fConst1403 = (fConst1402 + 0.000407678192f);
		fConst1404 = (1.0f / (((fConst1355 + 0.168404877f) / fConst1354) + 1.06935835f));
		fConst1405 = (fConst1383 + 53.5361519f);
		fConst1406 = (1.0f / (((fConst1355 + 0.51247865f) / fConst1354) + 0.689621389f));
		fConst1407 = (fConst1383 + 7.62173128f);
		fConst1408 = (1.0f / (((fConst1355 + 0.782413065f) / fConst1354) + 0.245291501f));
		fConst1409 = (9.99999975e-05f / fConst1357);
		fConst1410 = (fConst1409 + 0.000433227193f);
		fConst1411 = (((fConst1355 + -0.782413065f) / fConst1354) + 0.245291501f);
		fConst1412 = (2.0f * (0.245291501f - fConst1383));
		fConst1413 = (2.0f * (0.000433227193f - fConst1409));
		fConst1414 = (((fConst1355 + -0.51247865f) / fConst1354) + 0.689621389f);
		fConst1415 = (2.0f * (0.689621389f - fConst1383));
		fConst1416 = (2.0f * (7.62173128f - fConst1383));
		fConst1417 = (((fConst1355 + -0.168404877f) / fConst1354) + 1.06935835f);
		fConst1418 = (2.0f * (1.06935835f - fConst1383));
		fConst1419 = (2.0f * (53.5361519f - fConst1383));
		fConst1420 = (((fConst1393 + -3.18972731f) / fConst1392) + 4.07678175f);
		fConst1421 = (1.0f / fConst1395);
		fConst1422 = (2.0f * (4.07678175f - fConst1421));
		fConst1423 = (2.0f * (0.000407678192f - fConst1402));
		fConst1424 = (((fConst1393 + -0.743130445f) / fConst1392) + 1.4500711f);
		fConst1425 = (2.0f * (1.4500711f - fConst1421));
		fConst1426 = (2.0f * (1.4500711f - fConst1399));
		fConst1427 = (((fConst1393 + -0.157482162f) / fConst1392) + 0.935140193f);
		fConst1428 = (2.0f * (0.935140193f - fConst1421));
		fConst1429 = (2.0f * (0.935140193f - fConst1396));
		fConst1430 = std::tan((6997.10205f / fConst0));
		fConst1431 = (1.0f / fConst1430);
		fConst1432 = (1.0f / (((fConst1431 + 0.157482162f) / fConst1430) + 0.935140193f));
		fConst1433 = mydsp_faustpower2_f(fConst1430);
		fConst1434 = (50.0638084f / fConst1433);
		fConst1435 = (fConst1434 + 0.935140193f);
		fConst1436 = (1.0f / (((fConst1431 + 0.743130445f) / fConst1430) + 1.4500711f));
		fConst1437 = (11.0520525f / fConst1433);
		fConst1438 = (fConst1437 + 1.4500711f);
		fConst1439 = (1.0f / (((fConst1431 + 3.18972731f) / fConst1430) + 4.07678175f));
		fConst1440 = (0.00176617282f / fConst1433);
		fConst1441 = (fConst1440 + 0.000407678192f);
		fConst1442 = (1.0f / (((fConst1393 + 0.168404877f) / fConst1392) + 1.06935835f));
		fConst1443 = (fConst1421 + 53.5361519f);
		fConst1444 = (1.0f / (((fConst1393 + 0.51247865f) / fConst1392) + 0.689621389f));
		fConst1445 = (fConst1421 + 7.62173128f);
		fConst1446 = (1.0f / (((fConst1393 + 0.782413065f) / fConst1392) + 0.245291501f));
		fConst1447 = (9.99999975e-05f / fConst1395);
		fConst1448 = (fConst1447 + 0.000433227193f);
		fConst1449 = (((fConst1393 + -0.782413065f) / fConst1392) + 0.245291501f);
		fConst1450 = (2.0f * (0.245291501f - fConst1421));
		fConst1451 = (2.0f * (0.000433227193f - fConst1447));
		fConst1452 = (((fConst1393 + -0.51247865f) / fConst1392) + 0.689621389f);
		fConst1453 = (2.0f * (0.689621389f - fConst1421));
		fConst1454 = (2.0f * (7.62173128f - fConst1421));
		fConst1455 = (((fConst1393 + -0.168404877f) / fConst1392) + 1.06935835f);
		fConst1456 = (2.0f * (1.06935835f - fConst1421));
		fConst1457 = (2.0f * (53.5361519f - fConst1421));
		fConst1458 = (((fConst1431 + -3.18972731f) / fConst1430) + 4.07678175f);
		fConst1459 = (1.0f / fConst1433);
		fConst1460 = (2.0f * (4.07678175f - fConst1459));
		fConst1461 = (2.0f * (0.000407678192f - fConst1440));
		fConst1462 = (((fConst1431 + -0.743130445f) / fConst1430) + 1.4500711f);
		fConst1463 = (2.0f * (1.4500711f - fConst1459));
		fConst1464 = (2.0f * (1.4500711f - fConst1437));
		fConst1465 = (((fConst1431 + -0.157482162f) / fConst1430) + 0.935140193f);
		fConst1466 = (2.0f * (0.935140193f - fConst1459));
		fConst1467 = (2.0f * (0.935140193f - fConst1434));
		fConst1468 = std::tan((6604.38477f / fConst0));
		fConst1469 = (1.0f / fConst1468);
		fConst1470 = (1.0f / (((fConst1469 + 0.157482162f) / fConst1468) + 0.935140193f));
		fConst1471 = mydsp_faustpower2_f(fConst1468);
		fConst1472 = (50.0638084f / fConst1471);
		fConst1473 = (fConst1472 + 0.935140193f);
		fConst1474 = (1.0f / (((fConst1469 + 0.743130445f) / fConst1468) + 1.4500711f));
		fConst1475 = (11.0520525f / fConst1471);
		fConst1476 = (fConst1475 + 1.4500711f);
		fConst1477 = (1.0f / (((fConst1469 + 3.18972731f) / fConst1468) + 4.07678175f));
		fConst1478 = (0.00176617282f / fConst1471);
		fConst1479 = (fConst1478 + 0.000407678192f);
		fConst1480 = (1.0f / (((fConst1431 + 0.168404877f) / fConst1430) + 1.06935835f));
		fConst1481 = (fConst1459 + 53.5361519f);
		fConst1482 = (1.0f / (((fConst1431 + 0.51247865f) / fConst1430) + 0.689621389f));
		fConst1483 = (fConst1459 + 7.62173128f);
		fConst1484 = (1.0f / (((fConst1431 + 0.782413065f) / fConst1430) + 0.245291501f));
		fConst1485 = (9.99999975e-05f / fConst1433);
		fConst1486 = (fConst1485 + 0.000433227193f);
		fConst1487 = (((fConst1431 + -0.782413065f) / fConst1430) + 0.245291501f);
		fConst1488 = (2.0f * (0.245291501f - fConst1459));
		fConst1489 = (2.0f * (0.000433227193f - fConst1485));
		fConst1490 = (((fConst1431 + -0.51247865f) / fConst1430) + 0.689621389f);
		fConst1491 = (2.0f * (0.689621389f - fConst1459));
		fConst1492 = (2.0f * (7.62173128f - fConst1459));
		fConst1493 = (((fConst1431 + -0.168404877f) / fConst1430) + 1.06935835f);
		fConst1494 = (2.0f * (1.06935835f - fConst1459));
		fConst1495 = (2.0f * (53.5361519f - fConst1459));
		fConst1496 = (((fConst1469 + -3.18972731f) / fConst1468) + 4.07678175f);
		fConst1497 = (1.0f / fConst1471);
		fConst1498 = (2.0f * (4.07678175f - fConst1497));
		fConst1499 = (2.0f * (0.000407678192f - fConst1478));
		fConst1500 = (((fConst1469 + -0.743130445f) / fConst1468) + 1.4500711f);
		fConst1501 = (2.0f * (1.4500711f - fConst1497));
		fConst1502 = (2.0f * (1.4500711f - fConst1475));
		fConst1503 = (((fConst1469 + -0.157482162f) / fConst1468) + 0.935140193f);
		fConst1504 = (2.0f * (0.935140193f - fConst1497));
		fConst1505 = (2.0f * (0.935140193f - fConst1472));
		fConst1506 = std::tan((6233.70947f / fConst0));
		fConst1507 = (1.0f / fConst1506);
		fConst1508 = (1.0f / (((fConst1507 + 0.157482162f) / fConst1506) + 0.935140193f));
		fConst1509 = mydsp_faustpower2_f(fConst1506);
		fConst1510 = (50.0638084f / fConst1509);
		fConst1511 = (fConst1510 + 0.935140193f);
		fConst1512 = (1.0f / (((fConst1507 + 0.743130445f) / fConst1506) + 1.4500711f));
		fConst1513 = (11.0520525f / fConst1509);
		fConst1514 = (fConst1513 + 1.4500711f);
		fConst1515 = (1.0f / (((fConst1507 + 3.18972731f) / fConst1506) + 4.07678175f));
		fConst1516 = (0.00176617282f / fConst1509);
		fConst1517 = (fConst1516 + 0.000407678192f);
		fConst1518 = (1.0f / (((fConst1469 + 0.168404877f) / fConst1468) + 1.06935835f));
		fConst1519 = (fConst1497 + 53.5361519f);
		fConst1520 = (1.0f / (((fConst1469 + 0.51247865f) / fConst1468) + 0.689621389f));
		fConst1521 = (fConst1497 + 7.62173128f);
		fConst1522 = (1.0f / (((fConst1469 + 0.782413065f) / fConst1468) + 0.245291501f));
		fConst1523 = (9.99999975e-05f / fConst1471);
		fConst1524 = (fConst1523 + 0.000433227193f);
		fConst1525 = (((fConst1469 + -0.782413065f) / fConst1468) + 0.245291501f);
		fConst1526 = (2.0f * (0.245291501f - fConst1497));
		fConst1527 = (2.0f * (0.000433227193f - fConst1523));
		fConst1528 = (((fConst1469 + -0.51247865f) / fConst1468) + 0.689621389f);
		fConst1529 = (2.0f * (0.689621389f - fConst1497));
		fConst1530 = (2.0f * (7.62173128f - fConst1497));
		fConst1531 = (((fConst1469 + -0.168404877f) / fConst1468) + 1.06935835f);
		fConst1532 = (2.0f * (1.06935835f - fConst1497));
		fConst1533 = (2.0f * (53.5361519f - fConst1497));
		fConst1534 = (((fConst1507 + -3.18972731f) / fConst1506) + 4.07678175f);
		fConst1535 = (1.0f / fConst1509);
		fConst1536 = (2.0f * (4.07678175f - fConst1535));
		fConst1537 = (2.0f * (0.000407678192f - fConst1516));
		fConst1538 = (((fConst1507 + -0.743130445f) / fConst1506) + 1.4500711f);
		fConst1539 = (2.0f * (1.4500711f - fConst1535));
		fConst1540 = (2.0f * (1.4500711f - fConst1513));
		fConst1541 = (((fConst1507 + -0.157482162f) / fConst1506) + 0.935140193f);
		fConst1542 = (2.0f * (0.935140193f - fConst1535));
		fConst1543 = (2.0f * (0.935140193f - fConst1510));
		fConst1544 = std::tan((5883.83789f / fConst0));
		fConst1545 = (1.0f / fConst1544);
		fConst1546 = (1.0f / (((fConst1545 + 0.157482162f) / fConst1544) + 0.935140193f));
		fConst1547 = mydsp_faustpower2_f(fConst1544);
		fConst1548 = (50.0638084f / fConst1547);
		fConst1549 = (fConst1548 + 0.935140193f);
		fConst1550 = (1.0f / (((fConst1545 + 0.743130445f) / fConst1544) + 1.4500711f));
		fConst1551 = (11.0520525f / fConst1547);
		fConst1552 = (fConst1551 + 1.4500711f);
		fConst1553 = (1.0f / (((fConst1545 + 3.18972731f) / fConst1544) + 4.07678175f));
		fConst1554 = (0.00176617282f / fConst1547);
		fConst1555 = (fConst1554 + 0.000407678192f);
		fConst1556 = (1.0f / (((fConst1507 + 0.168404877f) / fConst1506) + 1.06935835f));
		fConst1557 = (fConst1535 + 53.5361519f);
		fConst1558 = (1.0f / (((fConst1507 + 0.51247865f) / fConst1506) + 0.689621389f));
		fConst1559 = (fConst1535 + 7.62173128f);
		fConst1560 = (1.0f / (((fConst1507 + 0.782413065f) / fConst1506) + 0.245291501f));
		fConst1561 = (9.99999975e-05f / fConst1509);
		fConst1562 = (fConst1561 + 0.000433227193f);
		fConst1563 = (((fConst1507 + -0.782413065f) / fConst1506) + 0.245291501f);
		fConst1564 = (2.0f * (0.245291501f - fConst1535));
		fConst1565 = (2.0f * (0.000433227193f - fConst1561));
		fConst1566 = (((fConst1507 + -0.51247865f) / fConst1506) + 0.689621389f);
		fConst1567 = (2.0f * (0.689621389f - fConst1535));
		fConst1568 = (2.0f * (7.62173128f - fConst1535));
		fConst1569 = (((fConst1507 + -0.168404877f) / fConst1506) + 1.06935835f);
		fConst1570 = (2.0f * (1.06935835f - fConst1535));
		fConst1571 = (2.0f * (53.5361519f - fConst1535));
		fConst1572 = (((fConst1545 + -3.18972731f) / fConst1544) + 4.07678175f);
		fConst1573 = (1.0f / fConst1547);
		fConst1574 = (2.0f * (4.07678175f - fConst1573));
		fConst1575 = (2.0f * (0.000407678192f - fConst1554));
		fConst1576 = (((fConst1545 + -0.743130445f) / fConst1544) + 1.4500711f);
		fConst1577 = (2.0f * (1.4500711f - fConst1573));
		fConst1578 = (2.0f * (1.4500711f - fConst1551));
		fConst1579 = (((fConst1545 + -0.157482162f) / fConst1544) + 0.935140193f);
		fConst1580 = (2.0f * (0.935140193f - fConst1573));
		fConst1581 = (2.0f * (0.935140193f - fConst1548));
		fConst1582 = std::tan((5553.60352f / fConst0));
		fConst1583 = (1.0f / fConst1582);
		fConst1584 = (1.0f / (((fConst1583 + 0.157482162f) / fConst1582) + 0.935140193f));
		fConst1585 = mydsp_faustpower2_f(fConst1582);
		fConst1586 = (50.0638084f / fConst1585);
		fConst1587 = (fConst1586 + 0.935140193f);
		fConst1588 = (1.0f / (((fConst1583 + 0.743130445f) / fConst1582) + 1.4500711f));
		fConst1589 = (11.0520525f / fConst1585);
		fConst1590 = (fConst1589 + 1.4500711f);
		fConst1591 = (1.0f / (((fConst1583 + 3.18972731f) / fConst1582) + 4.07678175f));
		fConst1592 = (0.00176617282f / fConst1585);
		fConst1593 = (fConst1592 + 0.000407678192f);
		fConst1594 = (1.0f / (((fConst1545 + 0.168404877f) / fConst1544) + 1.06935835f));
		fConst1595 = (fConst1573 + 53.5361519f);
		fConst1596 = (1.0f / (((fConst1545 + 0.51247865f) / fConst1544) + 0.689621389f));
		fConst1597 = (fConst1573 + 7.62173128f);
		fConst1598 = (1.0f / (((fConst1545 + 0.782413065f) / fConst1544) + 0.245291501f));
		fConst1599 = (9.99999975e-05f / fConst1547);
		fConst1600 = (fConst1599 + 0.000433227193f);
		fConst1601 = (((fConst1545 + -0.782413065f) / fConst1544) + 0.245291501f);
		fConst1602 = (2.0f * (0.245291501f - fConst1573));
		fConst1603 = (2.0f * (0.000433227193f - fConst1599));
		fConst1604 = (((fConst1545 + -0.51247865f) / fConst1544) + 0.689621389f);
		fConst1605 = (2.0f * (0.689621389f - fConst1573));
		fConst1606 = (2.0f * (7.62173128f - fConst1573));
		fConst1607 = (((fConst1545 + -0.168404877f) / fConst1544) + 1.06935835f);
		fConst1608 = (2.0f * (1.06935835f - fConst1573));
		fConst1609 = (2.0f * (53.5361519f - fConst1573));
		fConst1610 = (((fConst1583 + -3.18972731f) / fConst1582) + 4.07678175f);
		fConst1611 = (1.0f / fConst1585);
		fConst1612 = (2.0f * (4.07678175f - fConst1611));
		fConst1613 = (2.0f * (0.000407678192f - fConst1592));
		fConst1614 = (((fConst1583 + -0.743130445f) / fConst1582) + 1.4500711f);
		fConst1615 = (2.0f * (1.4500711f - fConst1611));
		fConst1616 = (2.0f * (1.4500711f - fConst1589));
		fConst1617 = (((fConst1583 + -0.157482162f) / fConst1582) + 0.935140193f);
		fConst1618 = (2.0f * (0.935140193f - fConst1611));
		fConst1619 = (2.0f * (0.935140193f - fConst1586));
		fConst1620 = std::tan((5241.90381f / fConst0));
		fConst1621 = (1.0f / fConst1620);
		fConst1622 = (1.0f / (((fConst1621 + 0.157482162f) / fConst1620) + 0.935140193f));
		fConst1623 = mydsp_faustpower2_f(fConst1620);
		fConst1624 = (50.0638084f / fConst1623);
		fConst1625 = (fConst1624 + 0.935140193f);
		fConst1626 = (1.0f / (((fConst1621 + 0.743130445f) / fConst1620) + 1.4500711f));
		fConst1627 = (11.0520525f / fConst1623);
		fConst1628 = (fConst1627 + 1.4500711f);
		fConst1629 = (1.0f / (((fConst1621 + 3.18972731f) / fConst1620) + 4.07678175f));
		fConst1630 = (0.00176617282f / fConst1623);
		fConst1631 = (fConst1630 + 0.000407678192f);
		fConst1632 = (1.0f / (((fConst1583 + 0.168404877f) / fConst1582) + 1.06935835f));
		fConst1633 = (fConst1611 + 53.5361519f);
		fConst1634 = (1.0f / (((fConst1583 + 0.51247865f) / fConst1582) + 0.689621389f));
		fConst1635 = (fConst1611 + 7.62173128f);
		fConst1636 = (1.0f / (((fConst1583 + 0.782413065f) / fConst1582) + 0.245291501f));
		fConst1637 = (9.99999975e-05f / fConst1585);
		fConst1638 = (fConst1637 + 0.000433227193f);
		fConst1639 = (((fConst1583 + -0.782413065f) / fConst1582) + 0.245291501f);
		fConst1640 = (2.0f * (0.245291501f - fConst1611));
		fConst1641 = (2.0f * (0.000433227193f - fConst1637));
		fConst1642 = (((fConst1583 + -0.51247865f) / fConst1582) + 0.689621389f);
		fConst1643 = (2.0f * (0.689621389f - fConst1611));
		fConst1644 = (2.0f * (7.62173128f - fConst1611));
		fConst1645 = (((fConst1583 + -0.168404877f) / fConst1582) + 1.06935835f);
		fConst1646 = (2.0f * (1.06935835f - fConst1611));
		fConst1647 = (2.0f * (53.5361519f - fConst1611));
		fConst1648 = (((fConst1621 + -3.18972731f) / fConst1620) + 4.07678175f);
		fConst1649 = (1.0f / fConst1623);
		fConst1650 = (2.0f * (4.07678175f - fConst1649));
		fConst1651 = (2.0f * (0.000407678192f - fConst1630));
		fConst1652 = (((fConst1621 + -0.743130445f) / fConst1620) + 1.4500711f);
		fConst1653 = (2.0f * (1.4500711f - fConst1649));
		fConst1654 = (2.0f * (1.4500711f - fConst1627));
		fConst1655 = (((fConst1621 + -0.157482162f) / fConst1620) + 0.935140193f);
		fConst1656 = (2.0f * (0.935140193f - fConst1649));
		fConst1657 = (2.0f * (0.935140193f - fConst1624));
		fConst1658 = std::tan((4947.69824f / fConst0));
		fConst1659 = (1.0f / fConst1658);
		fConst1660 = (1.0f / (((fConst1659 + 0.157482162f) / fConst1658) + 0.935140193f));
		fConst1661 = mydsp_faustpower2_f(fConst1658);
		fConst1662 = (50.0638084f / fConst1661);
		fConst1663 = (fConst1662 + 0.935140193f);
		fConst1664 = (1.0f / (((fConst1659 + 0.743130445f) / fConst1658) + 1.4500711f));
		fConst1665 = (11.0520525f / fConst1661);
		fConst1666 = (fConst1665 + 1.4500711f);
		fConst1667 = (1.0f / (((fConst1659 + 3.18972731f) / fConst1658) + 4.07678175f));
		fConst1668 = (0.00176617282f / fConst1661);
		fConst1669 = (fConst1668 + 0.000407678192f);
		fConst1670 = (1.0f / (((fConst1621 + 0.168404877f) / fConst1620) + 1.06935835f));
		fConst1671 = (fConst1649 + 53.5361519f);
		fConst1672 = (1.0f / (((fConst1621 + 0.51247865f) / fConst1620) + 0.689621389f));
		fConst1673 = (fConst1649 + 7.62173128f);
		fConst1674 = (1.0f / (((fConst1621 + 0.782413065f) / fConst1620) + 0.245291501f));
		fConst1675 = (9.99999975e-05f / fConst1623);
		fConst1676 = (fConst1675 + 0.000433227193f);
		fConst1677 = (((fConst1621 + -0.782413065f) / fConst1620) + 0.245291501f);
		fConst1678 = (2.0f * (0.245291501f - fConst1649));
		fConst1679 = (2.0f * (0.000433227193f - fConst1675));
		fConst1680 = (((fConst1621 + -0.51247865f) / fConst1620) + 0.689621389f);
		fConst1681 = (2.0f * (0.689621389f - fConst1649));
		fConst1682 = (2.0f * (7.62173128f - fConst1649));
		fConst1683 = (((fConst1621 + -0.168404877f) / fConst1620) + 1.06935835f);
		fConst1684 = (2.0f * (1.06935835f - fConst1649));
		fConst1685 = (2.0f * (53.5361519f - fConst1649));
		fConst1686 = (((fConst1659 + -3.18972731f) / fConst1658) + 4.07678175f);
		fConst1687 = (1.0f / fConst1661);
		fConst1688 = (2.0f * (4.07678175f - fConst1687));
		fConst1689 = (2.0f * (0.000407678192f - fConst1668));
		fConst1690 = (((fConst1659 + -0.743130445f) / fConst1658) + 1.4500711f);
		fConst1691 = (2.0f * (1.4500711f - fConst1687));
		fConst1692 = (2.0f * (1.4500711f - fConst1665));
		fConst1693 = (((fConst1659 + -0.157482162f) / fConst1658) + 0.935140193f);
		fConst1694 = (2.0f * (0.935140193f - fConst1687));
		fConst1695 = (2.0f * (0.935140193f - fConst1662));
		fConst1696 = std::tan((4670.00537f / fConst0));
		fConst1697 = (1.0f / fConst1696);
		fConst1698 = (1.0f / (((fConst1697 + 0.157482162f) / fConst1696) + 0.935140193f));
		fConst1699 = mydsp_faustpower2_f(fConst1696);
		fConst1700 = (50.0638084f / fConst1699);
		fConst1701 = (fConst1700 + 0.935140193f);
		fConst1702 = (1.0f / (((fConst1697 + 0.743130445f) / fConst1696) + 1.4500711f));
		fConst1703 = (11.0520525f / fConst1699);
		fConst1704 = (fConst1703 + 1.4500711f);
		fConst1705 = (1.0f / (((fConst1697 + 3.18972731f) / fConst1696) + 4.07678175f));
		fConst1706 = (0.00176617282f / fConst1699);
		fConst1707 = (fConst1706 + 0.000407678192f);
		fConst1708 = (1.0f / (((fConst1659 + 0.168404877f) / fConst1658) + 1.06935835f));
		fConst1709 = (fConst1687 + 53.5361519f);
		fConst1710 = (1.0f / (((fConst1659 + 0.51247865f) / fConst1658) + 0.689621389f));
		fConst1711 = (fConst1687 + 7.62173128f);
		fConst1712 = (1.0f / (((fConst1659 + 0.782413065f) / fConst1658) + 0.245291501f));
		fConst1713 = (9.99999975e-05f / fConst1661);
		fConst1714 = (fConst1713 + 0.000433227193f);
		fConst1715 = (((fConst1659 + -0.782413065f) / fConst1658) + 0.245291501f);
		fConst1716 = (2.0f * (0.245291501f - fConst1687));
		fConst1717 = (2.0f * (0.000433227193f - fConst1713));
		fConst1718 = (((fConst1659 + -0.51247865f) / fConst1658) + 0.689621389f);
		fConst1719 = (2.0f * (0.689621389f - fConst1687));
		fConst1720 = (2.0f * (7.62173128f - fConst1687));
		fConst1721 = (((fConst1659 + -0.168404877f) / fConst1658) + 1.06935835f);
		fConst1722 = (2.0f * (1.06935835f - fConst1687));
		fConst1723 = (2.0f * (53.5361519f - fConst1687));
		fConst1724 = (((fConst1697 + -3.18972731f) / fConst1696) + 4.07678175f);
		fConst1725 = (1.0f / fConst1699);
		fConst1726 = (2.0f * (4.07678175f - fConst1725));
		fConst1727 = (2.0f * (0.000407678192f - fConst1706));
		fConst1728 = (((fConst1697 + -0.743130445f) / fConst1696) + 1.4500711f);
		fConst1729 = (2.0f * (1.4500711f - fConst1725));
		fConst1730 = (2.0f * (1.4500711f - fConst1703));
		fConst1731 = (((fConst1697 + -0.157482162f) / fConst1696) + 0.935140193f);
		fConst1732 = (2.0f * (0.935140193f - fConst1725));
		fConst1733 = (2.0f * (0.935140193f - fConst1700));
		fConst1734 = std::tan((4407.89795f / fConst0));
		fConst1735 = (1.0f / fConst1734);
		fConst1736 = (1.0f / (((fConst1735 + 0.157482162f) / fConst1734) + 0.935140193f));
		fConst1737 = mydsp_faustpower2_f(fConst1734);
		fConst1738 = (50.0638084f / fConst1737);
		fConst1739 = (fConst1738 + 0.935140193f);
		fConst1740 = (1.0f / (((fConst1735 + 0.743130445f) / fConst1734) + 1.4500711f));
		fConst1741 = (11.0520525f / fConst1737);
		fConst1742 = (fConst1741 + 1.4500711f);
		fConst1743 = (1.0f / (((fConst1735 + 3.18972731f) / fConst1734) + 4.07678175f));
		fConst1744 = (0.00176617282f / fConst1737);
		fConst1745 = (fConst1744 + 0.000407678192f);
		fConst1746 = (1.0f / (((fConst1697 + 0.168404877f) / fConst1696) + 1.06935835f));
		fConst1747 = (fConst1725 + 53.5361519f);
		fConst1748 = (1.0f / (((fConst1697 + 0.51247865f) / fConst1696) + 0.689621389f));
		fConst1749 = (fConst1725 + 7.62173128f);
		fConst1750 = (1.0f / (((fConst1697 + 0.782413065f) / fConst1696) + 0.245291501f));
		fConst1751 = (9.99999975e-05f / fConst1699);
		fConst1752 = (fConst1751 + 0.000433227193f);
		fConst1753 = (((fConst1697 + -0.782413065f) / fConst1696) + 0.245291501f);
		fConst1754 = (2.0f * (0.245291501f - fConst1725));
		fConst1755 = (2.0f * (0.000433227193f - fConst1751));
		fConst1756 = (((fConst1697 + -0.51247865f) / fConst1696) + 0.689621389f);
		fConst1757 = (2.0f * (0.689621389f - fConst1725));
		fConst1758 = (2.0f * (7.62173128f - fConst1725));
		fConst1759 = (((fConst1697 + -0.168404877f) / fConst1696) + 1.06935835f);
		fConst1760 = (2.0f * (1.06935835f - fConst1725));
		fConst1761 = (2.0f * (53.5361519f - fConst1725));
		fConst1762 = (((fConst1735 + -3.18972731f) / fConst1734) + 4.07678175f);
		fConst1763 = (1.0f / fConst1737);
		fConst1764 = (2.0f * (4.07678175f - fConst1763));
		fConst1765 = (2.0f * (0.000407678192f - fConst1744));
		fConst1766 = (((fConst1735 + -0.743130445f) / fConst1734) + 1.4500711f);
		fConst1767 = (2.0f * (1.4500711f - fConst1763));
		fConst1768 = (2.0f * (1.4500711f - fConst1741));
		fConst1769 = (((fConst1735 + -0.157482162f) / fConst1734) + 0.935140193f);
		fConst1770 = (2.0f * (0.935140193f - fConst1763));
		fConst1771 = (2.0f * (0.935140193f - fConst1738));
		fConst1772 = std::tan((4160.50195f / fConst0));
		fConst1773 = (1.0f / fConst1772);
		fConst1774 = (1.0f / (((fConst1773 + 0.157482162f) / fConst1772) + 0.935140193f));
		fConst1775 = mydsp_faustpower2_f(fConst1772);
		fConst1776 = (50.0638084f / fConst1775);
		fConst1777 = (fConst1776 + 0.935140193f);
		fConst1778 = (1.0f / (((fConst1773 + 0.743130445f) / fConst1772) + 1.4500711f));
		fConst1779 = (11.0520525f / fConst1775);
		fConst1780 = (fConst1779 + 1.4500711f);
		fConst1781 = (1.0f / (((fConst1773 + 3.18972731f) / fConst1772) + 4.07678175f));
		fConst1782 = (0.00176617282f / fConst1775);
		fConst1783 = (fConst1782 + 0.000407678192f);
		fConst1784 = (1.0f / (((fConst1735 + 0.168404877f) / fConst1734) + 1.06935835f));
		fConst1785 = (fConst1763 + 53.5361519f);
		fConst1786 = (1.0f / (((fConst1735 + 0.51247865f) / fConst1734) + 0.689621389f));
		fConst1787 = (fConst1763 + 7.62173128f);
		fConst1788 = (1.0f / (((fConst1735 + 0.782413065f) / fConst1734) + 0.245291501f));
		fConst1789 = (9.99999975e-05f / fConst1737);
		fConst1790 = (fConst1789 + 0.000433227193f);
		fConst1791 = (((fConst1735 + -0.782413065f) / fConst1734) + 0.245291501f);
		fConst1792 = (2.0f * (0.245291501f - fConst1763));
		fConst1793 = (2.0f * (0.000433227193f - fConst1789));
		fConst1794 = (((fConst1735 + -0.51247865f) / fConst1734) + 0.689621389f);
		fConst1795 = (2.0f * (0.689621389f - fConst1763));
		fConst1796 = (2.0f * (7.62173128f - fConst1763));
		fConst1797 = (((fConst1735 + -0.168404877f) / fConst1734) + 1.06935835f);
		fConst1798 = (2.0f * (1.06935835f - fConst1763));
		fConst1799 = (2.0f * (53.5361519f - fConst1763));
		fConst1800 = (((fConst1773 + -3.18972731f) / fConst1772) + 4.07678175f);
		fConst1801 = (1.0f / fConst1775);
		fConst1802 = (2.0f * (4.07678175f - fConst1801));
		fConst1803 = (2.0f * (0.000407678192f - fConst1782));
		fConst1804 = (((fConst1773 + -0.743130445f) / fConst1772) + 1.4500711f);
		fConst1805 = (2.0f * (1.4500711f - fConst1801));
		fConst1806 = (2.0f * (1.4500711f - fConst1779));
		fConst1807 = (((fConst1773 + -0.157482162f) / fConst1772) + 0.935140193f);
		fConst1808 = (2.0f * (0.935140193f - fConst1801));
		fConst1809 = (2.0f * (0.935140193f - fConst1776));
		fConst1810 = std::tan((3926.99072f / fConst0));
		fConst1811 = (1.0f / fConst1810);
		fConst1812 = (1.0f / (((fConst1811 + 0.157482162f) / fConst1810) + 0.935140193f));
		fConst1813 = mydsp_faustpower2_f(fConst1810);
		fConst1814 = (50.0638084f / fConst1813);
		fConst1815 = (fConst1814 + 0.935140193f);
		fConst1816 = (1.0f / (((fConst1811 + 0.743130445f) / fConst1810) + 1.4500711f));
		fConst1817 = (11.0520525f / fConst1813);
		fConst1818 = (fConst1817 + 1.4500711f);
		fConst1819 = (1.0f / (((fConst1811 + 3.18972731f) / fConst1810) + 4.07678175f));
		fConst1820 = (0.00176617282f / fConst1813);
		fConst1821 = (fConst1820 + 0.000407678192f);
		fConst1822 = (1.0f / (((fConst1773 + 0.168404877f) / fConst1772) + 1.06935835f));
		fConst1823 = (fConst1801 + 53.5361519f);
		fConst1824 = (1.0f / (((fConst1773 + 0.51247865f) / fConst1772) + 0.689621389f));
		fConst1825 = (fConst1801 + 7.62173128f);
		fConst1826 = (1.0f / (((fConst1773 + 0.782413065f) / fConst1772) + 0.245291501f));
		fConst1827 = (9.99999975e-05f / fConst1775);
		fConst1828 = (fConst1827 + 0.000433227193f);
		fConst1829 = (((fConst1773 + -0.782413065f) / fConst1772) + 0.245291501f);
		fConst1830 = (2.0f * (0.245291501f - fConst1801));
		fConst1831 = (2.0f * (0.000433227193f - fConst1827));
		fConst1832 = (((fConst1773 + -0.51247865f) / fConst1772) + 0.689621389f);
		fConst1833 = (2.0f * (0.689621389f - fConst1801));
		fConst1834 = (2.0f * (7.62173128f - fConst1801));
		fConst1835 = (((fConst1773 + -0.168404877f) / fConst1772) + 1.06935835f);
		fConst1836 = (2.0f * (1.06935835f - fConst1801));
		fConst1837 = (2.0f * (53.5361519f - fConst1801));
		fConst1838 = (((fConst1811 + -3.18972731f) / fConst1810) + 4.07678175f);
		fConst1839 = (1.0f / fConst1813);
		fConst1840 = (2.0f * (4.07678175f - fConst1839));
		fConst1841 = (2.0f * (0.000407678192f - fConst1820));
		fConst1842 = (((fConst1811 + -0.743130445f) / fConst1810) + 1.4500711f);
		fConst1843 = (2.0f * (1.4500711f - fConst1839));
		fConst1844 = (2.0f * (1.4500711f - fConst1817));
		fConst1845 = (((fConst1811 + -0.157482162f) / fConst1810) + 0.935140193f);
		fConst1846 = (2.0f * (0.935140193f - fConst1839));
		fConst1847 = (2.0f * (0.935140193f - fConst1814));
		fConst1848 = std::tan((3706.58569f / fConst0));
		fConst1849 = (1.0f / fConst1848);
		fConst1850 = (1.0f / (((fConst1849 + 0.157482162f) / fConst1848) + 0.935140193f));
		fConst1851 = mydsp_faustpower2_f(fConst1848);
		fConst1852 = (50.0638084f / fConst1851);
		fConst1853 = (fConst1852 + 0.935140193f);
		fConst1854 = (1.0f / (((fConst1849 + 0.743130445f) / fConst1848) + 1.4500711f));
		fConst1855 = (11.0520525f / fConst1851);
		fConst1856 = (fConst1855 + 1.4500711f);
		fConst1857 = (1.0f / (((fConst1849 + 3.18972731f) / fConst1848) + 4.07678175f));
		fConst1858 = (0.00176617282f / fConst1851);
		fConst1859 = (fConst1858 + 0.000407678192f);
		fConst1860 = (1.0f / (((fConst1811 + 0.168404877f) / fConst1810) + 1.06935835f));
		fConst1861 = (fConst1839 + 53.5361519f);
		fConst1862 = (1.0f / (((fConst1811 + 0.51247865f) / fConst1810) + 0.689621389f));
		fConst1863 = (fConst1839 + 7.62173128f);
		fConst1864 = (1.0f / (((fConst1811 + 0.782413065f) / fConst1810) + 0.245291501f));
		fConst1865 = (9.99999975e-05f / fConst1813);
		fConst1866 = (fConst1865 + 0.000433227193f);
		fConst1867 = (((fConst1811 + -0.782413065f) / fConst1810) + 0.245291501f);
		fConst1868 = (2.0f * (0.245291501f - fConst1839));
		fConst1869 = (2.0f * (0.000433227193f - fConst1865));
		fConst1870 = (((fConst1811 + -0.51247865f) / fConst1810) + 0.689621389f);
		fConst1871 = (2.0f * (0.689621389f - fConst1839));
		fConst1872 = (2.0f * (7.62173128f - fConst1839));
		fConst1873 = (((fConst1811 + -0.168404877f) / fConst1810) + 1.06935835f);
		fConst1874 = (2.0f * (1.06935835f - fConst1839));
		fConst1875 = (2.0f * (53.5361519f - fConst1839));
		fConst1876 = (((fConst1849 + -3.18972731f) / fConst1848) + 4.07678175f);
		fConst1877 = (1.0f / fConst1851);
		fConst1878 = (2.0f * (4.07678175f - fConst1877));
		fConst1879 = (2.0f * (0.000407678192f - fConst1858));
		fConst1880 = (((fConst1849 + -0.743130445f) / fConst1848) + 1.4500711f);
		fConst1881 = (2.0f * (1.4500711f - fConst1877));
		fConst1882 = (2.0f * (1.4500711f - fConst1855));
		fConst1883 = (((fConst1849 + -0.157482162f) / fConst1848) + 0.935140193f);
		fConst1884 = (2.0f * (0.935140193f - fConst1877));
		fConst1885 = (2.0f * (0.935140193f - fConst1852));
		fConst1886 = std::tan((3498.55103f / fConst0));
		fConst1887 = (1.0f / fConst1886);
		fConst1888 = (1.0f / (((fConst1887 + 0.157482162f) / fConst1886) + 0.935140193f));
		fConst1889 = mydsp_faustpower2_f(fConst1886);
		fConst1890 = (50.0638084f / fConst1889);
		fConst1891 = (fConst1890 + 0.935140193f);
		fConst1892 = (1.0f / (((fConst1887 + 0.743130445f) / fConst1886) + 1.4500711f));
		fConst1893 = (11.0520525f / fConst1889);
		fConst1894 = (fConst1893 + 1.4500711f);
		fConst1895 = (1.0f / (((fConst1887 + 3.18972731f) / fConst1886) + 4.07678175f));
		fConst1896 = (0.00176617282f / fConst1889);
		fConst1897 = (fConst1896 + 0.000407678192f);
		fConst1898 = (1.0f / (((fConst1849 + 0.168404877f) / fConst1848) + 1.06935835f));
		fConst1899 = (fConst1877 + 53.5361519f);
		fConst1900 = (1.0f / (((fConst1849 + 0.51247865f) / fConst1848) + 0.689621389f));
		fConst1901 = (fConst1877 + 7.62173128f);
		fConst1902 = (1.0f / (((fConst1849 + 0.782413065f) / fConst1848) + 0.245291501f));
		fConst1903 = (9.99999975e-05f / fConst1851);
		fConst1904 = (fConst1903 + 0.000433227193f);
		fConst1905 = (((fConst1849 + -0.782413065f) / fConst1848) + 0.245291501f);
		fConst1906 = (2.0f * (0.245291501f - fConst1877));
		fConst1907 = (2.0f * (0.000433227193f - fConst1903));
		fConst1908 = (((fConst1849 + -0.51247865f) / fConst1848) + 0.689621389f);
		fConst1909 = (2.0f * (0.689621389f - fConst1877));
		fConst1910 = (2.0f * (7.62173128f - fConst1877));
		fConst1911 = (((fConst1849 + -0.168404877f) / fConst1848) + 1.06935835f);
		fConst1912 = (2.0f * (1.06935835f - fConst1877));
		fConst1913 = (2.0f * (53.5361519f - fConst1877));
		fConst1914 = (((fConst1887 + -3.18972731f) / fConst1886) + 4.07678175f);
		fConst1915 = (1.0f / fConst1889);
		fConst1916 = (2.0f * (4.07678175f - fConst1915));
		fConst1917 = (2.0f * (0.000407678192f - fConst1896));
		fConst1918 = (((fConst1887 + -0.743130445f) / fConst1886) + 1.4500711f);
		fConst1919 = (2.0f * (1.4500711f - fConst1915));
		fConst1920 = (2.0f * (1.4500711f - fConst1893));
		fConst1921 = (((fConst1887 + -0.157482162f) / fConst1886) + 0.935140193f);
		fConst1922 = (2.0f * (0.935140193f - fConst1915));
		fConst1923 = (2.0f * (0.935140193f - fConst1890));
		fConst1924 = std::tan((3302.19238f / fConst0));
		fConst1925 = (1.0f / fConst1924);
		fConst1926 = (1.0f / (((fConst1925 + 0.157482162f) / fConst1924) + 0.935140193f));
		fConst1927 = mydsp_faustpower2_f(fConst1924);
		fConst1928 = (50.0638084f / fConst1927);
		fConst1929 = (fConst1928 + 0.935140193f);
		fConst1930 = (1.0f / (((fConst1925 + 0.743130445f) / fConst1924) + 1.4500711f));
		fConst1931 = (11.0520525f / fConst1927);
		fConst1932 = (fConst1931 + 1.4500711f);
		fConst1933 = (1.0f / (((fConst1925 + 3.18972731f) / fConst1924) + 4.07678175f));
		fConst1934 = (0.00176617282f / fConst1927);
		fConst1935 = (fConst1934 + 0.000407678192f);
		fConst1936 = (1.0f / (((fConst1887 + 0.168404877f) / fConst1886) + 1.06935835f));
		fConst1937 = (fConst1915 + 53.5361519f);
		fConst1938 = (1.0f / (((fConst1887 + 0.51247865f) / fConst1886) + 0.689621389f));
		fConst1939 = (fConst1915 + 7.62173128f);
		fConst1940 = (1.0f / (((fConst1887 + 0.782413065f) / fConst1886) + 0.245291501f));
		fConst1941 = (9.99999975e-05f / fConst1889);
		fConst1942 = (fConst1941 + 0.000433227193f);
		fConst1943 = (((fConst1887 + -0.782413065f) / fConst1886) + 0.245291501f);
		fConst1944 = (2.0f * (0.245291501f - fConst1915));
		fConst1945 = (2.0f * (0.000433227193f - fConst1941));
		fConst1946 = (((fConst1887 + -0.51247865f) / fConst1886) + 0.689621389f);
		fConst1947 = (2.0f * (0.689621389f - fConst1915));
		fConst1948 = (2.0f * (7.62173128f - fConst1915));
		fConst1949 = (((fConst1887 + -0.168404877f) / fConst1886) + 1.06935835f);
		fConst1950 = (2.0f * (1.06935835f - fConst1915));
		fConst1951 = (2.0f * (53.5361519f - fConst1915));
		fConst1952 = (((fConst1925 + -3.18972731f) / fConst1924) + 4.07678175f);
		fConst1953 = (1.0f / fConst1927);
		fConst1954 = (2.0f * (4.07678175f - fConst1953));
		fConst1955 = (2.0f * (0.000407678192f - fConst1934));
		fConst1956 = (((fConst1925 + -0.743130445f) / fConst1924) + 1.4500711f);
		fConst1957 = (2.0f * (1.4500711f - fConst1953));
		fConst1958 = (2.0f * (1.4500711f - fConst1931));
		fConst1959 = (((fConst1925 + -0.157482162f) / fConst1924) + 0.935140193f);
		fConst1960 = (2.0f * (0.935140193f - fConst1953));
		fConst1961 = (2.0f * (0.935140193f - fConst1928));
		fConst1962 = std::tan((3116.85474f / fConst0));
		fConst1963 = (1.0f / fConst1962);
		fConst1964 = (1.0f / (((fConst1963 + 0.157482162f) / fConst1962) + 0.935140193f));
		fConst1965 = mydsp_faustpower2_f(fConst1962);
		fConst1966 = (50.0638084f / fConst1965);
		fConst1967 = (fConst1966 + 0.935140193f);
		fConst1968 = (1.0f / (((fConst1963 + 0.743130445f) / fConst1962) + 1.4500711f));
		fConst1969 = (11.0520525f / fConst1965);
		fConst1970 = (fConst1969 + 1.4500711f);
		fConst1971 = (1.0f / (((fConst1963 + 3.18972731f) / fConst1962) + 4.07678175f));
		fConst1972 = (0.00176617282f / fConst1965);
		fConst1973 = (fConst1972 + 0.000407678192f);
		fConst1974 = (1.0f / (((fConst1925 + 0.168404877f) / fConst1924) + 1.06935835f));
		fConst1975 = (fConst1953 + 53.5361519f);
		fConst1976 = (1.0f / (((fConst1925 + 0.51247865f) / fConst1924) + 0.689621389f));
		fConst1977 = (fConst1953 + 7.62173128f);
		fConst1978 = (1.0f / (((fConst1925 + 0.782413065f) / fConst1924) + 0.245291501f));
		fConst1979 = (9.99999975e-05f / fConst1927);
		fConst1980 = (fConst1979 + 0.000433227193f);
		fConst1981 = (((fConst1925 + -0.782413065f) / fConst1924) + 0.245291501f);
		fConst1982 = (2.0f * (0.245291501f - fConst1953));
		fConst1983 = (2.0f * (0.000433227193f - fConst1979));
		fConst1984 = (((fConst1925 + -0.51247865f) / fConst1924) + 0.689621389f);
		fConst1985 = (2.0f * (0.689621389f - fConst1953));
		fConst1986 = (2.0f * (7.62173128f - fConst1953));
		fConst1987 = (((fConst1925 + -0.168404877f) / fConst1924) + 1.06935835f);
		fConst1988 = (2.0f * (1.06935835f - fConst1953));
		fConst1989 = (2.0f * (53.5361519f - fConst1953));
		fConst1990 = (((fConst1963 + -3.18972731f) / fConst1962) + 4.07678175f);
		fConst1991 = (1.0f / fConst1965);
		fConst1992 = (2.0f * (4.07678175f - fConst1991));
		fConst1993 = (2.0f * (0.000407678192f - fConst1972));
		fConst1994 = (((fConst1963 + -0.743130445f) / fConst1962) + 1.4500711f);
		fConst1995 = (2.0f * (1.4500711f - fConst1991));
		fConst1996 = (2.0f * (1.4500711f - fConst1969));
		fConst1997 = (((fConst1963 + -0.157482162f) / fConst1962) + 0.935140193f);
		fConst1998 = (2.0f * (0.935140193f - fConst1991));
		fConst1999 = (2.0f * (0.935140193f - fConst1966));
		fConst2000 = std::tan((2941.91895f / fConst0));
		fConst2001 = (1.0f / fConst2000);
		fConst2002 = (1.0f / (((fConst2001 + 0.157482162f) / fConst2000) + 0.935140193f));
		fConst2003 = mydsp_faustpower2_f(fConst2000);
		fConst2004 = (50.0638084f / fConst2003);
		fConst2005 = (fConst2004 + 0.935140193f);
		fConst2006 = (1.0f / (((fConst2001 + 0.743130445f) / fConst2000) + 1.4500711f));
		fConst2007 = (11.0520525f / fConst2003);
		fConst2008 = (fConst2007 + 1.4500711f);
		fConst2009 = (1.0f / (((fConst2001 + 3.18972731f) / fConst2000) + 4.07678175f));
		fConst2010 = (0.00176617282f / fConst2003);
		fConst2011 = (fConst2010 + 0.000407678192f);
		fConst2012 = (1.0f / (((fConst1963 + 0.168404877f) / fConst1962) + 1.06935835f));
		fConst2013 = (fConst1991 + 53.5361519f);
		fConst2014 = (1.0f / (((fConst1963 + 0.51247865f) / fConst1962) + 0.689621389f));
		fConst2015 = (fConst1991 + 7.62173128f);
		fConst2016 = (1.0f / (((fConst1963 + 0.782413065f) / fConst1962) + 0.245291501f));
		fConst2017 = (9.99999975e-05f / fConst1965);
		fConst2018 = (fConst2017 + 0.000433227193f);
		fConst2019 = (((fConst1963 + -0.782413065f) / fConst1962) + 0.245291501f);
		fConst2020 = (2.0f * (0.245291501f - fConst1991));
		fConst2021 = (2.0f * (0.000433227193f - fConst2017));
		fConst2022 = (((fConst1963 + -0.51247865f) / fConst1962) + 0.689621389f);
		fConst2023 = (2.0f * (0.689621389f - fConst1991));
		fConst2024 = (2.0f * (7.62173128f - fConst1991));
		fConst2025 = (((fConst1963 + -0.168404877f) / fConst1962) + 1.06935835f);
		fConst2026 = (2.0f * (1.06935835f - fConst1991));
		fConst2027 = (2.0f * (53.5361519f - fConst1991));
		fConst2028 = (((fConst2001 + -3.18972731f) / fConst2000) + 4.07678175f);
		fConst2029 = (1.0f / fConst2003);
		fConst2030 = (2.0f * (4.07678175f - fConst2029));
		fConst2031 = (2.0f * (0.000407678192f - fConst2010));
		fConst2032 = (((fConst2001 + -0.743130445f) / fConst2000) + 1.4500711f);
		fConst2033 = (2.0f * (1.4500711f - fConst2029));
		fConst2034 = (2.0f * (1.4500711f - fConst2007));
		fConst2035 = (((fConst2001 + -0.157482162f) / fConst2000) + 0.935140193f);
		fConst2036 = (2.0f * (0.935140193f - fConst2029));
		fConst2037 = (2.0f * (0.935140193f - fConst2004));
		fConst2038 = std::tan((2776.80176f / fConst0));
		fConst2039 = (1.0f / fConst2038);
		fConst2040 = (1.0f / (((fConst2039 + 0.157482162f) / fConst2038) + 0.935140193f));
		fConst2041 = mydsp_faustpower2_f(fConst2038);
		fConst2042 = (50.0638084f / fConst2041);
		fConst2043 = (fConst2042 + 0.935140193f);
		fConst2044 = (1.0f / (((fConst2039 + 0.743130445f) / fConst2038) + 1.4500711f));
		fConst2045 = (11.0520525f / fConst2041);
		fConst2046 = (fConst2045 + 1.4500711f);
		fConst2047 = (1.0f / (((fConst2039 + 3.18972731f) / fConst2038) + 4.07678175f));
		fConst2048 = (0.00176617282f / fConst2041);
		fConst2049 = (fConst2048 + 0.000407678192f);
		fConst2050 = (1.0f / (((fConst2001 + 0.168404877f) / fConst2000) + 1.06935835f));
		fConst2051 = (fConst2029 + 53.5361519f);
		fConst2052 = (1.0f / (((fConst2001 + 0.51247865f) / fConst2000) + 0.689621389f));
		fConst2053 = (fConst2029 + 7.62173128f);
		fConst2054 = (1.0f / (((fConst2001 + 0.782413065f) / fConst2000) + 0.245291501f));
		fConst2055 = (9.99999975e-05f / fConst2003);
		fConst2056 = (fConst2055 + 0.000433227193f);
		fConst2057 = (((fConst2001 + -0.782413065f) / fConst2000) + 0.245291501f);
		fConst2058 = (2.0f * (0.245291501f - fConst2029));
		fConst2059 = (2.0f * (0.000433227193f - fConst2055));
		fConst2060 = (((fConst2001 + -0.51247865f) / fConst2000) + 0.689621389f);
		fConst2061 = (2.0f * (0.689621389f - fConst2029));
		fConst2062 = (2.0f * (7.62173128f - fConst2029));
		fConst2063 = (((fConst2001 + -0.168404877f) / fConst2000) + 1.06935835f);
		fConst2064 = (2.0f * (1.06935835f - fConst2029));
		fConst2065 = (2.0f * (53.5361519f - fConst2029));
		fConst2066 = (((fConst2039 + -3.18972731f) / fConst2038) + 4.07678175f);
		fConst2067 = (1.0f / fConst2041);
		fConst2068 = (2.0f * (4.07678175f - fConst2067));
		fConst2069 = (2.0f * (0.000407678192f - fConst2048));
		fConst2070 = (((fConst2039 + -0.743130445f) / fConst2038) + 1.4500711f);
		fConst2071 = (2.0f * (1.4500711f - fConst2067));
		fConst2072 = (2.0f * (1.4500711f - fConst2045));
		fConst2073 = (((fConst2039 + -0.157482162f) / fConst2038) + 0.935140193f);
		fConst2074 = (2.0f * (0.935140193f - fConst2067));
		fConst2075 = (2.0f * (0.935140193f - fConst2042));
		fConst2076 = std::tan((2620.9519f / fConst0));
		fConst2077 = (1.0f / fConst2076);
		fConst2078 = (1.0f / (((fConst2077 + 0.157482162f) / fConst2076) + 0.935140193f));
		fConst2079 = mydsp_faustpower2_f(fConst2076);
		fConst2080 = (50.0638084f / fConst2079);
		fConst2081 = (fConst2080 + 0.935140193f);
		fConst2082 = (1.0f / (((fConst2077 + 0.743130445f) / fConst2076) + 1.4500711f));
		fConst2083 = (11.0520525f / fConst2079);
		fConst2084 = (fConst2083 + 1.4500711f);
		fConst2085 = (1.0f / (((fConst2077 + 3.18972731f) / fConst2076) + 4.07678175f));
		fConst2086 = (0.00176617282f / fConst2079);
		fConst2087 = (fConst2086 + 0.000407678192f);
		fConst2088 = (1.0f / (((fConst2039 + 0.168404877f) / fConst2038) + 1.06935835f));
		fConst2089 = (fConst2067 + 53.5361519f);
		fConst2090 = (1.0f / (((fConst2039 + 0.51247865f) / fConst2038) + 0.689621389f));
		fConst2091 = (fConst2067 + 7.62173128f);
		fConst2092 = (1.0f / (((fConst2039 + 0.782413065f) / fConst2038) + 0.245291501f));
		fConst2093 = (9.99999975e-05f / fConst2041);
		fConst2094 = (fConst2093 + 0.000433227193f);
		fConst2095 = (((fConst2039 + -0.782413065f) / fConst2038) + 0.245291501f);
		fConst2096 = (2.0f * (0.245291501f - fConst2067));
		fConst2097 = (2.0f * (0.000433227193f - fConst2093));
		fConst2098 = (((fConst2039 + -0.51247865f) / fConst2038) + 0.689621389f);
		fConst2099 = (2.0f * (0.689621389f - fConst2067));
		fConst2100 = (2.0f * (7.62173128f - fConst2067));
		fConst2101 = (((fConst2039 + -0.168404877f) / fConst2038) + 1.06935835f);
		fConst2102 = (2.0f * (1.06935835f - fConst2067));
		fConst2103 = (2.0f * (53.5361519f - fConst2067));
		fConst2104 = (((fConst2077 + -3.18972731f) / fConst2076) + 4.07678175f);
		fConst2105 = (1.0f / fConst2079);
		fConst2106 = (2.0f * (4.07678175f - fConst2105));
		fConst2107 = (2.0f * (0.000407678192f - fConst2086));
		fConst2108 = (((fConst2077 + -0.743130445f) / fConst2076) + 1.4500711f);
		fConst2109 = (2.0f * (1.4500711f - fConst2105));
		fConst2110 = (2.0f * (1.4500711f - fConst2083));
		fConst2111 = (((fConst2077 + -0.157482162f) / fConst2076) + 0.935140193f);
		fConst2112 = (2.0f * (0.935140193f - fConst2105));
		fConst2113 = (2.0f * (0.935140193f - fConst2080));
		fConst2114 = std::tan((2473.84912f / fConst0));
		fConst2115 = (1.0f / fConst2114);
		fConst2116 = (1.0f / (((fConst2115 + 0.157482162f) / fConst2114) + 0.935140193f));
		fConst2117 = mydsp_faustpower2_f(fConst2114);
		fConst2118 = (50.0638084f / fConst2117);
		fConst2119 = (fConst2118 + 0.935140193f);
		fConst2120 = (1.0f / (((fConst2115 + 0.743130445f) / fConst2114) + 1.4500711f));
		fConst2121 = (11.0520525f / fConst2117);
		fConst2122 = (fConst2121 + 1.4500711f);
		fConst2123 = (1.0f / (((fConst2115 + 3.18972731f) / fConst2114) + 4.07678175f));
		fConst2124 = (0.00176617282f / fConst2117);
		fConst2125 = (fConst2124 + 0.000407678192f);
		fConst2126 = (1.0f / (((fConst2077 + 0.168404877f) / fConst2076) + 1.06935835f));
		fConst2127 = (fConst2105 + 53.5361519f);
		fConst2128 = (1.0f / (((fConst2077 + 0.51247865f) / fConst2076) + 0.689621389f));
		fConst2129 = (fConst2105 + 7.62173128f);
		fConst2130 = (1.0f / (((fConst2077 + 0.782413065f) / fConst2076) + 0.245291501f));
		fConst2131 = (9.99999975e-05f / fConst2079);
		fConst2132 = (fConst2131 + 0.000433227193f);
		fConst2133 = (((fConst2077 + -0.782413065f) / fConst2076) + 0.245291501f);
		fConst2134 = (2.0f * (0.245291501f - fConst2105));
		fConst2135 = (2.0f * (0.000433227193f - fConst2131));
		fConst2136 = (((fConst2077 + -0.51247865f) / fConst2076) + 0.689621389f);
		fConst2137 = (2.0f * (0.689621389f - fConst2105));
		fConst2138 = (2.0f * (7.62173128f - fConst2105));
		fConst2139 = (((fConst2077 + -0.168404877f) / fConst2076) + 1.06935835f);
		fConst2140 = (2.0f * (1.06935835f - fConst2105));
		fConst2141 = (2.0f * (53.5361519f - fConst2105));
		fConst2142 = (((fConst2115 + -3.18972731f) / fConst2114) + 4.07678175f);
		fConst2143 = (1.0f / fConst2117);
		fConst2144 = (2.0f * (4.07678175f - fConst2143));
		fConst2145 = (2.0f * (0.000407678192f - fConst2124));
		fConst2146 = (((fConst2115 + -0.743130445f) / fConst2114) + 1.4500711f);
		fConst2147 = (2.0f * (1.4500711f - fConst2143));
		fConst2148 = (2.0f * (1.4500711f - fConst2121));
		fConst2149 = (((fConst2115 + -0.157482162f) / fConst2114) + 0.935140193f);
		fConst2150 = (2.0f * (0.935140193f - fConst2143));
		fConst2151 = (2.0f * (0.935140193f - fConst2118));
		fConst2152 = std::tan((2335.00269f / fConst0));
		fConst2153 = (1.0f / fConst2152);
		fConst2154 = (1.0f / (((fConst2153 + 0.157482162f) / fConst2152) + 0.935140193f));
		fConst2155 = mydsp_faustpower2_f(fConst2152);
		fConst2156 = (50.0638084f / fConst2155);
		fConst2157 = (fConst2156 + 0.935140193f);
		fConst2158 = (1.0f / (((fConst2153 + 0.743130445f) / fConst2152) + 1.4500711f));
		fConst2159 = (11.0520525f / fConst2155);
		fConst2160 = (fConst2159 + 1.4500711f);
		fConst2161 = (1.0f / (((fConst2153 + 3.18972731f) / fConst2152) + 4.07678175f));
		fConst2162 = (0.00176617282f / fConst2155);
		fConst2163 = (fConst2162 + 0.000407678192f);
		fConst2164 = (1.0f / (((fConst2115 + 0.168404877f) / fConst2114) + 1.06935835f));
		fConst2165 = (fConst2143 + 53.5361519f);
		fConst2166 = (1.0f / (((fConst2115 + 0.51247865f) / fConst2114) + 0.689621389f));
		fConst2167 = (fConst2143 + 7.62173128f);
		fConst2168 = (1.0f / (((fConst2115 + 0.782413065f) / fConst2114) + 0.245291501f));
		fConst2169 = (9.99999975e-05f / fConst2117);
		fConst2170 = (fConst2169 + 0.000433227193f);
		fConst2171 = (((fConst2115 + -0.782413065f) / fConst2114) + 0.245291501f);
		fConst2172 = (2.0f * (0.245291501f - fConst2143));
		fConst2173 = (2.0f * (0.000433227193f - fConst2169));
		fConst2174 = (((fConst2115 + -0.51247865f) / fConst2114) + 0.689621389f);
		fConst2175 = (2.0f * (0.689621389f - fConst2143));
		fConst2176 = (2.0f * (7.62173128f - fConst2143));
		fConst2177 = (((fConst2115 + -0.168404877f) / fConst2114) + 1.06935835f);
		fConst2178 = (2.0f * (1.06935835f - fConst2143));
		fConst2179 = (2.0f * (53.5361519f - fConst2143));
		fConst2180 = (((fConst2153 + -3.18972731f) / fConst2152) + 4.07678175f);
		fConst2181 = (1.0f / fConst2155);
		fConst2182 = (2.0f * (4.07678175f - fConst2181));
		fConst2183 = (2.0f * (0.000407678192f - fConst2162));
		fConst2184 = (((fConst2153 + -0.743130445f) / fConst2152) + 1.4500711f);
		fConst2185 = (2.0f * (1.4500711f - fConst2181));
		fConst2186 = (2.0f * (1.4500711f - fConst2159));
		fConst2187 = (((fConst2153 + -0.157482162f) / fConst2152) + 0.935140193f);
		fConst2188 = (2.0f * (0.935140193f - fConst2181));
		fConst2189 = (2.0f * (0.935140193f - fConst2156));
		fConst2190 = std::tan((2203.94897f / fConst0));
		fConst2191 = (1.0f / fConst2190);
		fConst2192 = (1.0f / (((fConst2191 + 0.157482162f) / fConst2190) + 0.935140193f));
		fConst2193 = mydsp_faustpower2_f(fConst2190);
		fConst2194 = (50.0638084f / fConst2193);
		fConst2195 = (fConst2194 + 0.935140193f);
		fConst2196 = (1.0f / (((fConst2191 + 0.743130445f) / fConst2190) + 1.4500711f));
		fConst2197 = (11.0520525f / fConst2193);
		fConst2198 = (fConst2197 + 1.4500711f);
		fConst2199 = (1.0f / (((fConst2191 + 3.18972731f) / fConst2190) + 4.07678175f));
		fConst2200 = (0.00176617282f / fConst2193);
		fConst2201 = (fConst2200 + 0.000407678192f);
		fConst2202 = (1.0f / (((fConst2153 + 0.168404877f) / fConst2152) + 1.06935835f));
		fConst2203 = (fConst2181 + 53.5361519f);
		fConst2204 = (1.0f / (((fConst2153 + 0.51247865f) / fConst2152) + 0.689621389f));
		fConst2205 = (fConst2181 + 7.62173128f);
		fConst2206 = (1.0f / (((fConst2153 + 0.782413065f) / fConst2152) + 0.245291501f));
		fConst2207 = (9.99999975e-05f / fConst2155);
		fConst2208 = (fConst2207 + 0.000433227193f);
		fConst2209 = (((fConst2153 + -0.782413065f) / fConst2152) + 0.245291501f);
		fConst2210 = (2.0f * (0.245291501f - fConst2181));
		fConst2211 = (2.0f * (0.000433227193f - fConst2207));
		fConst2212 = (((fConst2153 + -0.51247865f) / fConst2152) + 0.689621389f);
		fConst2213 = (2.0f * (0.689621389f - fConst2181));
		fConst2214 = (2.0f * (7.62173128f - fConst2181));
		fConst2215 = (((fConst2153 + -0.168404877f) / fConst2152) + 1.06935835f);
		fConst2216 = (2.0f * (1.06935835f - fConst2181));
		fConst2217 = (2.0f * (53.5361519f - fConst2181));
		fConst2218 = (((fConst2191 + -3.18972731f) / fConst2190) + 4.07678175f);
		fConst2219 = (1.0f / fConst2193);
		fConst2220 = (2.0f * (4.07678175f - fConst2219));
		fConst2221 = (2.0f * (0.000407678192f - fConst2200));
		fConst2222 = (((fConst2191 + -0.743130445f) / fConst2190) + 1.4500711f);
		fConst2223 = (2.0f * (1.4500711f - fConst2219));
		fConst2224 = (2.0f * (1.4500711f - fConst2197));
		fConst2225 = (((fConst2191 + -0.157482162f) / fConst2190) + 0.935140193f);
		fConst2226 = (2.0f * (0.935140193f - fConst2219));
		fConst2227 = (2.0f * (0.935140193f - fConst2194));
		fConst2228 = std::tan((2080.25098f / fConst0));
		fConst2229 = (1.0f / fConst2228);
		fConst2230 = (1.0f / (((fConst2229 + 0.157482162f) / fConst2228) + 0.935140193f));
		fConst2231 = mydsp_faustpower2_f(fConst2228);
		fConst2232 = (50.0638084f / fConst2231);
		fConst2233 = (fConst2232 + 0.935140193f);
		fConst2234 = (1.0f / (((fConst2229 + 0.743130445f) / fConst2228) + 1.4500711f));
		fConst2235 = (11.0520525f / fConst2231);
		fConst2236 = (fConst2235 + 1.4500711f);
		fConst2237 = (1.0f / (((fConst2229 + 3.18972731f) / fConst2228) + 4.07678175f));
		fConst2238 = (0.00176617282f / fConst2231);
		fConst2239 = (fConst2238 + 0.000407678192f);
		fConst2240 = (1.0f / (((fConst2191 + 0.168404877f) / fConst2190) + 1.06935835f));
		fConst2241 = (fConst2219 + 53.5361519f);
		fConst2242 = (1.0f / (((fConst2191 + 0.51247865f) / fConst2190) + 0.689621389f));
		fConst2243 = (fConst2219 + 7.62173128f);
		fConst2244 = (1.0f / (((fConst2191 + 0.782413065f) / fConst2190) + 0.245291501f));
		fConst2245 = (9.99999975e-05f / fConst2193);
		fConst2246 = (fConst2245 + 0.000433227193f);
		fConst2247 = (((fConst2191 + -0.782413065f) / fConst2190) + 0.245291501f);
		fConst2248 = (2.0f * (0.245291501f - fConst2219));
		fConst2249 = (2.0f * (0.000433227193f - fConst2245));
		fConst2250 = (((fConst2191 + -0.51247865f) / fConst2190) + 0.689621389f);
		fConst2251 = (2.0f * (0.689621389f - fConst2219));
		fConst2252 = (2.0f * (7.62173128f - fConst2219));
		fConst2253 = (((fConst2191 + -0.168404877f) / fConst2190) + 1.06935835f);
		fConst2254 = (2.0f * (1.06935835f - fConst2219));
		fConst2255 = (2.0f * (53.5361519f - fConst2219));
		fConst2256 = (((fConst2229 + -3.18972731f) / fConst2228) + 4.07678175f);
		fConst2257 = (1.0f / fConst2231);
		fConst2258 = (2.0f * (4.07678175f - fConst2257));
		fConst2259 = (2.0f * (0.000407678192f - fConst2238));
		fConst2260 = (((fConst2229 + -0.743130445f) / fConst2228) + 1.4500711f);
		fConst2261 = (2.0f * (1.4500711f - fConst2257));
		fConst2262 = (2.0f * (1.4500711f - fConst2235));
		fConst2263 = (((fConst2229 + -0.157482162f) / fConst2228) + 0.935140193f);
		fConst2264 = (2.0f * (0.935140193f - fConst2257));
		fConst2265 = (2.0f * (0.935140193f - fConst2232));
		fConst2266 = std::tan((1963.49536f / fConst0));
		fConst2267 = (1.0f / fConst2266);
		fConst2268 = (1.0f / (((fConst2267 + 0.157482162f) / fConst2266) + 0.935140193f));
		fConst2269 = mydsp_faustpower2_f(fConst2266);
		fConst2270 = (50.0638084f / fConst2269);
		fConst2271 = (fConst2270 + 0.935140193f);
		fConst2272 = (1.0f / (((fConst2267 + 0.743130445f) / fConst2266) + 1.4500711f));
		fConst2273 = (11.0520525f / fConst2269);
		fConst2274 = (fConst2273 + 1.4500711f);
		fConst2275 = (1.0f / (((fConst2267 + 3.18972731f) / fConst2266) + 4.07678175f));
		fConst2276 = (0.00176617282f / fConst2269);
		fConst2277 = (fConst2276 + 0.000407678192f);
		fConst2278 = (1.0f / (((fConst2229 + 0.168404877f) / fConst2228) + 1.06935835f));
		fConst2279 = (fConst2257 + 53.5361519f);
		fConst2280 = (1.0f / (((fConst2229 + 0.51247865f) / fConst2228) + 0.689621389f));
		fConst2281 = (fConst2257 + 7.62173128f);
		fConst2282 = (1.0f / (((fConst2229 + 0.782413065f) / fConst2228) + 0.245291501f));
		fConst2283 = (9.99999975e-05f / fConst2231);
		fConst2284 = (fConst2283 + 0.000433227193f);
		fConst2285 = (((fConst2229 + -0.782413065f) / fConst2228) + 0.245291501f);
		fConst2286 = (2.0f * (0.245291501f - fConst2257));
		fConst2287 = (2.0f * (0.000433227193f - fConst2283));
		fConst2288 = (((fConst2229 + -0.51247865f) / fConst2228) + 0.689621389f);
		fConst2289 = (2.0f * (0.689621389f - fConst2257));
		fConst2290 = (2.0f * (7.62173128f - fConst2257));
		fConst2291 = (((fConst2229 + -0.168404877f) / fConst2228) + 1.06935835f);
		fConst2292 = (2.0f * (1.06935835f - fConst2257));
		fConst2293 = (2.0f * (53.5361519f - fConst2257));
		fConst2294 = (((fConst2267 + -3.18972731f) / fConst2266) + 4.07678175f);
		fConst2295 = (1.0f / fConst2269);
		fConst2296 = (2.0f * (4.07678175f - fConst2295));
		fConst2297 = (2.0f * (0.000407678192f - fConst2276));
		fConst2298 = (((fConst2267 + -0.743130445f) / fConst2266) + 1.4500711f);
		fConst2299 = (2.0f * (1.4500711f - fConst2295));
		fConst2300 = (2.0f * (1.4500711f - fConst2273));
		fConst2301 = (((fConst2267 + -0.157482162f) / fConst2266) + 0.935140193f);
		fConst2302 = (2.0f * (0.935140193f - fConst2295));
		fConst2303 = (2.0f * (0.935140193f - fConst2270));
		fConst2304 = std::tan((1853.29285f / fConst0));
		fConst2305 = (1.0f / fConst2304);
		fConst2306 = (1.0f / (((fConst2305 + 0.157482162f) / fConst2304) + 0.935140193f));
		fConst2307 = mydsp_faustpower2_f(fConst2304);
		fConst2308 = (50.0638084f / fConst2307);
		fConst2309 = (fConst2308 + 0.935140193f);
		fConst2310 = (1.0f / (((fConst2305 + 0.743130445f) / fConst2304) + 1.4500711f));
		fConst2311 = (11.0520525f / fConst2307);
		fConst2312 = (fConst2311 + 1.4500711f);
		fConst2313 = (1.0f / (((fConst2305 + 3.18972731f) / fConst2304) + 4.07678175f));
		fConst2314 = (0.00176617282f / fConst2307);
		fConst2315 = (fConst2314 + 0.000407678192f);
		fConst2316 = (1.0f / (((fConst2267 + 0.168404877f) / fConst2266) + 1.06935835f));
		fConst2317 = (fConst2295 + 53.5361519f);
		fConst2318 = (1.0f / (((fConst2267 + 0.51247865f) / fConst2266) + 0.689621389f));
		fConst2319 = (fConst2295 + 7.62173128f);
		fConst2320 = (1.0f / (((fConst2267 + 0.782413065f) / fConst2266) + 0.245291501f));
		fConst2321 = (9.99999975e-05f / fConst2269);
		fConst2322 = (fConst2321 + 0.000433227193f);
		fConst2323 = (((fConst2267 + -0.782413065f) / fConst2266) + 0.245291501f);
		fConst2324 = (2.0f * (0.245291501f - fConst2295));
		fConst2325 = (2.0f * (0.000433227193f - fConst2321));
		fConst2326 = (((fConst2267 + -0.51247865f) / fConst2266) + 0.689621389f);
		fConst2327 = (2.0f * (0.689621389f - fConst2295));
		fConst2328 = (2.0f * (7.62173128f - fConst2295));
		fConst2329 = (((fConst2267 + -0.168404877f) / fConst2266) + 1.06935835f);
		fConst2330 = (2.0f * (1.06935835f - fConst2295));
		fConst2331 = (2.0f * (53.5361519f - fConst2295));
		fConst2332 = (((fConst2305 + -3.18972731f) / fConst2304) + 4.07678175f);
		fConst2333 = (1.0f / fConst2307);
		fConst2334 = (2.0f * (4.07678175f - fConst2333));
		fConst2335 = (2.0f * (0.000407678192f - fConst2314));
		fConst2336 = (((fConst2305 + -0.743130445f) / fConst2304) + 1.4500711f);
		fConst2337 = (2.0f * (1.4500711f - fConst2333));
		fConst2338 = (2.0f * (1.4500711f - fConst2311));
		fConst2339 = (((fConst2305 + -0.157482162f) / fConst2304) + 0.935140193f);
		fConst2340 = (2.0f * (0.935140193f - fConst2333));
		fConst2341 = (2.0f * (0.935140193f - fConst2308));
		fConst2342 = std::tan((1749.27551f / fConst0));
		fConst2343 = (1.0f / fConst2342);
		fConst2344 = (1.0f / (((fConst2343 + 0.157482162f) / fConst2342) + 0.935140193f));
		fConst2345 = mydsp_faustpower2_f(fConst2342);
		fConst2346 = (50.0638084f / fConst2345);
		fConst2347 = (fConst2346 + 0.935140193f);
		fConst2348 = (1.0f / (((fConst2343 + 0.743130445f) / fConst2342) + 1.4500711f));
		fConst2349 = (11.0520525f / fConst2345);
		fConst2350 = (fConst2349 + 1.4500711f);
		fConst2351 = (1.0f / (((fConst2343 + 3.18972731f) / fConst2342) + 4.07678175f));
		fConst2352 = (0.00176617282f / fConst2345);
		fConst2353 = (fConst2352 + 0.000407678192f);
		fConst2354 = (1.0f / (((fConst2305 + 0.168404877f) / fConst2304) + 1.06935835f));
		fConst2355 = (fConst2333 + 53.5361519f);
		fConst2356 = (1.0f / (((fConst2305 + 0.51247865f) / fConst2304) + 0.689621389f));
		fConst2357 = (fConst2333 + 7.62173128f);
		fConst2358 = (1.0f / (((fConst2305 + 0.782413065f) / fConst2304) + 0.245291501f));
		fConst2359 = (9.99999975e-05f / fConst2307);
		fConst2360 = (fConst2359 + 0.000433227193f);
		fConst2361 = (((fConst2305 + -0.782413065f) / fConst2304) + 0.245291501f);
		fConst2362 = (2.0f * (0.245291501f - fConst2333));
		fConst2363 = (2.0f * (0.000433227193f - fConst2359));
		fConst2364 = (((fConst2305 + -0.51247865f) / fConst2304) + 0.689621389f);
		fConst2365 = (2.0f * (0.689621389f - fConst2333));
		fConst2366 = (2.0f * (7.62173128f - fConst2333));
		fConst2367 = (((fConst2305 + -0.168404877f) / fConst2304) + 1.06935835f);
		fConst2368 = (2.0f * (1.06935835f - fConst2333));
		fConst2369 = (2.0f * (53.5361519f - fConst2333));
		fConst2370 = (((fConst2343 + -3.18972731f) / fConst2342) + 4.07678175f);
		fConst2371 = (1.0f / fConst2345);
		fConst2372 = (2.0f * (4.07678175f - fConst2371));
		fConst2373 = (2.0f * (0.000407678192f - fConst2352));
		fConst2374 = (((fConst2343 + -0.743130445f) / fConst2342) + 1.4500711f);
		fConst2375 = (2.0f * (1.4500711f - fConst2371));
		fConst2376 = (2.0f * (1.4500711f - fConst2349));
		fConst2377 = (((fConst2343 + -0.157482162f) / fConst2342) + 0.935140193f);
		fConst2378 = (2.0f * (0.935140193f - fConst2371));
		fConst2379 = (2.0f * (0.935140193f - fConst2346));
		fConst2380 = std::tan((1651.09619f / fConst0));
		fConst2381 = (1.0f / fConst2380);
		fConst2382 = (1.0f / (((fConst2381 + 0.157482162f) / fConst2380) + 0.935140193f));
		fConst2383 = mydsp_faustpower2_f(fConst2380);
		fConst2384 = (50.0638084f / fConst2383);
		fConst2385 = (fConst2384 + 0.935140193f);
		fConst2386 = (1.0f / (((fConst2381 + 0.743130445f) / fConst2380) + 1.4500711f));
		fConst2387 = (11.0520525f / fConst2383);
		fConst2388 = (fConst2387 + 1.4500711f);
		fConst2389 = (1.0f / (((fConst2381 + 3.18972731f) / fConst2380) + 4.07678175f));
		fConst2390 = (0.00176617282f / fConst2383);
		fConst2391 = (fConst2390 + 0.000407678192f);
		fConst2392 = (1.0f / (((fConst2343 + 0.168404877f) / fConst2342) + 1.06935835f));
		fConst2393 = (fConst2371 + 53.5361519f);
		fConst2394 = (1.0f / (((fConst2343 + 0.51247865f) / fConst2342) + 0.689621389f));
		fConst2395 = (fConst2371 + 7.62173128f);
		fConst2396 = (1.0f / (((fConst2343 + 0.782413065f) / fConst2342) + 0.245291501f));
		fConst2397 = (9.99999975e-05f / fConst2345);
		fConst2398 = (fConst2397 + 0.000433227193f);
		fConst2399 = (((fConst2343 + -0.782413065f) / fConst2342) + 0.245291501f);
		fConst2400 = (2.0f * (0.245291501f - fConst2371));
		fConst2401 = (2.0f * (0.000433227193f - fConst2397));
		fConst2402 = (((fConst2343 + -0.51247865f) / fConst2342) + 0.689621389f);
		fConst2403 = (2.0f * (0.689621389f - fConst2371));
		fConst2404 = (2.0f * (7.62173128f - fConst2371));
		fConst2405 = (((fConst2343 + -0.168404877f) / fConst2342) + 1.06935835f);
		fConst2406 = (2.0f * (1.06935835f - fConst2371));
		fConst2407 = (2.0f * (53.5361519f - fConst2371));
		fConst2408 = (((fConst2381 + -3.18972731f) / fConst2380) + 4.07678175f);
		fConst2409 = (1.0f / fConst2383);
		fConst2410 = (2.0f * (4.07678175f - fConst2409));
		fConst2411 = (2.0f * (0.000407678192f - fConst2390));
		fConst2412 = (((fConst2381 + -0.743130445f) / fConst2380) + 1.4500711f);
		fConst2413 = (2.0f * (1.4500711f - fConst2409));
		fConst2414 = (2.0f * (1.4500711f - fConst2387));
		fConst2415 = (((fConst2381 + -0.157482162f) / fConst2380) + 0.935140193f);
		fConst2416 = (2.0f * (0.935140193f - fConst2409));
		fConst2417 = (2.0f * (0.935140193f - fConst2384));
		fConst2418 = std::tan((1558.42737f / fConst0));
		fConst2419 = (1.0f / fConst2418);
		fConst2420 = (1.0f / (((fConst2419 + 0.157482162f) / fConst2418) + 0.935140193f));
		fConst2421 = mydsp_faustpower2_f(fConst2418);
		fConst2422 = (50.0638084f / fConst2421);
		fConst2423 = (fConst2422 + 0.935140193f);
		fConst2424 = (1.0f / (((fConst2419 + 0.743130445f) / fConst2418) + 1.4500711f));
		fConst2425 = (11.0520525f / fConst2421);
		fConst2426 = (fConst2425 + 1.4500711f);
		fConst2427 = (1.0f / (((fConst2419 + 3.18972731f) / fConst2418) + 4.07678175f));
		fConst2428 = (0.00176617282f / fConst2421);
		fConst2429 = (fConst2428 + 0.000407678192f);
		fConst2430 = (1.0f / (((fConst2381 + 0.168404877f) / fConst2380) + 1.06935835f));
		fConst2431 = (fConst2409 + 53.5361519f);
		fConst2432 = (1.0f / (((fConst2381 + 0.51247865f) / fConst2380) + 0.689621389f));
		fConst2433 = (fConst2409 + 7.62173128f);
		fConst2434 = (1.0f / (((fConst2381 + 0.782413065f) / fConst2380) + 0.245291501f));
		fConst2435 = (9.99999975e-05f / fConst2383);
		fConst2436 = (fConst2435 + 0.000433227193f);
		fConst2437 = (((fConst2381 + -0.782413065f) / fConst2380) + 0.245291501f);
		fConst2438 = (2.0f * (0.245291501f - fConst2409));
		fConst2439 = (2.0f * (0.000433227193f - fConst2435));
		fConst2440 = (((fConst2381 + -0.51247865f) / fConst2380) + 0.689621389f);
		fConst2441 = (2.0f * (0.689621389f - fConst2409));
		fConst2442 = (2.0f * (7.62173128f - fConst2409));
		fConst2443 = (((fConst2381 + -0.168404877f) / fConst2380) + 1.06935835f);
		fConst2444 = (2.0f * (1.06935835f - fConst2409));
		fConst2445 = (2.0f * (53.5361519f - fConst2409));
		fConst2446 = (((fConst2419 + -3.18972731f) / fConst2418) + 4.07678175f);
		fConst2447 = (1.0f / fConst2421);
		fConst2448 = (2.0f * (4.07678175f - fConst2447));
		fConst2449 = (2.0f * (0.000407678192f - fConst2428));
		fConst2450 = (((fConst2419 + -0.743130445f) / fConst2418) + 1.4500711f);
		fConst2451 = (2.0f * (1.4500711f - fConst2447));
		fConst2452 = (2.0f * (1.4500711f - fConst2425));
		fConst2453 = (((fConst2419 + -0.157482162f) / fConst2418) + 0.935140193f);
		fConst2454 = (2.0f * (0.935140193f - fConst2447));
		fConst2455 = (2.0f * (0.935140193f - fConst2422));
		fConst2456 = std::tan((1470.95947f / fConst0));
		fConst2457 = (1.0f / fConst2456);
		fConst2458 = (1.0f / (((fConst2457 + 0.157482162f) / fConst2456) + 0.935140193f));
		fConst2459 = mydsp_faustpower2_f(fConst2456);
		fConst2460 = (50.0638084f / fConst2459);
		fConst2461 = (fConst2460 + 0.935140193f);
		fConst2462 = (1.0f / (((fConst2457 + 0.743130445f) / fConst2456) + 1.4500711f));
		fConst2463 = (11.0520525f / fConst2459);
		fConst2464 = (fConst2463 + 1.4500711f);
		fConst2465 = (1.0f / (((fConst2457 + 3.18972731f) / fConst2456) + 4.07678175f));
		fConst2466 = (0.00176617282f / fConst2459);
		fConst2467 = (fConst2466 + 0.000407678192f);
		fConst2468 = (1.0f / (((fConst2419 + 0.168404877f) / fConst2418) + 1.06935835f));
		fConst2469 = (fConst2447 + 53.5361519f);
		fConst2470 = (1.0f / (((fConst2419 + 0.51247865f) / fConst2418) + 0.689621389f));
		fConst2471 = (fConst2447 + 7.62173128f);
		fConst2472 = (1.0f / (((fConst2419 + 0.782413065f) / fConst2418) + 0.245291501f));
		fConst2473 = (9.99999975e-05f / fConst2421);
		fConst2474 = (fConst2473 + 0.000433227193f);
		fConst2475 = (((fConst2419 + -0.782413065f) / fConst2418) + 0.245291501f);
		fConst2476 = (2.0f * (0.245291501f - fConst2447));
		fConst2477 = (2.0f * (0.000433227193f - fConst2473));
		fConst2478 = (((fConst2419 + -0.51247865f) / fConst2418) + 0.689621389f);
		fConst2479 = (2.0f * (0.689621389f - fConst2447));
		fConst2480 = (2.0f * (7.62173128f - fConst2447));
		fConst2481 = (((fConst2419 + -0.168404877f) / fConst2418) + 1.06935835f);
		fConst2482 = (2.0f * (1.06935835f - fConst2447));
		fConst2483 = (2.0f * (53.5361519f - fConst2447));
		fConst2484 = (((fConst2457 + -3.18972731f) / fConst2456) + 4.07678175f);
		fConst2485 = (1.0f / fConst2459);
		fConst2486 = (2.0f * (4.07678175f - fConst2485));
		fConst2487 = (2.0f * (0.000407678192f - fConst2466));
		fConst2488 = (((fConst2457 + -0.743130445f) / fConst2456) + 1.4500711f);
		fConst2489 = (2.0f * (1.4500711f - fConst2485));
		fConst2490 = (2.0f * (1.4500711f - fConst2463));
		fConst2491 = (((fConst2457 + -0.157482162f) / fConst2456) + 0.935140193f);
		fConst2492 = (2.0f * (0.935140193f - fConst2485));
		fConst2493 = (2.0f * (0.935140193f - fConst2460));
		fConst2494 = std::tan((1388.40088f / fConst0));
		fConst2495 = (1.0f / fConst2494);
		fConst2496 = (1.0f / (((fConst2495 + 0.157482162f) / fConst2494) + 0.935140193f));
		fConst2497 = mydsp_faustpower2_f(fConst2494);
		fConst2498 = (50.0638084f / fConst2497);
		fConst2499 = (fConst2498 + 0.935140193f);
		fConst2500 = (1.0f / (((fConst2495 + 0.743130445f) / fConst2494) + 1.4500711f));
		fConst2501 = (11.0520525f / fConst2497);
		fConst2502 = (fConst2501 + 1.4500711f);
		fConst2503 = (1.0f / (((fConst2495 + 3.18972731f) / fConst2494) + 4.07678175f));
		fConst2504 = (0.00176617282f / fConst2497);
		fConst2505 = (fConst2504 + 0.000407678192f);
		fConst2506 = (1.0f / (((fConst2457 + 0.168404877f) / fConst2456) + 1.06935835f));
		fConst2507 = (fConst2485 + 53.5361519f);
		fConst2508 = (1.0f / (((fConst2457 + 0.51247865f) / fConst2456) + 0.689621389f));
		fConst2509 = (fConst2485 + 7.62173128f);
		fConst2510 = (1.0f / (((fConst2457 + 0.782413065f) / fConst2456) + 0.245291501f));
		fConst2511 = (9.99999975e-05f / fConst2459);
		fConst2512 = (fConst2511 + 0.000433227193f);
		fConst2513 = (((fConst2457 + -0.782413065f) / fConst2456) + 0.245291501f);
		fConst2514 = (2.0f * (0.245291501f - fConst2485));
		fConst2515 = (2.0f * (0.000433227193f - fConst2511));
		fConst2516 = (((fConst2457 + -0.51247865f) / fConst2456) + 0.689621389f);
		fConst2517 = (2.0f * (0.689621389f - fConst2485));
		fConst2518 = (2.0f * (7.62173128f - fConst2485));
		fConst2519 = (((fConst2457 + -0.168404877f) / fConst2456) + 1.06935835f);
		fConst2520 = (2.0f * (1.06935835f - fConst2485));
		fConst2521 = (2.0f * (53.5361519f - fConst2485));
		fConst2522 = (((fConst2495 + -3.18972731f) / fConst2494) + 4.07678175f);
		fConst2523 = (1.0f / fConst2497);
		fConst2524 = (2.0f * (4.07678175f - fConst2523));
		fConst2525 = (2.0f * (0.000407678192f - fConst2504));
		fConst2526 = (((fConst2495 + -0.743130445f) / fConst2494) + 1.4500711f);
		fConst2527 = (2.0f * (1.4500711f - fConst2523));
		fConst2528 = (2.0f * (1.4500711f - fConst2501));
		fConst2529 = (((fConst2495 + -0.157482162f) / fConst2494) + 0.935140193f);
		fConst2530 = (2.0f * (0.935140193f - fConst2523));
		fConst2531 = (2.0f * (0.935140193f - fConst2498));
		fConst2532 = std::tan((1310.47595f / fConst0));
		fConst2533 = (1.0f / fConst2532);
		fConst2534 = (1.0f / (((fConst2533 + 0.157482162f) / fConst2532) + 0.935140193f));
		fConst2535 = mydsp_faustpower2_f(fConst2532);
		fConst2536 = (50.0638084f / fConst2535);
		fConst2537 = (fConst2536 + 0.935140193f);
		fConst2538 = (1.0f / (((fConst2533 + 0.743130445f) / fConst2532) + 1.4500711f));
		fConst2539 = (11.0520525f / fConst2535);
		fConst2540 = (fConst2539 + 1.4500711f);
		fConst2541 = (1.0f / (((fConst2533 + 3.18972731f) / fConst2532) + 4.07678175f));
		fConst2542 = (0.00176617282f / fConst2535);
		fConst2543 = (fConst2542 + 0.000407678192f);
		fConst2544 = (1.0f / (((fConst2495 + 0.168404877f) / fConst2494) + 1.06935835f));
		fConst2545 = (fConst2523 + 53.5361519f);
		fConst2546 = (1.0f / (((fConst2495 + 0.51247865f) / fConst2494) + 0.689621389f));
		fConst2547 = (fConst2523 + 7.62173128f);
		fConst2548 = (1.0f / (((fConst2495 + 0.782413065f) / fConst2494) + 0.245291501f));
		fConst2549 = (9.99999975e-05f / fConst2497);
		fConst2550 = (fConst2549 + 0.000433227193f);
		fConst2551 = (((fConst2495 + -0.782413065f) / fConst2494) + 0.245291501f);
		fConst2552 = (2.0f * (0.245291501f - fConst2523));
		fConst2553 = (2.0f * (0.000433227193f - fConst2549));
		fConst2554 = (((fConst2495 + -0.51247865f) / fConst2494) + 0.689621389f);
		fConst2555 = (2.0f * (0.689621389f - fConst2523));
		fConst2556 = (2.0f * (7.62173128f - fConst2523));
		fConst2557 = (((fConst2495 + -0.168404877f) / fConst2494) + 1.06935835f);
		fConst2558 = (2.0f * (1.06935835f - fConst2523));
		fConst2559 = (2.0f * (53.5361519f - fConst2523));
		fConst2560 = (((fConst2533 + -3.18972731f) / fConst2532) + 4.07678175f);
		fConst2561 = (1.0f / fConst2535);
		fConst2562 = (2.0f * (4.07678175f - fConst2561));
		fConst2563 = (2.0f * (0.000407678192f - fConst2542));
		fConst2564 = (((fConst2533 + -0.743130445f) / fConst2532) + 1.4500711f);
		fConst2565 = (2.0f * (1.4500711f - fConst2561));
		fConst2566 = (2.0f * (1.4500711f - fConst2539));
		fConst2567 = (((fConst2533 + -0.157482162f) / fConst2532) + 0.935140193f);
		fConst2568 = (2.0f * (0.935140193f - fConst2561));
		fConst2569 = (2.0f * (0.935140193f - fConst2536));
		fConst2570 = std::tan((1236.92456f / fConst0));
		fConst2571 = (1.0f / fConst2570);
		fConst2572 = (1.0f / (((fConst2571 + 0.157482162f) / fConst2570) + 0.935140193f));
		fConst2573 = mydsp_faustpower2_f(fConst2570);
		fConst2574 = (50.0638084f / fConst2573);
		fConst2575 = (fConst2574 + 0.935140193f);
		fConst2576 = (1.0f / (((fConst2571 + 0.743130445f) / fConst2570) + 1.4500711f));
		fConst2577 = (11.0520525f / fConst2573);
		fConst2578 = (fConst2577 + 1.4500711f);
		fConst2579 = (1.0f / (((fConst2571 + 3.18972731f) / fConst2570) + 4.07678175f));
		fConst2580 = (0.00176617282f / fConst2573);
		fConst2581 = (fConst2580 + 0.000407678192f);
		fConst2582 = (1.0f / (((fConst2533 + 0.168404877f) / fConst2532) + 1.06935835f));
		fConst2583 = (fConst2561 + 53.5361519f);
		fConst2584 = (1.0f / (((fConst2533 + 0.51247865f) / fConst2532) + 0.689621389f));
		fConst2585 = (fConst2561 + 7.62173128f);
		fConst2586 = (1.0f / (((fConst2533 + 0.782413065f) / fConst2532) + 0.245291501f));
		fConst2587 = (9.99999975e-05f / fConst2535);
		fConst2588 = (fConst2587 + 0.000433227193f);
		fConst2589 = (((fConst2533 + -0.782413065f) / fConst2532) + 0.245291501f);
		fConst2590 = (2.0f * (0.245291501f - fConst2561));
		fConst2591 = (2.0f * (0.000433227193f - fConst2587));
		fConst2592 = (((fConst2533 + -0.51247865f) / fConst2532) + 0.689621389f);
		fConst2593 = (2.0f * (0.689621389f - fConst2561));
		fConst2594 = (2.0f * (7.62173128f - fConst2561));
		fConst2595 = (((fConst2533 + -0.168404877f) / fConst2532) + 1.06935835f);
		fConst2596 = (2.0f * (1.06935835f - fConst2561));
		fConst2597 = (2.0f * (53.5361519f - fConst2561));
		fConst2598 = (((fConst2571 + -3.18972731f) / fConst2570) + 4.07678175f);
		fConst2599 = (1.0f / fConst2573);
		fConst2600 = (2.0f * (4.07678175f - fConst2599));
		fConst2601 = (2.0f * (0.000407678192f - fConst2580));
		fConst2602 = (((fConst2571 + -0.743130445f) / fConst2570) + 1.4500711f);
		fConst2603 = (2.0f * (1.4500711f - fConst2599));
		fConst2604 = (2.0f * (1.4500711f - fConst2577));
		fConst2605 = (((fConst2571 + -0.157482162f) / fConst2570) + 0.935140193f);
		fConst2606 = (2.0f * (0.935140193f - fConst2599));
		fConst2607 = (2.0f * (0.935140193f - fConst2574));
		fConst2608 = std::tan((1167.50134f / fConst0));
		fConst2609 = (1.0f / fConst2608);
		fConst2610 = (1.0f / (((fConst2609 + 0.157482162f) / fConst2608) + 0.935140193f));
		fConst2611 = mydsp_faustpower2_f(fConst2608);
		fConst2612 = (50.0638084f / fConst2611);
		fConst2613 = (fConst2612 + 0.935140193f);
		fConst2614 = (1.0f / (((fConst2609 + 0.743130445f) / fConst2608) + 1.4500711f));
		fConst2615 = (11.0520525f / fConst2611);
		fConst2616 = (fConst2615 + 1.4500711f);
		fConst2617 = (1.0f / (((fConst2609 + 3.18972731f) / fConst2608) + 4.07678175f));
		fConst2618 = (0.00176617282f / fConst2611);
		fConst2619 = (fConst2618 + 0.000407678192f);
		fConst2620 = (1.0f / (((fConst2571 + 0.168404877f) / fConst2570) + 1.06935835f));
		fConst2621 = (fConst2599 + 53.5361519f);
		fConst2622 = (1.0f / (((fConst2571 + 0.51247865f) / fConst2570) + 0.689621389f));
		fConst2623 = (fConst2599 + 7.62173128f);
		fConst2624 = (1.0f / (((fConst2571 + 0.782413065f) / fConst2570) + 0.245291501f));
		fConst2625 = (9.99999975e-05f / fConst2573);
		fConst2626 = (fConst2625 + 0.000433227193f);
		fConst2627 = (((fConst2571 + -0.782413065f) / fConst2570) + 0.245291501f);
		fConst2628 = (2.0f * (0.245291501f - fConst2599));
		fConst2629 = (2.0f * (0.000433227193f - fConst2625));
		fConst2630 = (((fConst2571 + -0.51247865f) / fConst2570) + 0.689621389f);
		fConst2631 = (2.0f * (0.689621389f - fConst2599));
		fConst2632 = (2.0f * (7.62173128f - fConst2599));
		fConst2633 = (((fConst2571 + -0.168404877f) / fConst2570) + 1.06935835f);
		fConst2634 = (2.0f * (1.06935835f - fConst2599));
		fConst2635 = (2.0f * (53.5361519f - fConst2599));
		fConst2636 = (((fConst2609 + -3.18972731f) / fConst2608) + 4.07678175f);
		fConst2637 = (1.0f / fConst2611);
		fConst2638 = (2.0f * (4.07678175f - fConst2637));
		fConst2639 = (2.0f * (0.000407678192f - fConst2618));
		fConst2640 = (((fConst2609 + -0.743130445f) / fConst2608) + 1.4500711f);
		fConst2641 = (2.0f * (1.4500711f - fConst2637));
		fConst2642 = (2.0f * (1.4500711f - fConst2615));
		fConst2643 = (((fConst2609 + -0.157482162f) / fConst2608) + 0.935140193f);
		fConst2644 = (2.0f * (0.935140193f - fConst2637));
		fConst2645 = (2.0f * (0.935140193f - fConst2612));
		fConst2646 = std::tan((1101.97449f / fConst0));
		fConst2647 = (1.0f / fConst2646);
		fConst2648 = (1.0f / (((fConst2647 + 0.157482162f) / fConst2646) + 0.935140193f));
		fConst2649 = mydsp_faustpower2_f(fConst2646);
		fConst2650 = (50.0638084f / fConst2649);
		fConst2651 = (fConst2650 + 0.935140193f);
		fConst2652 = (1.0f / (((fConst2647 + 0.743130445f) / fConst2646) + 1.4500711f));
		fConst2653 = (11.0520525f / fConst2649);
		fConst2654 = (fConst2653 + 1.4500711f);
		fConst2655 = (1.0f / (((fConst2647 + 3.18972731f) / fConst2646) + 4.07678175f));
		fConst2656 = (0.00176617282f / fConst2649);
		fConst2657 = (fConst2656 + 0.000407678192f);
		fConst2658 = (1.0f / (((fConst2609 + 0.168404877f) / fConst2608) + 1.06935835f));
		fConst2659 = (fConst2637 + 53.5361519f);
		fConst2660 = (1.0f / (((fConst2609 + 0.51247865f) / fConst2608) + 0.689621389f));
		fConst2661 = (fConst2637 + 7.62173128f);
		fConst2662 = (1.0f / (((fConst2609 + 0.782413065f) / fConst2608) + 0.245291501f));
		fConst2663 = (9.99999975e-05f / fConst2611);
		fConst2664 = (fConst2663 + 0.000433227193f);
		fConst2665 = (((fConst2609 + -0.782413065f) / fConst2608) + 0.245291501f);
		fConst2666 = (2.0f * (0.245291501f - fConst2637));
		fConst2667 = (2.0f * (0.000433227193f - fConst2663));
		fConst2668 = (((fConst2609 + -0.51247865f) / fConst2608) + 0.689621389f);
		fConst2669 = (2.0f * (0.689621389f - fConst2637));
		fConst2670 = (2.0f * (7.62173128f - fConst2637));
		fConst2671 = (((fConst2609 + -0.168404877f) / fConst2608) + 1.06935835f);
		fConst2672 = (2.0f * (1.06935835f - fConst2637));
		fConst2673 = (2.0f * (53.5361519f - fConst2637));
		fConst2674 = (((fConst2647 + -3.18972731f) / fConst2646) + 4.07678175f);
		fConst2675 = (1.0f / fConst2649);
		fConst2676 = (2.0f * (4.07678175f - fConst2675));
		fConst2677 = (2.0f * (0.000407678192f - fConst2656));
		fConst2678 = (((fConst2647 + -0.743130445f) / fConst2646) + 1.4500711f);
		fConst2679 = (2.0f * (1.4500711f - fConst2675));
		fConst2680 = (2.0f * (1.4500711f - fConst2653));
		fConst2681 = (((fConst2647 + -0.157482162f) / fConst2646) + 0.935140193f);
		fConst2682 = (2.0f * (0.935140193f - fConst2675));
		fConst2683 = (2.0f * (0.935140193f - fConst2650));
		fConst2684 = std::tan((1040.12549f / fConst0));
		fConst2685 = (1.0f / fConst2684);
		fConst2686 = (1.0f / (((fConst2685 + 0.157482162f) / fConst2684) + 0.935140193f));
		fConst2687 = mydsp_faustpower2_f(fConst2684);
		fConst2688 = (50.0638084f / fConst2687);
		fConst2689 = (fConst2688 + 0.935140193f);
		fConst2690 = (1.0f / (((fConst2685 + 0.743130445f) / fConst2684) + 1.4500711f));
		fConst2691 = (11.0520525f / fConst2687);
		fConst2692 = (fConst2691 + 1.4500711f);
		fConst2693 = (1.0f / (((fConst2685 + 3.18972731f) / fConst2684) + 4.07678175f));
		fConst2694 = (0.00176617282f / fConst2687);
		fConst2695 = (fConst2694 + 0.000407678192f);
		fConst2696 = (1.0f / (((fConst2647 + 0.168404877f) / fConst2646) + 1.06935835f));
		fConst2697 = (fConst2675 + 53.5361519f);
		fConst2698 = (1.0f / (((fConst2647 + 0.51247865f) / fConst2646) + 0.689621389f));
		fConst2699 = (fConst2675 + 7.62173128f);
		fConst2700 = (1.0f / (((fConst2647 + 0.782413065f) / fConst2646) + 0.245291501f));
		fConst2701 = (9.99999975e-05f / fConst2649);
		fConst2702 = (fConst2701 + 0.000433227193f);
		fConst2703 = (((fConst2647 + -0.782413065f) / fConst2646) + 0.245291501f);
		fConst2704 = (2.0f * (0.245291501f - fConst2675));
		fConst2705 = (2.0f * (0.000433227193f - fConst2701));
		fConst2706 = (((fConst2647 + -0.51247865f) / fConst2646) + 0.689621389f);
		fConst2707 = (2.0f * (0.689621389f - fConst2675));
		fConst2708 = (2.0f * (7.62173128f - fConst2675));
		fConst2709 = (((fConst2647 + -0.168404877f) / fConst2646) + 1.06935835f);
		fConst2710 = (2.0f * (1.06935835f - fConst2675));
		fConst2711 = (2.0f * (53.5361519f - fConst2675));
		fConst2712 = (((fConst2685 + -3.18972731f) / fConst2684) + 4.07678175f);
		fConst2713 = (1.0f / fConst2687);
		fConst2714 = (2.0f * (4.07678175f - fConst2713));
		fConst2715 = (2.0f * (0.000407678192f - fConst2694));
		fConst2716 = (((fConst2685 + -0.743130445f) / fConst2684) + 1.4500711f);
		fConst2717 = (2.0f * (1.4500711f - fConst2713));
		fConst2718 = (2.0f * (1.4500711f - fConst2691));
		fConst2719 = (((fConst2685 + -0.157482162f) / fConst2684) + 0.935140193f);
		fConst2720 = (2.0f * (0.935140193f - fConst2713));
		fConst2721 = (2.0f * (0.935140193f - fConst2688));
		fConst2722 = std::tan((981.747681f / fConst0));
		fConst2723 = (1.0f / fConst2722);
		fConst2724 = (1.0f / (((fConst2723 + 0.157482162f) / fConst2722) + 0.935140193f));
		fConst2725 = mydsp_faustpower2_f(fConst2722);
		fConst2726 = (50.0638084f / fConst2725);
		fConst2727 = (fConst2726 + 0.935140193f);
		fConst2728 = (1.0f / (((fConst2723 + 0.743130445f) / fConst2722) + 1.4500711f));
		fConst2729 = (11.0520525f / fConst2725);
		fConst2730 = (fConst2729 + 1.4500711f);
		fConst2731 = (1.0f / (((fConst2723 + 3.18972731f) / fConst2722) + 4.07678175f));
		fConst2732 = (0.00176617282f / fConst2725);
		fConst2733 = (fConst2732 + 0.000407678192f);
		fConst2734 = (1.0f / (((fConst2685 + 0.168404877f) / fConst2684) + 1.06935835f));
		fConst2735 = (fConst2713 + 53.5361519f);
		fConst2736 = (1.0f / (((fConst2685 + 0.51247865f) / fConst2684) + 0.689621389f));
		fConst2737 = (fConst2713 + 7.62173128f);
		fConst2738 = (1.0f / (((fConst2685 + 0.782413065f) / fConst2684) + 0.245291501f));
		fConst2739 = (9.99999975e-05f / fConst2687);
		fConst2740 = (fConst2739 + 0.000433227193f);
		fConst2741 = (((fConst2685 + -0.782413065f) / fConst2684) + 0.245291501f);
		fConst2742 = (2.0f * (0.245291501f - fConst2713));
		fConst2743 = (2.0f * (0.000433227193f - fConst2739));
		fConst2744 = (((fConst2685 + -0.51247865f) / fConst2684) + 0.689621389f);
		fConst2745 = (2.0f * (0.689621389f - fConst2713));
		fConst2746 = (2.0f * (7.62173128f - fConst2713));
		fConst2747 = (((fConst2685 + -0.168404877f) / fConst2684) + 1.06935835f);
		fConst2748 = (2.0f * (1.06935835f - fConst2713));
		fConst2749 = (2.0f * (53.5361519f - fConst2713));
		fConst2750 = (((fConst2723 + -3.18972731f) / fConst2722) + 4.07678175f);
		fConst2751 = (1.0f / fConst2725);
		fConst2752 = (2.0f * (4.07678175f - fConst2751));
		fConst2753 = (2.0f * (0.000407678192f - fConst2732));
		fConst2754 = (((fConst2723 + -0.743130445f) / fConst2722) + 1.4500711f);
		fConst2755 = (2.0f * (1.4500711f - fConst2751));
		fConst2756 = (2.0f * (1.4500711f - fConst2729));
		fConst2757 = (((fConst2723 + -0.157482162f) / fConst2722) + 0.935140193f);
		fConst2758 = (2.0f * (0.935140193f - fConst2751));
		fConst2759 = (2.0f * (0.935140193f - fConst2726));
		fConst2760 = std::tan((926.646423f / fConst0));
		fConst2761 = (1.0f / fConst2760);
		fConst2762 = (1.0f / (((fConst2761 + 0.157482162f) / fConst2760) + 0.935140193f));
		fConst2763 = mydsp_faustpower2_f(fConst2760);
		fConst2764 = (50.0638084f / fConst2763);
		fConst2765 = (fConst2764 + 0.935140193f);
		fConst2766 = (1.0f / (((fConst2761 + 0.743130445f) / fConst2760) + 1.4500711f));
		fConst2767 = (11.0520525f / fConst2763);
		fConst2768 = (fConst2767 + 1.4500711f);
		fConst2769 = (1.0f / (((fConst2761 + 3.18972731f) / fConst2760) + 4.07678175f));
		fConst2770 = (0.00176617282f / fConst2763);
		fConst2771 = (fConst2770 + 0.000407678192f);
		fConst2772 = (1.0f / (((fConst2723 + 0.168404877f) / fConst2722) + 1.06935835f));
		fConst2773 = (fConst2751 + 53.5361519f);
		fConst2774 = (1.0f / (((fConst2723 + 0.51247865f) / fConst2722) + 0.689621389f));
		fConst2775 = (fConst2751 + 7.62173128f);
		fConst2776 = (1.0f / (((fConst2723 + 0.782413065f) / fConst2722) + 0.245291501f));
		fConst2777 = (9.99999975e-05f / fConst2725);
		fConst2778 = (fConst2777 + 0.000433227193f);
		fConst2779 = (((fConst2723 + -0.782413065f) / fConst2722) + 0.245291501f);
		fConst2780 = (2.0f * (0.245291501f - fConst2751));
		fConst2781 = (2.0f * (0.000433227193f - fConst2777));
		fConst2782 = (((fConst2723 + -0.51247865f) / fConst2722) + 0.689621389f);
		fConst2783 = (2.0f * (0.689621389f - fConst2751));
		fConst2784 = (2.0f * (7.62173128f - fConst2751));
		fConst2785 = (((fConst2723 + -0.168404877f) / fConst2722) + 1.06935835f);
		fConst2786 = (2.0f * (1.06935835f - fConst2751));
		fConst2787 = (2.0f * (53.5361519f - fConst2751));
		fConst2788 = (((fConst2761 + -3.18972731f) / fConst2760) + 4.07678175f);
		fConst2789 = (1.0f / fConst2763);
		fConst2790 = (2.0f * (4.07678175f - fConst2789));
		fConst2791 = (2.0f * (0.000407678192f - fConst2770));
		fConst2792 = (((fConst2761 + -0.743130445f) / fConst2760) + 1.4500711f);
		fConst2793 = (2.0f * (1.4500711f - fConst2789));
		fConst2794 = (2.0f * (1.4500711f - fConst2767));
		fConst2795 = (((fConst2761 + -0.157482162f) / fConst2760) + 0.935140193f);
		fConst2796 = (2.0f * (0.935140193f - fConst2789));
		fConst2797 = (2.0f * (0.935140193f - fConst2764));
		fConst2798 = std::tan((874.637756f / fConst0));
		fConst2799 = (1.0f / fConst2798);
		fConst2800 = (1.0f / (((fConst2799 + 0.157482162f) / fConst2798) + 0.935140193f));
		fConst2801 = mydsp_faustpower2_f(fConst2798);
		fConst2802 = (50.0638084f / fConst2801);
		fConst2803 = (fConst2802 + 0.935140193f);
		fConst2804 = (1.0f / (((fConst2799 + 0.743130445f) / fConst2798) + 1.4500711f));
		fConst2805 = (11.0520525f / fConst2801);
		fConst2806 = (fConst2805 + 1.4500711f);
		fConst2807 = (1.0f / (((fConst2799 + 3.18972731f) / fConst2798) + 4.07678175f));
		fConst2808 = (0.00176617282f / fConst2801);
		fConst2809 = (fConst2808 + 0.000407678192f);
		fConst2810 = (1.0f / (((fConst2761 + 0.168404877f) / fConst2760) + 1.06935835f));
		fConst2811 = (fConst2789 + 53.5361519f);
		fConst2812 = (1.0f / (((fConst2761 + 0.51247865f) / fConst2760) + 0.689621389f));
		fConst2813 = (fConst2789 + 7.62173128f);
		fConst2814 = (1.0f / (((fConst2761 + 0.782413065f) / fConst2760) + 0.245291501f));
		fConst2815 = (9.99999975e-05f / fConst2763);
		fConst2816 = (fConst2815 + 0.000433227193f);
		fConst2817 = (((fConst2761 + -0.782413065f) / fConst2760) + 0.245291501f);
		fConst2818 = (2.0f * (0.245291501f - fConst2789));
		fConst2819 = (2.0f * (0.000433227193f - fConst2815));
		fConst2820 = (((fConst2761 + -0.51247865f) / fConst2760) + 0.689621389f);
		fConst2821 = (2.0f * (0.689621389f - fConst2789));
		fConst2822 = (2.0f * (7.62173128f - fConst2789));
		fConst2823 = (((fConst2761 + -0.168404877f) / fConst2760) + 1.06935835f);
		fConst2824 = (2.0f * (1.06935835f - fConst2789));
		fConst2825 = (2.0f * (53.5361519f - fConst2789));
		fConst2826 = (((fConst2799 + -3.18972731f) / fConst2798) + 4.07678175f);
		fConst2827 = (1.0f / fConst2801);
		fConst2828 = (2.0f * (4.07678175f - fConst2827));
		fConst2829 = (2.0f * (0.000407678192f - fConst2808));
		fConst2830 = (((fConst2799 + -0.743130445f) / fConst2798) + 1.4500711f);
		fConst2831 = (2.0f * (1.4500711f - fConst2827));
		fConst2832 = (2.0f * (1.4500711f - fConst2805));
		fConst2833 = (((fConst2799 + -0.157482162f) / fConst2798) + 0.935140193f);
		fConst2834 = (2.0f * (0.935140193f - fConst2827));
		fConst2835 = (2.0f * (0.935140193f - fConst2802));
		fConst2836 = std::tan((825.548096f / fConst0));
		fConst2837 = (1.0f / fConst2836);
		fConst2838 = (1.0f / (((fConst2837 + 0.157482162f) / fConst2836) + 0.935140193f));
		fConst2839 = mydsp_faustpower2_f(fConst2836);
		fConst2840 = (50.0638084f / fConst2839);
		fConst2841 = (fConst2840 + 0.935140193f);
		fConst2842 = (1.0f / (((fConst2837 + 0.743130445f) / fConst2836) + 1.4500711f));
		fConst2843 = (11.0520525f / fConst2839);
		fConst2844 = (fConst2843 + 1.4500711f);
		fConst2845 = (1.0f / (((fConst2837 + 3.18972731f) / fConst2836) + 4.07678175f));
		fConst2846 = (0.00176617282f / fConst2839);
		fConst2847 = (fConst2846 + 0.000407678192f);
		fConst2848 = (1.0f / (((fConst2799 + 0.168404877f) / fConst2798) + 1.06935835f));
		fConst2849 = (fConst2827 + 53.5361519f);
		fConst2850 = (1.0f / (((fConst2799 + 0.51247865f) / fConst2798) + 0.689621389f));
		fConst2851 = (fConst2827 + 7.62173128f);
		fConst2852 = (1.0f / (((fConst2799 + 0.782413065f) / fConst2798) + 0.245291501f));
		fConst2853 = (9.99999975e-05f / fConst2801);
		fConst2854 = (fConst2853 + 0.000433227193f);
		fConst2855 = (((fConst2799 + -0.782413065f) / fConst2798) + 0.245291501f);
		fConst2856 = (2.0f * (0.245291501f - fConst2827));
		fConst2857 = (2.0f * (0.000433227193f - fConst2853));
		fConst2858 = (((fConst2799 + -0.51247865f) / fConst2798) + 0.689621389f);
		fConst2859 = (2.0f * (0.689621389f - fConst2827));
		fConst2860 = (2.0f * (7.62173128f - fConst2827));
		fConst2861 = (((fConst2799 + -0.168404877f) / fConst2798) + 1.06935835f);
		fConst2862 = (2.0f * (1.06935835f - fConst2827));
		fConst2863 = (2.0f * (53.5361519f - fConst2827));
		fConst2864 = (((fConst2837 + -3.18972731f) / fConst2836) + 4.07678175f);
		fConst2865 = (1.0f / fConst2839);
		fConst2866 = (2.0f * (4.07678175f - fConst2865));
		fConst2867 = (2.0f * (0.000407678192f - fConst2846));
		fConst2868 = (((fConst2837 + -0.743130445f) / fConst2836) + 1.4500711f);
		fConst2869 = (2.0f * (1.4500711f - fConst2865));
		fConst2870 = (2.0f * (1.4500711f - fConst2843));
		fConst2871 = (((fConst2837 + -0.157482162f) / fConst2836) + 0.935140193f);
		fConst2872 = (2.0f * (0.935140193f - fConst2865));
		fConst2873 = (2.0f * (0.935140193f - fConst2840));
		fConst2874 = std::tan((779.213684f / fConst0));
		fConst2875 = (1.0f / fConst2874);
		fConst2876 = (1.0f / (((fConst2875 + 0.157482162f) / fConst2874) + 0.935140193f));
		fConst2877 = mydsp_faustpower2_f(fConst2874);
		fConst2878 = (50.0638084f / fConst2877);
		fConst2879 = (fConst2878 + 0.935140193f);
		fConst2880 = (1.0f / (((fConst2875 + 0.743130445f) / fConst2874) + 1.4500711f));
		fConst2881 = (11.0520525f / fConst2877);
		fConst2882 = (fConst2881 + 1.4500711f);
		fConst2883 = (1.0f / (((fConst2875 + 3.18972731f) / fConst2874) + 4.07678175f));
		fConst2884 = (0.00176617282f / fConst2877);
		fConst2885 = (fConst2884 + 0.000407678192f);
		fConst2886 = (1.0f / (((fConst2837 + 0.168404877f) / fConst2836) + 1.06935835f));
		fConst2887 = (fConst2865 + 53.5361519f);
		fConst2888 = (1.0f / (((fConst2837 + 0.51247865f) / fConst2836) + 0.689621389f));
		fConst2889 = (fConst2865 + 7.62173128f);
		fConst2890 = (1.0f / (((fConst2837 + 0.782413065f) / fConst2836) + 0.245291501f));
		fConst2891 = (9.99999975e-05f / fConst2839);
		fConst2892 = (fConst2891 + 0.000433227193f);
		fConst2893 = (((fConst2837 + -0.782413065f) / fConst2836) + 0.245291501f);
		fConst2894 = (2.0f * (0.245291501f - fConst2865));
		fConst2895 = (2.0f * (0.000433227193f - fConst2891));
		fConst2896 = (((fConst2837 + -0.51247865f) / fConst2836) + 0.689621389f);
		fConst2897 = (2.0f * (0.689621389f - fConst2865));
		fConst2898 = (2.0f * (7.62173128f - fConst2865));
		fConst2899 = (((fConst2837 + -0.168404877f) / fConst2836) + 1.06935835f);
		fConst2900 = (2.0f * (1.06935835f - fConst2865));
		fConst2901 = (2.0f * (53.5361519f - fConst2865));
		fConst2902 = (((fConst2875 + -3.18972731f) / fConst2874) + 4.07678175f);
		fConst2903 = (1.0f / fConst2877);
		fConst2904 = (2.0f * (4.07678175f - fConst2903));
		fConst2905 = (2.0f * (0.000407678192f - fConst2884));
		fConst2906 = (((fConst2875 + -0.743130445f) / fConst2874) + 1.4500711f);
		fConst2907 = (2.0f * (1.4500711f - fConst2903));
		fConst2908 = (2.0f * (1.4500711f - fConst2881));
		fConst2909 = (((fConst2875 + -0.157482162f) / fConst2874) + 0.935140193f);
		fConst2910 = (2.0f * (0.935140193f - fConst2903));
		fConst2911 = (2.0f * (0.935140193f - fConst2878));
		fConst2912 = std::tan((735.479736f / fConst0));
		fConst2913 = (1.0f / fConst2912);
		fConst2914 = (1.0f / (((fConst2913 + 0.157482162f) / fConst2912) + 0.935140193f));
		fConst2915 = mydsp_faustpower2_f(fConst2912);
		fConst2916 = (50.0638084f / fConst2915);
		fConst2917 = (fConst2916 + 0.935140193f);
		fConst2918 = (1.0f / (((fConst2913 + 0.743130445f) / fConst2912) + 1.4500711f));
		fConst2919 = (11.0520525f / fConst2915);
		fConst2920 = (fConst2919 + 1.4500711f);
		fConst2921 = (1.0f / (((fConst2913 + 3.18972731f) / fConst2912) + 4.07678175f));
		fConst2922 = (0.00176617282f / fConst2915);
		fConst2923 = (fConst2922 + 0.000407678192f);
		fConst2924 = (1.0f / (((fConst2875 + 0.168404877f) / fConst2874) + 1.06935835f));
		fConst2925 = (fConst2903 + 53.5361519f);
		fConst2926 = (1.0f / (((fConst2875 + 0.51247865f) / fConst2874) + 0.689621389f));
		fConst2927 = (fConst2903 + 7.62173128f);
		fConst2928 = (1.0f / (((fConst2875 + 0.782413065f) / fConst2874) + 0.245291501f));
		fConst2929 = (9.99999975e-05f / fConst2877);
		fConst2930 = (fConst2929 + 0.000433227193f);
		fConst2931 = (((fConst2875 + -0.782413065f) / fConst2874) + 0.245291501f);
		fConst2932 = (2.0f * (0.245291501f - fConst2903));
		fConst2933 = (2.0f * (0.000433227193f - fConst2929));
		fConst2934 = (((fConst2875 + -0.51247865f) / fConst2874) + 0.689621389f);
		fConst2935 = (2.0f * (0.689621389f - fConst2903));
		fConst2936 = (2.0f * (7.62173128f - fConst2903));
		fConst2937 = (((fConst2875 + -0.168404877f) / fConst2874) + 1.06935835f);
		fConst2938 = (2.0f * (1.06935835f - fConst2903));
		fConst2939 = (2.0f * (53.5361519f - fConst2903));
		fConst2940 = (((fConst2913 + -3.18972731f) / fConst2912) + 4.07678175f);
		fConst2941 = (1.0f / fConst2915);
		fConst2942 = (2.0f * (4.07678175f - fConst2941));
		fConst2943 = (2.0f * (0.000407678192f - fConst2922));
		fConst2944 = (((fConst2913 + -0.743130445f) / fConst2912) + 1.4500711f);
		fConst2945 = (2.0f * (1.4500711f - fConst2941));
		fConst2946 = (2.0f * (1.4500711f - fConst2919));
		fConst2947 = (((fConst2913 + -0.157482162f) / fConst2912) + 0.935140193f);
		fConst2948 = (2.0f * (0.935140193f - fConst2941));
		fConst2949 = (2.0f * (0.935140193f - fConst2916));
		fConst2950 = std::tan((694.200439f / fConst0));
		fConst2951 = (1.0f / fConst2950);
		fConst2952 = (1.0f / (((fConst2951 + 0.157482162f) / fConst2950) + 0.935140193f));
		fConst2953 = mydsp_faustpower2_f(fConst2950);
		fConst2954 = (50.0638084f / fConst2953);
		fConst2955 = (fConst2954 + 0.935140193f);
		fConst2956 = (1.0f / (((fConst2951 + 0.743130445f) / fConst2950) + 1.4500711f));
		fConst2957 = (11.0520525f / fConst2953);
		fConst2958 = (fConst2957 + 1.4500711f);
		fConst2959 = (1.0f / (((fConst2951 + 3.18972731f) / fConst2950) + 4.07678175f));
		fConst2960 = (0.00176617282f / fConst2953);
		fConst2961 = (fConst2960 + 0.000407678192f);
		fConst2962 = (1.0f / (((fConst2913 + 0.168404877f) / fConst2912) + 1.06935835f));
		fConst2963 = (fConst2941 + 53.5361519f);
		fConst2964 = (1.0f / (((fConst2913 + 0.51247865f) / fConst2912) + 0.689621389f));
		fConst2965 = (fConst2941 + 7.62173128f);
		fConst2966 = (1.0f / (((fConst2913 + 0.782413065f) / fConst2912) + 0.245291501f));
		fConst2967 = (9.99999975e-05f / fConst2915);
		fConst2968 = (fConst2967 + 0.000433227193f);
		fConst2969 = (((fConst2913 + -0.782413065f) / fConst2912) + 0.245291501f);
		fConst2970 = (2.0f * (0.245291501f - fConst2941));
		fConst2971 = (2.0f * (0.000433227193f - fConst2967));
		fConst2972 = (((fConst2913 + -0.51247865f) / fConst2912) + 0.689621389f);
		fConst2973 = (2.0f * (0.689621389f - fConst2941));
		fConst2974 = (2.0f * (7.62173128f - fConst2941));
		fConst2975 = (((fConst2913 + -0.168404877f) / fConst2912) + 1.06935835f);
		fConst2976 = (2.0f * (1.06935835f - fConst2941));
		fConst2977 = (2.0f * (53.5361519f - fConst2941));
		fConst2978 = (((fConst2951 + -3.18972731f) / fConst2950) + 4.07678175f);
		fConst2979 = (1.0f / fConst2953);
		fConst2980 = (2.0f * (4.07678175f - fConst2979));
		fConst2981 = (2.0f * (0.000407678192f - fConst2960));
		fConst2982 = (((fConst2951 + -0.743130445f) / fConst2950) + 1.4500711f);
		fConst2983 = (2.0f * (1.4500711f - fConst2979));
		fConst2984 = (2.0f * (1.4500711f - fConst2957));
		fConst2985 = (((fConst2951 + -0.157482162f) / fConst2950) + 0.935140193f);
		fConst2986 = (2.0f * (0.935140193f - fConst2979));
		fConst2987 = (2.0f * (0.935140193f - fConst2954));
		fConst2988 = std::tan((655.237976f / fConst0));
		fConst2989 = (1.0f / fConst2988);
		fConst2990 = (1.0f / (((fConst2989 + 0.157482162f) / fConst2988) + 0.935140193f));
		fConst2991 = mydsp_faustpower2_f(fConst2988);
		fConst2992 = (50.0638084f / fConst2991);
		fConst2993 = (fConst2992 + 0.935140193f);
		fConst2994 = (1.0f / (((fConst2989 + 0.743130445f) / fConst2988) + 1.4500711f));
		fConst2995 = (11.0520525f / fConst2991);
		fConst2996 = (fConst2995 + 1.4500711f);
		fConst2997 = (1.0f / (((fConst2989 + 3.18972731f) / fConst2988) + 4.07678175f));
		fConst2998 = (0.00176617282f / fConst2991);
		fConst2999 = (fConst2998 + 0.000407678192f);
		fConst3000 = (1.0f / (((fConst2951 + 0.168404877f) / fConst2950) + 1.06935835f));
		fConst3001 = (fConst2979 + 53.5361519f);
		fConst3002 = (1.0f / (((fConst2951 + 0.51247865f) / fConst2950) + 0.689621389f));
		fConst3003 = (fConst2979 + 7.62173128f);
		fConst3004 = (1.0f / (((fConst2951 + 0.782413065f) / fConst2950) + 0.245291501f));
		fConst3005 = (9.99999975e-05f / fConst2953);
		fConst3006 = (fConst3005 + 0.000433227193f);
		fConst3007 = (((fConst2951 + -0.782413065f) / fConst2950) + 0.245291501f);
		fConst3008 = (2.0f * (0.245291501f - fConst2979));
		fConst3009 = (2.0f * (0.000433227193f - fConst3005));
		fConst3010 = (((fConst2951 + -0.51247865f) / fConst2950) + 0.689621389f);
		fConst3011 = (2.0f * (0.689621389f - fConst2979));
		fConst3012 = (2.0f * (7.62173128f - fConst2979));
		fConst3013 = (((fConst2951 + -0.168404877f) / fConst2950) + 1.06935835f);
		fConst3014 = (2.0f * (1.06935835f - fConst2979));
		fConst3015 = (2.0f * (53.5361519f - fConst2979));
		fConst3016 = (((fConst2989 + -3.18972731f) / fConst2988) + 4.07678175f);
		fConst3017 = (1.0f / fConst2991);
		fConst3018 = (2.0f * (4.07678175f - fConst3017));
		fConst3019 = (2.0f * (0.000407678192f - fConst2998));
		fConst3020 = (((fConst2989 + -0.743130445f) / fConst2988) + 1.4500711f);
		fConst3021 = (2.0f * (1.4500711f - fConst3017));
		fConst3022 = (2.0f * (1.4500711f - fConst2995));
		fConst3023 = (((fConst2989 + -0.157482162f) / fConst2988) + 0.935140193f);
		fConst3024 = (2.0f * (0.935140193f - fConst3017));
		fConst3025 = (2.0f * (0.935140193f - fConst2992));
		fConst3026 = std::tan((618.46228f / fConst0));
		fConst3027 = (1.0f / fConst3026);
		fConst3028 = (1.0f / (((fConst3027 + 0.157482162f) / fConst3026) + 0.935140193f));
		fConst3029 = mydsp_faustpower2_f(fConst3026);
		fConst3030 = (50.0638084f / fConst3029);
		fConst3031 = (fConst3030 + 0.935140193f);
		fConst3032 = (1.0f / (((fConst3027 + 0.743130445f) / fConst3026) + 1.4500711f));
		fConst3033 = (11.0520525f / fConst3029);
		fConst3034 = (fConst3033 + 1.4500711f);
		fConst3035 = (1.0f / (((fConst3027 + 3.18972731f) / fConst3026) + 4.07678175f));
		fConst3036 = (0.00176617282f / fConst3029);
		fConst3037 = (fConst3036 + 0.000407678192f);
		fConst3038 = (1.0f / (((fConst2989 + 0.168404877f) / fConst2988) + 1.06935835f));
		fConst3039 = (fConst3017 + 53.5361519f);
		fConst3040 = (1.0f / (((fConst2989 + 0.51247865f) / fConst2988) + 0.689621389f));
		fConst3041 = (fConst3017 + 7.62173128f);
		fConst3042 = (1.0f / (((fConst2989 + 0.782413065f) / fConst2988) + 0.245291501f));
		fConst3043 = (9.99999975e-05f / fConst2991);
		fConst3044 = (fConst3043 + 0.000433227193f);
		fConst3045 = (((fConst2989 + -0.782413065f) / fConst2988) + 0.245291501f);
		fConst3046 = (2.0f * (0.245291501f - fConst3017));
		fConst3047 = (2.0f * (0.000433227193f - fConst3043));
		fConst3048 = (((fConst2989 + -0.51247865f) / fConst2988) + 0.689621389f);
		fConst3049 = (2.0f * (0.689621389f - fConst3017));
		fConst3050 = (2.0f * (7.62173128f - fConst3017));
		fConst3051 = (((fConst2989 + -0.168404877f) / fConst2988) + 1.06935835f);
		fConst3052 = (2.0f * (1.06935835f - fConst3017));
		fConst3053 = (2.0f * (53.5361519f - fConst3017));
		fConst3054 = (((fConst3027 + -3.18972731f) / fConst3026) + 4.07678175f);
		fConst3055 = (1.0f / fConst3029);
		fConst3056 = (2.0f * (4.07678175f - fConst3055));
		fConst3057 = (2.0f * (0.000407678192f - fConst3036));
		fConst3058 = (((fConst3027 + -0.743130445f) / fConst3026) + 1.4500711f);
		fConst3059 = (2.0f * (1.4500711f - fConst3055));
		fConst3060 = (2.0f * (1.4500711f - fConst3033));
		fConst3061 = (((fConst3027 + -0.157482162f) / fConst3026) + 0.935140193f);
		fConst3062 = (2.0f * (0.935140193f - fConst3055));
		fConst3063 = (2.0f * (0.935140193f - fConst3030));
		fConst3064 = std::tan((583.750671f / fConst0));
		fConst3065 = (1.0f / fConst3064);
		fConst3066 = (1.0f / (((fConst3065 + 0.157482162f) / fConst3064) + 0.935140193f));
		fConst3067 = mydsp_faustpower2_f(fConst3064);
		fConst3068 = (50.0638084f / fConst3067);
		fConst3069 = (fConst3068 + 0.935140193f);
		fConst3070 = (1.0f / (((fConst3065 + 0.743130445f) / fConst3064) + 1.4500711f));
		fConst3071 = (11.0520525f / fConst3067);
		fConst3072 = (fConst3071 + 1.4500711f);
		fConst3073 = (1.0f / (((fConst3065 + 3.18972731f) / fConst3064) + 4.07678175f));
		fConst3074 = (0.00176617282f / fConst3067);
		fConst3075 = (fConst3074 + 0.000407678192f);
		fConst3076 = (1.0f / (((fConst3027 + 0.168404877f) / fConst3026) + 1.06935835f));
		fConst3077 = (fConst3055 + 53.5361519f);
		fConst3078 = (1.0f / (((fConst3027 + 0.51247865f) / fConst3026) + 0.689621389f));
		fConst3079 = (fConst3055 + 7.62173128f);
		fConst3080 = (1.0f / (((fConst3027 + 0.782413065f) / fConst3026) + 0.245291501f));
		fConst3081 = (9.99999975e-05f / fConst3029);
		fConst3082 = (fConst3081 + 0.000433227193f);
		fConst3083 = (((fConst3027 + -0.782413065f) / fConst3026) + 0.245291501f);
		fConst3084 = (2.0f * (0.245291501f - fConst3055));
		fConst3085 = (2.0f * (0.000433227193f - fConst3081));
		fConst3086 = (((fConst3027 + -0.51247865f) / fConst3026) + 0.689621389f);
		fConst3087 = (2.0f * (0.689621389f - fConst3055));
		fConst3088 = (2.0f * (7.62173128f - fConst3055));
		fConst3089 = (((fConst3027 + -0.168404877f) / fConst3026) + 1.06935835f);
		fConst3090 = (2.0f * (1.06935835f - fConst3055));
		fConst3091 = (2.0f * (53.5361519f - fConst3055));
		fConst3092 = (((fConst3065 + -3.18972731f) / fConst3064) + 4.07678175f);
		fConst3093 = (1.0f / fConst3067);
		fConst3094 = (2.0f * (4.07678175f - fConst3093));
		fConst3095 = (2.0f * (0.000407678192f - fConst3074));
		fConst3096 = (((fConst3065 + -0.743130445f) / fConst3064) + 1.4500711f);
		fConst3097 = (2.0f * (1.4500711f - fConst3093));
		fConst3098 = (2.0f * (1.4500711f - fConst3071));
		fConst3099 = (((fConst3065 + -0.157482162f) / fConst3064) + 0.935140193f);
		fConst3100 = (2.0f * (0.935140193f - fConst3093));
		fConst3101 = (2.0f * (0.935140193f - fConst3068));
		fConst3102 = std::tan((550.987244f / fConst0));
		fConst3103 = (1.0f / fConst3102);
		fConst3104 = (1.0f / (((fConst3103 + 0.157482162f) / fConst3102) + 0.935140193f));
		fConst3105 = mydsp_faustpower2_f(fConst3102);
		fConst3106 = (50.0638084f / fConst3105);
		fConst3107 = (fConst3106 + 0.935140193f);
		fConst3108 = (1.0f / (((fConst3103 + 0.743130445f) / fConst3102) + 1.4500711f));
		fConst3109 = (11.0520525f / fConst3105);
		fConst3110 = (fConst3109 + 1.4500711f);
		fConst3111 = (1.0f / (((fConst3103 + 3.18972731f) / fConst3102) + 4.07678175f));
		fConst3112 = (0.00176617282f / fConst3105);
		fConst3113 = (fConst3112 + 0.000407678192f);
		fConst3114 = (1.0f / (((fConst3065 + 0.168404877f) / fConst3064) + 1.06935835f));
		fConst3115 = (fConst3093 + 53.5361519f);
		fConst3116 = (1.0f / (((fConst3065 + 0.51247865f) / fConst3064) + 0.689621389f));
		fConst3117 = (fConst3093 + 7.62173128f);
		fConst3118 = (1.0f / (((fConst3065 + 0.782413065f) / fConst3064) + 0.245291501f));
		fConst3119 = (9.99999975e-05f / fConst3067);
		fConst3120 = (fConst3119 + 0.000433227193f);
		fConst3121 = (((fConst3065 + -0.782413065f) / fConst3064) + 0.245291501f);
		fConst3122 = (2.0f * (0.245291501f - fConst3093));
		fConst3123 = (2.0f * (0.000433227193f - fConst3119));
		fConst3124 = (((fConst3065 + -0.51247865f) / fConst3064) + 0.689621389f);
		fConst3125 = (2.0f * (0.689621389f - fConst3093));
		fConst3126 = (2.0f * (7.62173128f - fConst3093));
		fConst3127 = (((fConst3065 + -0.168404877f) / fConst3064) + 1.06935835f);
		fConst3128 = (2.0f * (1.06935835f - fConst3093));
		fConst3129 = (2.0f * (53.5361519f - fConst3093));
		fConst3130 = (((fConst3103 + -3.18972731f) / fConst3102) + 4.07678175f);
		fConst3131 = (1.0f / fConst3105);
		fConst3132 = (2.0f * (4.07678175f - fConst3131));
		fConst3133 = (2.0f * (0.000407678192f - fConst3112));
		fConst3134 = (((fConst3103 + -0.743130445f) / fConst3102) + 1.4500711f);
		fConst3135 = (2.0f * (1.4500711f - fConst3131));
		fConst3136 = (2.0f * (1.4500711f - fConst3109));
		fConst3137 = (((fConst3103 + -0.157482162f) / fConst3102) + 0.935140193f);
		fConst3138 = (2.0f * (0.935140193f - fConst3131));
		fConst3139 = (2.0f * (0.935140193f - fConst3106));
		fConst3140 = std::tan((520.062744f / fConst0));
		fConst3141 = (1.0f / fConst3140);
		fConst3142 = (1.0f / (((fConst3141 + 0.157482162f) / fConst3140) + 0.935140193f));
		fConst3143 = mydsp_faustpower2_f(fConst3140);
		fConst3144 = (50.0638084f / fConst3143);
		fConst3145 = (fConst3144 + 0.935140193f);
		fConst3146 = (1.0f / (((fConst3141 + 0.743130445f) / fConst3140) + 1.4500711f));
		fConst3147 = (11.0520525f / fConst3143);
		fConst3148 = (fConst3147 + 1.4500711f);
		fConst3149 = (1.0f / (((fConst3141 + 3.18972731f) / fConst3140) + 4.07678175f));
		fConst3150 = (0.00176617282f / fConst3143);
		fConst3151 = (fConst3150 + 0.000407678192f);
		fConst3152 = (1.0f / (((fConst3103 + 0.168404877f) / fConst3102) + 1.06935835f));
		fConst3153 = (fConst3131 + 53.5361519f);
		fConst3154 = (1.0f / (((fConst3103 + 0.51247865f) / fConst3102) + 0.689621389f));
		fConst3155 = (fConst3131 + 7.62173128f);
		fConst3156 = (1.0f / (((fConst3103 + 0.782413065f) / fConst3102) + 0.245291501f));
		fConst3157 = (9.99999975e-05f / fConst3105);
		fConst3158 = (fConst3157 + 0.000433227193f);
		fConst3159 = (((fConst3103 + -0.782413065f) / fConst3102) + 0.245291501f);
		fConst3160 = (2.0f * (0.245291501f - fConst3131));
		fConst3161 = (2.0f * (0.000433227193f - fConst3157));
		fConst3162 = (((fConst3103 + -0.51247865f) / fConst3102) + 0.689621389f);
		fConst3163 = (2.0f * (0.689621389f - fConst3131));
		fConst3164 = (2.0f * (7.62173128f - fConst3131));
		fConst3165 = (((fConst3103 + -0.168404877f) / fConst3102) + 1.06935835f);
		fConst3166 = (2.0f * (1.06935835f - fConst3131));
		fConst3167 = (2.0f * (53.5361519f - fConst3131));
		fConst3168 = (((fConst3141 + -3.18972731f) / fConst3140) + 4.07678175f);
		fConst3169 = (1.0f / fConst3143);
		fConst3170 = (2.0f * (4.07678175f - fConst3169));
		fConst3171 = (2.0f * (0.000407678192f - fConst3150));
		fConst3172 = (((fConst3141 + -0.743130445f) / fConst3140) + 1.4500711f);
		fConst3173 = (2.0f * (1.4500711f - fConst3169));
		fConst3174 = (2.0f * (1.4500711f - fConst3147));
		fConst3175 = (((fConst3141 + -0.157482162f) / fConst3140) + 0.935140193f);
		fConst3176 = (2.0f * (0.935140193f - fConst3169));
		fConst3177 = (2.0f * (0.935140193f - fConst3144));
		fConst3178 = std::tan((490.87384f / fConst0));
		fConst3179 = (1.0f / fConst3178);
		fConst3180 = (1.0f / (((fConst3179 + 0.157482162f) / fConst3178) + 0.935140193f));
		fConst3181 = mydsp_faustpower2_f(fConst3178);
		fConst3182 = (50.0638084f / fConst3181);
		fConst3183 = (fConst3182 + 0.935140193f);
		fConst3184 = (1.0f / (((fConst3179 + 0.743130445f) / fConst3178) + 1.4500711f));
		fConst3185 = (11.0520525f / fConst3181);
		fConst3186 = (fConst3185 + 1.4500711f);
		fConst3187 = (1.0f / (((fConst3179 + 3.18972731f) / fConst3178) + 4.07678175f));
		fConst3188 = (0.00176617282f / fConst3181);
		fConst3189 = (fConst3188 + 0.000407678192f);
		fConst3190 = (1.0f / (((fConst3141 + 0.168404877f) / fConst3140) + 1.06935835f));
		fConst3191 = (fConst3169 + 53.5361519f);
		fConst3192 = (1.0f / (((fConst3141 + 0.51247865f) / fConst3140) + 0.689621389f));
		fConst3193 = (fConst3169 + 7.62173128f);
		fConst3194 = (1.0f / (((fConst3141 + 0.782413065f) / fConst3140) + 0.245291501f));
		fConst3195 = (9.99999975e-05f / fConst3143);
		fConst3196 = (fConst3195 + 0.000433227193f);
		fConst3197 = (((fConst3141 + -0.782413065f) / fConst3140) + 0.245291501f);
		fConst3198 = (2.0f * (0.245291501f - fConst3169));
		fConst3199 = (2.0f * (0.000433227193f - fConst3195));
		fConst3200 = (((fConst3141 + -0.51247865f) / fConst3140) + 0.689621389f);
		fConst3201 = (2.0f * (0.689621389f - fConst3169));
		fConst3202 = (2.0f * (7.62173128f - fConst3169));
		fConst3203 = (((fConst3141 + -0.168404877f) / fConst3140) + 1.06935835f);
		fConst3204 = (2.0f * (1.06935835f - fConst3169));
		fConst3205 = (2.0f * (53.5361519f - fConst3169));
		fConst3206 = (((fConst3179 + -3.18972731f) / fConst3178) + 4.07678175f);
		fConst3207 = (1.0f / fConst3181);
		fConst3208 = (2.0f * (4.07678175f - fConst3207));
		fConst3209 = (2.0f * (0.000407678192f - fConst3188));
		fConst3210 = (((fConst3179 + -0.743130445f) / fConst3178) + 1.4500711f);
		fConst3211 = (2.0f * (1.4500711f - fConst3207));
		fConst3212 = (2.0f * (1.4500711f - fConst3185));
		fConst3213 = (((fConst3179 + -0.157482162f) / fConst3178) + 0.935140193f);
		fConst3214 = (2.0f * (0.935140193f - fConst3207));
		fConst3215 = (2.0f * (0.935140193f - fConst3182));
		fConst3216 = std::tan((463.323212f / fConst0));
		fConst3217 = (1.0f / fConst3216);
		fConst3218 = (1.0f / (((fConst3217 + 0.157482162f) / fConst3216) + 0.935140193f));
		fConst3219 = mydsp_faustpower2_f(fConst3216);
		fConst3220 = (50.0638084f / fConst3219);
		fConst3221 = (fConst3220 + 0.935140193f);
		fConst3222 = (1.0f / (((fConst3217 + 0.743130445f) / fConst3216) + 1.4500711f));
		fConst3223 = (11.0520525f / fConst3219);
		fConst3224 = (fConst3223 + 1.4500711f);
		fConst3225 = (1.0f / (((fConst3217 + 3.18972731f) / fConst3216) + 4.07678175f));
		fConst3226 = (0.00176617282f / fConst3219);
		fConst3227 = (fConst3226 + 0.000407678192f);
		fConst3228 = (1.0f / (((fConst3179 + 0.168404877f) / fConst3178) + 1.06935835f));
		fConst3229 = (fConst3207 + 53.5361519f);
		fConst3230 = (1.0f / (((fConst3179 + 0.51247865f) / fConst3178) + 0.689621389f));
		fConst3231 = (fConst3207 + 7.62173128f);
		fConst3232 = (1.0f / (((fConst3179 + 0.782413065f) / fConst3178) + 0.245291501f));
		fConst3233 = (9.99999975e-05f / fConst3181);
		fConst3234 = (fConst3233 + 0.000433227193f);
		fConst3235 = (((fConst3179 + -0.782413065f) / fConst3178) + 0.245291501f);
		fConst3236 = (2.0f * (0.245291501f - fConst3207));
		fConst3237 = (2.0f * (0.000433227193f - fConst3233));
		fConst3238 = (((fConst3179 + -0.51247865f) / fConst3178) + 0.689621389f);
		fConst3239 = (2.0f * (0.689621389f - fConst3207));
		fConst3240 = (2.0f * (7.62173128f - fConst3207));
		fConst3241 = (((fConst3179 + -0.168404877f) / fConst3178) + 1.06935835f);
		fConst3242 = (2.0f * (1.06935835f - fConst3207));
		fConst3243 = (2.0f * (53.5361519f - fConst3207));
		fConst3244 = (((fConst3217 + -3.18972731f) / fConst3216) + 4.07678175f);
		fConst3245 = (1.0f / fConst3219);
		fConst3246 = (2.0f * (4.07678175f - fConst3245));
		fConst3247 = (2.0f * (0.000407678192f - fConst3226));
		fConst3248 = (((fConst3217 + -0.743130445f) / fConst3216) + 1.4500711f);
		fConst3249 = (2.0f * (1.4500711f - fConst3245));
		fConst3250 = (2.0f * (1.4500711f - fConst3223));
		fConst3251 = (((fConst3217 + -0.157482162f) / fConst3216) + 0.935140193f);
		fConst3252 = (2.0f * (0.935140193f - fConst3245));
		fConst3253 = (2.0f * (0.935140193f - fConst3220));
		fConst3254 = std::tan((437.318878f / fConst0));
		fConst3255 = (1.0f / fConst3254);
		fConst3256 = (1.0f / (((fConst3255 + 0.157482162f) / fConst3254) + 0.935140193f));
		fConst3257 = mydsp_faustpower2_f(fConst3254);
		fConst3258 = (50.0638084f / fConst3257);
		fConst3259 = (fConst3258 + 0.935140193f);
		fConst3260 = (1.0f / (((fConst3255 + 0.743130445f) / fConst3254) + 1.4500711f));
		fConst3261 = (11.0520525f / fConst3257);
		fConst3262 = (fConst3261 + 1.4500711f);
		fConst3263 = (1.0f / (((fConst3255 + 3.18972731f) / fConst3254) + 4.07678175f));
		fConst3264 = (0.00176617282f / fConst3257);
		fConst3265 = (fConst3264 + 0.000407678192f);
		fConst3266 = (1.0f / (((fConst3217 + 0.168404877f) / fConst3216) + 1.06935835f));
		fConst3267 = (fConst3245 + 53.5361519f);
		fConst3268 = (1.0f / (((fConst3217 + 0.51247865f) / fConst3216) + 0.689621389f));
		fConst3269 = (fConst3245 + 7.62173128f);
		fConst3270 = (1.0f / (((fConst3217 + 0.782413065f) / fConst3216) + 0.245291501f));
		fConst3271 = (9.99999975e-05f / fConst3219);
		fConst3272 = (fConst3271 + 0.000433227193f);
		fConst3273 = (((fConst3217 + -0.782413065f) / fConst3216) + 0.245291501f);
		fConst3274 = (2.0f * (0.245291501f - fConst3245));
		fConst3275 = (2.0f * (0.000433227193f - fConst3271));
		fConst3276 = (((fConst3217 + -0.51247865f) / fConst3216) + 0.689621389f);
		fConst3277 = (2.0f * (0.689621389f - fConst3245));
		fConst3278 = (2.0f * (7.62173128f - fConst3245));
		fConst3279 = (((fConst3217 + -0.168404877f) / fConst3216) + 1.06935835f);
		fConst3280 = (2.0f * (1.06935835f - fConst3245));
		fConst3281 = (2.0f * (53.5361519f - fConst3245));
		fConst3282 = (((fConst3255 + -3.18972731f) / fConst3254) + 4.07678175f);
		fConst3283 = (1.0f / fConst3257);
		fConst3284 = (2.0f * (4.07678175f - fConst3283));
		fConst3285 = (2.0f * (0.000407678192f - fConst3264));
		fConst3286 = (((fConst3255 + -0.743130445f) / fConst3254) + 1.4500711f);
		fConst3287 = (2.0f * (1.4500711f - fConst3283));
		fConst3288 = (2.0f * (1.4500711f - fConst3261));
		fConst3289 = (((fConst3255 + -0.157482162f) / fConst3254) + 0.935140193f);
		fConst3290 = (2.0f * (0.935140193f - fConst3283));
		fConst3291 = (2.0f * (0.935140193f - fConst3258));
		fConst3292 = std::tan((412.774048f / fConst0));
		fConst3293 = (1.0f / fConst3292);
		fConst3294 = (1.0f / (((fConst3293 + 0.157482162f) / fConst3292) + 0.935140193f));
		fConst3295 = mydsp_faustpower2_f(fConst3292);
		fConst3296 = (50.0638084f / fConst3295);
		fConst3297 = (fConst3296 + 0.935140193f);
		fConst3298 = (1.0f / (((fConst3293 + 0.743130445f) / fConst3292) + 1.4500711f));
		fConst3299 = (11.0520525f / fConst3295);
		fConst3300 = (fConst3299 + 1.4500711f);
		fConst3301 = (1.0f / (((fConst3293 + 3.18972731f) / fConst3292) + 4.07678175f));
		fConst3302 = (0.00176617282f / fConst3295);
		fConst3303 = (fConst3302 + 0.000407678192f);
		fConst3304 = (1.0f / (((fConst3255 + 0.168404877f) / fConst3254) + 1.06935835f));
		fConst3305 = (fConst3283 + 53.5361519f);
		fConst3306 = (1.0f / (((fConst3255 + 0.51247865f) / fConst3254) + 0.689621389f));
		fConst3307 = (fConst3283 + 7.62173128f);
		fConst3308 = (1.0f / (((fConst3255 + 0.782413065f) / fConst3254) + 0.245291501f));
		fConst3309 = (9.99999975e-05f / fConst3257);
		fConst3310 = (fConst3309 + 0.000433227193f);
		fConst3311 = (((fConst3255 + -0.782413065f) / fConst3254) + 0.245291501f);
		fConst3312 = (2.0f * (0.245291501f - fConst3283));
		fConst3313 = (2.0f * (0.000433227193f - fConst3309));
		fConst3314 = (((fConst3255 + -0.51247865f) / fConst3254) + 0.689621389f);
		fConst3315 = (2.0f * (0.689621389f - fConst3283));
		fConst3316 = (2.0f * (7.62173128f - fConst3283));
		fConst3317 = (((fConst3255 + -0.168404877f) / fConst3254) + 1.06935835f);
		fConst3318 = (2.0f * (1.06935835f - fConst3283));
		fConst3319 = (2.0f * (53.5361519f - fConst3283));
		fConst3320 = (((fConst3293 + -3.18972731f) / fConst3292) + 4.07678175f);
		fConst3321 = (1.0f / fConst3295);
		fConst3322 = (2.0f * (4.07678175f - fConst3321));
		fConst3323 = (2.0f * (0.000407678192f - fConst3302));
		fConst3324 = (((fConst3293 + -0.743130445f) / fConst3292) + 1.4500711f);
		fConst3325 = (2.0f * (1.4500711f - fConst3321));
		fConst3326 = (2.0f * (1.4500711f - fConst3299));
		fConst3327 = (((fConst3293 + -0.157482162f) / fConst3292) + 0.935140193f);
		fConst3328 = (2.0f * (0.935140193f - fConst3321));
		fConst3329 = (2.0f * (0.935140193f - fConst3296));
		fConst3330 = std::tan((389.606842f / fConst0));
		fConst3331 = (1.0f / fConst3330);
		fConst3332 = (1.0f / (((fConst3331 + 0.157482162f) / fConst3330) + 0.935140193f));
		fConst3333 = mydsp_faustpower2_f(fConst3330);
		fConst3334 = (50.0638084f / fConst3333);
		fConst3335 = (fConst3334 + 0.935140193f);
		fConst3336 = (1.0f / (((fConst3331 + 0.743130445f) / fConst3330) + 1.4500711f));
		fConst3337 = (11.0520525f / fConst3333);
		fConst3338 = (fConst3337 + 1.4500711f);
		fConst3339 = (1.0f / (((fConst3331 + 3.18972731f) / fConst3330) + 4.07678175f));
		fConst3340 = (0.00176617282f / fConst3333);
		fConst3341 = (fConst3340 + 0.000407678192f);
		fConst3342 = (1.0f / (((fConst3293 + 0.168404877f) / fConst3292) + 1.06935835f));
		fConst3343 = (fConst3321 + 53.5361519f);
		fConst3344 = (1.0f / (((fConst3293 + 0.51247865f) / fConst3292) + 0.689621389f));
		fConst3345 = (fConst3321 + 7.62173128f);
		fConst3346 = (1.0f / (((fConst3293 + 0.782413065f) / fConst3292) + 0.245291501f));
		fConst3347 = (9.99999975e-05f / fConst3295);
		fConst3348 = (fConst3347 + 0.000433227193f);
		fConst3349 = (((fConst3293 + -0.782413065f) / fConst3292) + 0.245291501f);
		fConst3350 = (2.0f * (0.245291501f - fConst3321));
		fConst3351 = (2.0f * (0.000433227193f - fConst3347));
		fConst3352 = (((fConst3293 + -0.51247865f) / fConst3292) + 0.689621389f);
		fConst3353 = (2.0f * (0.689621389f - fConst3321));
		fConst3354 = (2.0f * (7.62173128f - fConst3321));
		fConst3355 = (((fConst3293 + -0.168404877f) / fConst3292) + 1.06935835f);
		fConst3356 = (2.0f * (1.06935835f - fConst3321));
		fConst3357 = (2.0f * (53.5361519f - fConst3321));
		fConst3358 = (((fConst3331 + -3.18972731f) / fConst3330) + 4.07678175f);
		fConst3359 = (1.0f / fConst3333);
		fConst3360 = (2.0f * (4.07678175f - fConst3359));
		fConst3361 = (2.0f * (0.000407678192f - fConst3340));
		fConst3362 = (((fConst3331 + -0.743130445f) / fConst3330) + 1.4500711f);
		fConst3363 = (2.0f * (1.4500711f - fConst3359));
		fConst3364 = (2.0f * (1.4500711f - fConst3337));
		fConst3365 = (((fConst3331 + -0.157482162f) / fConst3330) + 0.935140193f);
		fConst3366 = (2.0f * (0.935140193f - fConst3359));
		fConst3367 = (2.0f * (0.935140193f - fConst3334));
		fConst3368 = std::tan((367.739868f / fConst0));
		fConst3369 = (1.0f / fConst3368);
		fConst3370 = (1.0f / (((fConst3369 + 0.157482162f) / fConst3368) + 0.935140193f));
		fConst3371 = mydsp_faustpower2_f(fConst3368);
		fConst3372 = (50.0638084f / fConst3371);
		fConst3373 = (fConst3372 + 0.935140193f);
		fConst3374 = (1.0f / (((fConst3369 + 0.743130445f) / fConst3368) + 1.4500711f));
		fConst3375 = (11.0520525f / fConst3371);
		fConst3376 = (fConst3375 + 1.4500711f);
		fConst3377 = (1.0f / (((fConst3369 + 3.18972731f) / fConst3368) + 4.07678175f));
		fConst3378 = (0.00176617282f / fConst3371);
		fConst3379 = (fConst3378 + 0.000407678192f);
		fConst3380 = (1.0f / (((fConst3331 + 0.168404877f) / fConst3330) + 1.06935835f));
		fConst3381 = (fConst3359 + 53.5361519f);
		fConst3382 = (1.0f / (((fConst3331 + 0.51247865f) / fConst3330) + 0.689621389f));
		fConst3383 = (fConst3359 + 7.62173128f);
		fConst3384 = (1.0f / (((fConst3331 + 0.782413065f) / fConst3330) + 0.245291501f));
		fConst3385 = (9.99999975e-05f / fConst3333);
		fConst3386 = (fConst3385 + 0.000433227193f);
		fConst3387 = (((fConst3331 + -0.782413065f) / fConst3330) + 0.245291501f);
		fConst3388 = (2.0f * (0.245291501f - fConst3359));
		fConst3389 = (2.0f * (0.000433227193f - fConst3385));
		fConst3390 = (((fConst3331 + -0.51247865f) / fConst3330) + 0.689621389f);
		fConst3391 = (2.0f * (0.689621389f - fConst3359));
		fConst3392 = (2.0f * (7.62173128f - fConst3359));
		fConst3393 = (((fConst3331 + -0.168404877f) / fConst3330) + 1.06935835f);
		fConst3394 = (2.0f * (1.06935835f - fConst3359));
		fConst3395 = (2.0f * (53.5361519f - fConst3359));
		fConst3396 = (((fConst3369 + -3.18972731f) / fConst3368) + 4.07678175f);
		fConst3397 = (1.0f / fConst3371);
		fConst3398 = (2.0f * (4.07678175f - fConst3397));
		fConst3399 = (2.0f * (0.000407678192f - fConst3378));
		fConst3400 = (((fConst3369 + -0.743130445f) / fConst3368) + 1.4500711f);
		fConst3401 = (2.0f * (1.4500711f - fConst3397));
		fConst3402 = (2.0f * (1.4500711f - fConst3375));
		fConst3403 = (((fConst3369 + -0.157482162f) / fConst3368) + 0.935140193f);
		fConst3404 = (2.0f * (0.935140193f - fConst3397));
		fConst3405 = (2.0f * (0.935140193f - fConst3372));
		fConst3406 = std::tan((347.10022f / fConst0));
		fConst3407 = (1.0f / fConst3406);
		fConst3408 = (1.0f / (((fConst3407 + 0.157482162f) / fConst3406) + 0.935140193f));
		fConst3409 = mydsp_faustpower2_f(fConst3406);
		fConst3410 = (50.0638084f / fConst3409);
		fConst3411 = (fConst3410 + 0.935140193f);
		fConst3412 = (1.0f / (((fConst3407 + 0.743130445f) / fConst3406) + 1.4500711f));
		fConst3413 = (11.0520525f / fConst3409);
		fConst3414 = (fConst3413 + 1.4500711f);
		fConst3415 = (1.0f / (((fConst3407 + 3.18972731f) / fConst3406) + 4.07678175f));
		fConst3416 = (0.00176617282f / fConst3409);
		fConst3417 = (fConst3416 + 0.000407678192f);
		fConst3418 = (1.0f / (((fConst3369 + 0.168404877f) / fConst3368) + 1.06935835f));
		fConst3419 = (fConst3397 + 53.5361519f);
		fConst3420 = (1.0f / (((fConst3369 + 0.51247865f) / fConst3368) + 0.689621389f));
		fConst3421 = (fConst3397 + 7.62173128f);
		fConst3422 = (1.0f / (((fConst3369 + 0.782413065f) / fConst3368) + 0.245291501f));
		fConst3423 = (9.99999975e-05f / fConst3371);
		fConst3424 = (fConst3423 + 0.000433227193f);
		fConst3425 = (((fConst3369 + -0.782413065f) / fConst3368) + 0.245291501f);
		fConst3426 = (2.0f * (0.245291501f - fConst3397));
		fConst3427 = (2.0f * (0.000433227193f - fConst3423));
		fConst3428 = (((fConst3369 + -0.51247865f) / fConst3368) + 0.689621389f);
		fConst3429 = (2.0f * (0.689621389f - fConst3397));
		fConst3430 = (2.0f * (7.62173128f - fConst3397));
		fConst3431 = (((fConst3369 + -0.168404877f) / fConst3368) + 1.06935835f);
		fConst3432 = (2.0f * (1.06935835f - fConst3397));
		fConst3433 = (2.0f * (53.5361519f - fConst3397));
		fConst3434 = (((fConst3407 + -3.18972731f) / fConst3406) + 4.07678175f);
		fConst3435 = (1.0f / fConst3409);
		fConst3436 = (2.0f * (4.07678175f - fConst3435));
		fConst3437 = (2.0f * (0.000407678192f - fConst3416));
		fConst3438 = (((fConst3407 + -0.743130445f) / fConst3406) + 1.4500711f);
		fConst3439 = (2.0f * (1.4500711f - fConst3435));
		fConst3440 = (2.0f * (1.4500711f - fConst3413));
		fConst3441 = (((fConst3407 + -0.157482162f) / fConst3406) + 0.935140193f);
		fConst3442 = (2.0f * (0.935140193f - fConst3435));
		fConst3443 = (2.0f * (0.935140193f - fConst3410));
		fConst3444 = std::tan((327.618988f / fConst0));
		fConst3445 = (1.0f / fConst3444);
		fConst3446 = (1.0f / (((fConst3445 + 0.157482162f) / fConst3444) + 0.935140193f));
		fConst3447 = mydsp_faustpower2_f(fConst3444);
		fConst3448 = (50.0638084f / fConst3447);
		fConst3449 = (fConst3448 + 0.935140193f);
		fConst3450 = (1.0f / (((fConst3445 + 0.743130445f) / fConst3444) + 1.4500711f));
		fConst3451 = (11.0520525f / fConst3447);
		fConst3452 = (fConst3451 + 1.4500711f);
		fConst3453 = (1.0f / (((fConst3445 + 3.18972731f) / fConst3444) + 4.07678175f));
		fConst3454 = (0.00176617282f / fConst3447);
		fConst3455 = (fConst3454 + 0.000407678192f);
		fConst3456 = (1.0f / (((fConst3407 + 0.168404877f) / fConst3406) + 1.06935835f));
		fConst3457 = (fConst3435 + 53.5361519f);
		fConst3458 = (1.0f / (((fConst3407 + 0.51247865f) / fConst3406) + 0.689621389f));
		fConst3459 = (fConst3435 + 7.62173128f);
		fConst3460 = (1.0f / (((fConst3407 + 0.782413065f) / fConst3406) + 0.245291501f));
		fConst3461 = (9.99999975e-05f / fConst3409);
		fConst3462 = (fConst3461 + 0.000433227193f);
		fConst3463 = (((fConst3407 + -0.782413065f) / fConst3406) + 0.245291501f);
		fConst3464 = (2.0f * (0.245291501f - fConst3435));
		fConst3465 = (2.0f * (0.000433227193f - fConst3461));
		fConst3466 = (((fConst3407 + -0.51247865f) / fConst3406) + 0.689621389f);
		fConst3467 = (2.0f * (0.689621389f - fConst3435));
		fConst3468 = (2.0f * (7.62173128f - fConst3435));
		fConst3469 = (((fConst3407 + -0.168404877f) / fConst3406) + 1.06935835f);
		fConst3470 = (2.0f * (1.06935835f - fConst3435));
		fConst3471 = (2.0f * (53.5361519f - fConst3435));
		fConst3472 = (((fConst3445 + -3.18972731f) / fConst3444) + 4.07678175f);
		fConst3473 = (1.0f / fConst3447);
		fConst3474 = (2.0f * (4.07678175f - fConst3473));
		fConst3475 = (2.0f * (0.000407678192f - fConst3454));
		fConst3476 = (((fConst3445 + -0.743130445f) / fConst3444) + 1.4500711f);
		fConst3477 = (2.0f * (1.4500711f - fConst3473));
		fConst3478 = (2.0f * (1.4500711f - fConst3451));
		fConst3479 = (((fConst3445 + -0.157482162f) / fConst3444) + 0.935140193f);
		fConst3480 = (2.0f * (0.935140193f - fConst3473));
		fConst3481 = (2.0f * (0.935140193f - fConst3448));
		fConst3482 = std::tan((309.23114f / fConst0));
		fConst3483 = (1.0f / fConst3482);
		fConst3484 = (1.0f / (((fConst3483 + 0.157482162f) / fConst3482) + 0.935140193f));
		fConst3485 = mydsp_faustpower2_f(fConst3482);
		fConst3486 = (50.0638084f / fConst3485);
		fConst3487 = (fConst3486 + 0.935140193f);
		fConst3488 = (1.0f / (((fConst3483 + 0.743130445f) / fConst3482) + 1.4500711f));
		fConst3489 = (11.0520525f / fConst3485);
		fConst3490 = (fConst3489 + 1.4500711f);
		fConst3491 = (1.0f / (((fConst3483 + 3.18972731f) / fConst3482) + 4.07678175f));
		fConst3492 = (0.00176617282f / fConst3485);
		fConst3493 = (fConst3492 + 0.000407678192f);
		fConst3494 = (1.0f / (((fConst3445 + 0.168404877f) / fConst3444) + 1.06935835f));
		fConst3495 = (fConst3473 + 53.5361519f);
		fConst3496 = (1.0f / (((fConst3445 + 0.51247865f) / fConst3444) + 0.689621389f));
		fConst3497 = (fConst3473 + 7.62173128f);
		fConst3498 = (1.0f / (((fConst3445 + 0.782413065f) / fConst3444) + 0.245291501f));
		fConst3499 = (9.99999975e-05f / fConst3447);
		fConst3500 = (fConst3499 + 0.000433227193f);
		fConst3501 = (((fConst3445 + -0.782413065f) / fConst3444) + 0.245291501f);
		fConst3502 = (2.0f * (0.245291501f - fConst3473));
		fConst3503 = (2.0f * (0.000433227193f - fConst3499));
		fConst3504 = (((fConst3445 + -0.51247865f) / fConst3444) + 0.689621389f);
		fConst3505 = (2.0f * (0.689621389f - fConst3473));
		fConst3506 = (2.0f * (7.62173128f - fConst3473));
		fConst3507 = (((fConst3445 + -0.168404877f) / fConst3444) + 1.06935835f);
		fConst3508 = (2.0f * (1.06935835f - fConst3473));
		fConst3509 = (2.0f * (53.5361519f - fConst3473));
		fConst3510 = (((fConst3483 + -3.18972731f) / fConst3482) + 4.07678175f);
		fConst3511 = (1.0f / fConst3485);
		fConst3512 = (2.0f * (4.07678175f - fConst3511));
		fConst3513 = (2.0f * (0.000407678192f - fConst3492));
		fConst3514 = (((fConst3483 + -0.743130445f) / fConst3482) + 1.4500711f);
		fConst3515 = (2.0f * (1.4500711f - fConst3511));
		fConst3516 = (2.0f * (1.4500711f - fConst3489));
		fConst3517 = (((fConst3483 + -0.157482162f) / fConst3482) + 0.935140193f);
		fConst3518 = (2.0f * (0.935140193f - fConst3511));
		fConst3519 = (2.0f * (0.935140193f - fConst3486));
		fConst3520 = std::tan((291.875336f / fConst0));
		fConst3521 = (1.0f / fConst3520);
		fConst3522 = (1.0f / (((fConst3521 + 0.157482162f) / fConst3520) + 0.935140193f));
		fConst3523 = mydsp_faustpower2_f(fConst3520);
		fConst3524 = (50.0638084f / fConst3523);
		fConst3525 = (fConst3524 + 0.935140193f);
		fConst3526 = (1.0f / (((fConst3521 + 0.743130445f) / fConst3520) + 1.4500711f));
		fConst3527 = (11.0520525f / fConst3523);
		fConst3528 = (fConst3527 + 1.4500711f);
		fConst3529 = (1.0f / (((fConst3521 + 3.18972731f) / fConst3520) + 4.07678175f));
		fConst3530 = (0.00176617282f / fConst3523);
		fConst3531 = (fConst3530 + 0.000407678192f);
		fConst3532 = (1.0f / (((fConst3483 + 0.168404877f) / fConst3482) + 1.06935835f));
		fConst3533 = (fConst3511 + 53.5361519f);
		fConst3534 = (1.0f / (((fConst3483 + 0.51247865f) / fConst3482) + 0.689621389f));
		fConst3535 = (fConst3511 + 7.62173128f);
		fConst3536 = (1.0f / (((fConst3483 + 0.782413065f) / fConst3482) + 0.245291501f));
		fConst3537 = (9.99999975e-05f / fConst3485);
		fConst3538 = (fConst3537 + 0.000433227193f);
		fConst3539 = (((fConst3483 + -0.782413065f) / fConst3482) + 0.245291501f);
		fConst3540 = (2.0f * (0.245291501f - fConst3511));
		fConst3541 = (2.0f * (0.000433227193f - fConst3537));
		fConst3542 = (((fConst3483 + -0.51247865f) / fConst3482) + 0.689621389f);
		fConst3543 = (2.0f * (0.689621389f - fConst3511));
		fConst3544 = (2.0f * (7.62173128f - fConst3511));
		fConst3545 = (((fConst3483 + -0.168404877f) / fConst3482) + 1.06935835f);
		fConst3546 = (2.0f * (1.06935835f - fConst3511));
		fConst3547 = (2.0f * (53.5361519f - fConst3511));
		fConst3548 = (((fConst3521 + -3.18972731f) / fConst3520) + 4.07678175f);
		fConst3549 = (1.0f / fConst3523);
		fConst3550 = (2.0f * (4.07678175f - fConst3549));
		fConst3551 = (2.0f * (0.000407678192f - fConst3530));
		fConst3552 = (((fConst3521 + -0.743130445f) / fConst3520) + 1.4500711f);
		fConst3553 = (2.0f * (1.4500711f - fConst3549));
		fConst3554 = (2.0f * (1.4500711f - fConst3527));
		fConst3555 = (((fConst3521 + -0.157482162f) / fConst3520) + 0.935140193f);
		fConst3556 = (2.0f * (0.935140193f - fConst3549));
		fConst3557 = (2.0f * (0.935140193f - fConst3524));
		fConst3558 = std::tan((275.493622f / fConst0));
		fConst3559 = (1.0f / fConst3558);
		fConst3560 = (1.0f / (((fConst3559 + 0.157482162f) / fConst3558) + 0.935140193f));
		fConst3561 = mydsp_faustpower2_f(fConst3558);
		fConst3562 = (50.0638084f / fConst3561);
		fConst3563 = (fConst3562 + 0.935140193f);
		fConst3564 = (1.0f / (((fConst3559 + 0.743130445f) / fConst3558) + 1.4500711f));
		fConst3565 = (11.0520525f / fConst3561);
		fConst3566 = (fConst3565 + 1.4500711f);
		fConst3567 = (1.0f / (((fConst3559 + 3.18972731f) / fConst3558) + 4.07678175f));
		fConst3568 = (0.00176617282f / fConst3561);
		fConst3569 = (fConst3568 + 0.000407678192f);
		fConst3570 = (1.0f / (((fConst3521 + 0.168404877f) / fConst3520) + 1.06935835f));
		fConst3571 = (fConst3549 + 53.5361519f);
		fConst3572 = (1.0f / (((fConst3521 + 0.51247865f) / fConst3520) + 0.689621389f));
		fConst3573 = (fConst3549 + 7.62173128f);
		fConst3574 = (1.0f / (((fConst3521 + 0.782413065f) / fConst3520) + 0.245291501f));
		fConst3575 = (9.99999975e-05f / fConst3523);
		fConst3576 = (fConst3575 + 0.000433227193f);
		fConst3577 = (((fConst3521 + -0.782413065f) / fConst3520) + 0.245291501f);
		fConst3578 = (2.0f * (0.245291501f - fConst3549));
		fConst3579 = (2.0f * (0.000433227193f - fConst3575));
		fConst3580 = (((fConst3521 + -0.51247865f) / fConst3520) + 0.689621389f);
		fConst3581 = (2.0f * (0.689621389f - fConst3549));
		fConst3582 = (2.0f * (7.62173128f - fConst3549));
		fConst3583 = (((fConst3521 + -0.168404877f) / fConst3520) + 1.06935835f);
		fConst3584 = (2.0f * (1.06935835f - fConst3549));
		fConst3585 = (2.0f * (53.5361519f - fConst3549));
		fConst3586 = (((fConst3559 + -3.18972731f) / fConst3558) + 4.07678175f);
		fConst3587 = (1.0f / fConst3561);
		fConst3588 = (2.0f * (4.07678175f - fConst3587));
		fConst3589 = (2.0f * (0.000407678192f - fConst3568));
		fConst3590 = (((fConst3559 + -0.743130445f) / fConst3558) + 1.4500711f);
		fConst3591 = (2.0f * (1.4500711f - fConst3587));
		fConst3592 = (2.0f * (1.4500711f - fConst3565));
		fConst3593 = (((fConst3559 + -0.157482162f) / fConst3558) + 0.935140193f);
		fConst3594 = (2.0f * (0.935140193f - fConst3587));
		fConst3595 = (2.0f * (0.935140193f - fConst3562));
		fConst3596 = std::tan((260.031372f / fConst0));
		fConst3597 = (1.0f / fConst3596);
		fConst3598 = (1.0f / (((fConst3597 + 0.157482162f) / fConst3596) + 0.935140193f));
		fConst3599 = mydsp_faustpower2_f(fConst3596);
		fConst3600 = (50.0638084f / fConst3599);
		fConst3601 = (fConst3600 + 0.935140193f);
		fConst3602 = (1.0f / (((fConst3597 + 0.743130445f) / fConst3596) + 1.4500711f));
		fConst3603 = (11.0520525f / fConst3599);
		fConst3604 = (fConst3603 + 1.4500711f);
		fConst3605 = (1.0f / (((fConst3597 + 3.18972731f) / fConst3596) + 4.07678175f));
		fConst3606 = (0.00176617282f / fConst3599);
		fConst3607 = (fConst3606 + 0.000407678192f);
		fConst3608 = (1.0f / (((fConst3559 + 0.168404877f) / fConst3558) + 1.06935835f));
		fConst3609 = (fConst3587 + 53.5361519f);
		fConst3610 = (1.0f / (((fConst3559 + 0.51247865f) / fConst3558) + 0.689621389f));
		fConst3611 = (fConst3587 + 7.62173128f);
		fConst3612 = (1.0f / (((fConst3559 + 0.782413065f) / fConst3558) + 0.245291501f));
		fConst3613 = (9.99999975e-05f / fConst3561);
		fConst3614 = (fConst3613 + 0.000433227193f);
		fConst3615 = (((fConst3559 + -0.782413065f) / fConst3558) + 0.245291501f);
		fConst3616 = (2.0f * (0.245291501f - fConst3587));
		fConst3617 = (2.0f * (0.000433227193f - fConst3613));
		fConst3618 = (((fConst3559 + -0.51247865f) / fConst3558) + 0.689621389f);
		fConst3619 = (2.0f * (0.689621389f - fConst3587));
		fConst3620 = (2.0f * (7.62173128f - fConst3587));
		fConst3621 = (((fConst3559 + -0.168404877f) / fConst3558) + 1.06935835f);
		fConst3622 = (2.0f * (1.06935835f - fConst3587));
		fConst3623 = (2.0f * (53.5361519f - fConst3587));
		fConst3624 = (((fConst3597 + -3.18972731f) / fConst3596) + 4.07678175f);
		fConst3625 = (1.0f / fConst3599);
		fConst3626 = (2.0f * (4.07678175f - fConst3625));
		fConst3627 = (2.0f * (0.000407678192f - fConst3606));
		fConst3628 = (((fConst3597 + -0.743130445f) / fConst3596) + 1.4500711f);
		fConst3629 = (2.0f * (1.4500711f - fConst3625));
		fConst3630 = (2.0f * (1.4500711f - fConst3603));
		fConst3631 = (((fConst3597 + -0.157482162f) / fConst3596) + 0.935140193f);
		fConst3632 = (2.0f * (0.935140193f - fConst3625));
		fConst3633 = (2.0f * (0.935140193f - fConst3600));
		fConst3634 = std::tan((245.43692f / fConst0));
		fConst3635 = (1.0f / fConst3634);
		fConst3636 = (1.0f / (((fConst3635 + 0.157482162f) / fConst3634) + 0.935140193f));
		fConst3637 = mydsp_faustpower2_f(fConst3634);
		fConst3638 = (50.0638084f / fConst3637);
		fConst3639 = (fConst3638 + 0.935140193f);
		fConst3640 = (1.0f / (((fConst3635 + 0.743130445f) / fConst3634) + 1.4500711f));
		fConst3641 = (11.0520525f / fConst3637);
		fConst3642 = (fConst3641 + 1.4500711f);
		fConst3643 = (1.0f / (((fConst3635 + 3.18972731f) / fConst3634) + 4.07678175f));
		fConst3644 = (0.00176617282f / fConst3637);
		fConst3645 = (fConst3644 + 0.000407678192f);
		fConst3646 = (1.0f / (((fConst3597 + 0.168404877f) / fConst3596) + 1.06935835f));
		fConst3647 = (fConst3625 + 53.5361519f);
		fConst3648 = (1.0f / (((fConst3597 + 0.51247865f) / fConst3596) + 0.689621389f));
		fConst3649 = (fConst3625 + 7.62173128f);
		fConst3650 = (1.0f / (((fConst3597 + 0.782413065f) / fConst3596) + 0.245291501f));
		fConst3651 = (9.99999975e-05f / fConst3599);
		fConst3652 = (fConst3651 + 0.000433227193f);
		fConst3653 = (((fConst3597 + -0.782413065f) / fConst3596) + 0.245291501f);
		fConst3654 = (2.0f * (0.245291501f - fConst3625));
		fConst3655 = (2.0f * (0.000433227193f - fConst3651));
		fConst3656 = (((fConst3597 + -0.51247865f) / fConst3596) + 0.689621389f);
		fConst3657 = (2.0f * (0.689621389f - fConst3625));
		fConst3658 = (2.0f * (7.62173128f - fConst3625));
		fConst3659 = (((fConst3597 + -0.168404877f) / fConst3596) + 1.06935835f);
		fConst3660 = (2.0f * (1.06935835f - fConst3625));
		fConst3661 = (2.0f * (53.5361519f - fConst3625));
		fConst3662 = (((fConst3635 + -3.18972731f) / fConst3634) + 4.07678175f);
		fConst3663 = (1.0f / fConst3637);
		fConst3664 = (2.0f * (4.07678175f - fConst3663));
		fConst3665 = (2.0f * (0.000407678192f - fConst3644));
		fConst3666 = (((fConst3635 + -0.743130445f) / fConst3634) + 1.4500711f);
		fConst3667 = (2.0f * (1.4500711f - fConst3663));
		fConst3668 = (2.0f * (1.4500711f - fConst3641));
		fConst3669 = (((fConst3635 + -0.157482162f) / fConst3634) + 0.935140193f);
		fConst3670 = (2.0f * (0.935140193f - fConst3663));
		fConst3671 = (2.0f * (0.935140193f - fConst3638));
		fConst3672 = std::tan((231.661606f / fConst0));
		fConst3673 = (1.0f / fConst3672);
		fConst3674 = (1.0f / (((fConst3673 + 0.157482162f) / fConst3672) + 0.935140193f));
		fConst3675 = mydsp_faustpower2_f(fConst3672);
		fConst3676 = (50.0638084f / fConst3675);
		fConst3677 = (fConst3676 + 0.935140193f);
		fConst3678 = (1.0f / (((fConst3673 + 0.743130445f) / fConst3672) + 1.4500711f));
		fConst3679 = (11.0520525f / fConst3675);
		fConst3680 = (fConst3679 + 1.4500711f);
		fConst3681 = (1.0f / (((fConst3673 + 3.18972731f) / fConst3672) + 4.07678175f));
		fConst3682 = (0.00176617282f / fConst3675);
		fConst3683 = (fConst3682 + 0.000407678192f);
		fConst3684 = (1.0f / (((fConst3635 + 0.168404877f) / fConst3634) + 1.06935835f));
		fConst3685 = (fConst3663 + 53.5361519f);
		fConst3686 = (1.0f / (((fConst3635 + 0.51247865f) / fConst3634) + 0.689621389f));
		fConst3687 = (fConst3663 + 7.62173128f);
		fConst3688 = (1.0f / (((fConst3635 + 0.782413065f) / fConst3634) + 0.245291501f));
		fConst3689 = (9.99999975e-05f / fConst3637);
		fConst3690 = (fConst3689 + 0.000433227193f);
		fConst3691 = (((fConst3635 + -0.782413065f) / fConst3634) + 0.245291501f);
		fConst3692 = (2.0f * (0.245291501f - fConst3663));
		fConst3693 = (2.0f * (0.000433227193f - fConst3689));
		fConst3694 = (((fConst3635 + -0.51247865f) / fConst3634) + 0.689621389f);
		fConst3695 = (2.0f * (0.689621389f - fConst3663));
		fConst3696 = (2.0f * (7.62173128f - fConst3663));
		fConst3697 = (((fConst3635 + -0.168404877f) / fConst3634) + 1.06935835f);
		fConst3698 = (2.0f * (1.06935835f - fConst3663));
		fConst3699 = (2.0f * (53.5361519f - fConst3663));
		fConst3700 = (((fConst3673 + -3.18972731f) / fConst3672) + 4.07678175f);
		fConst3701 = (1.0f / fConst3675);
		fConst3702 = (2.0f * (4.07678175f - fConst3701));
		fConst3703 = (2.0f * (0.000407678192f - fConst3682));
		fConst3704 = (((fConst3673 + -0.743130445f) / fConst3672) + 1.4500711f);
		fConst3705 = (2.0f * (1.4500711f - fConst3701));
		fConst3706 = (2.0f * (1.4500711f - fConst3679));
		fConst3707 = (((fConst3673 + -0.157482162f) / fConst3672) + 0.935140193f);
		fConst3708 = (2.0f * (0.935140193f - fConst3701));
		fConst3709 = (2.0f * (0.935140193f - fConst3676));
		fConst3710 = std::tan((218.659439f / fConst0));
		fConst3711 = (1.0f / fConst3710);
		fConst3712 = (1.0f / (((fConst3711 + 0.157482162f) / fConst3710) + 0.935140193f));
		fConst3713 = mydsp_faustpower2_f(fConst3710);
		fConst3714 = (50.0638084f / fConst3713);
		fConst3715 = (fConst3714 + 0.935140193f);
		fConst3716 = (1.0f / (((fConst3711 + 0.743130445f) / fConst3710) + 1.4500711f));
		fConst3717 = (11.0520525f / fConst3713);
		fConst3718 = (fConst3717 + 1.4500711f);
		fConst3719 = (1.0f / (((fConst3711 + 3.18972731f) / fConst3710) + 4.07678175f));
		fConst3720 = (0.00176617282f / fConst3713);
		fConst3721 = (fConst3720 + 0.000407678192f);
		fConst3722 = (1.0f / (((fConst3673 + 0.168404877f) / fConst3672) + 1.06935835f));
		fConst3723 = (fConst3701 + 53.5361519f);
		fConst3724 = (1.0f / (((fConst3673 + 0.51247865f) / fConst3672) + 0.689621389f));
		fConst3725 = (fConst3701 + 7.62173128f);
		fConst3726 = (1.0f / (((fConst3673 + 0.782413065f) / fConst3672) + 0.245291501f));
		fConst3727 = (9.99999975e-05f / fConst3675);
		fConst3728 = (fConst3727 + 0.000433227193f);
		fConst3729 = (((fConst3673 + -0.782413065f) / fConst3672) + 0.245291501f);
		fConst3730 = (2.0f * (0.245291501f - fConst3701));
		fConst3731 = (2.0f * (0.000433227193f - fConst3727));
		fConst3732 = (((fConst3673 + -0.51247865f) / fConst3672) + 0.689621389f);
		fConst3733 = (2.0f * (0.689621389f - fConst3701));
		fConst3734 = (2.0f * (7.62173128f - fConst3701));
		fConst3735 = (((fConst3673 + -0.168404877f) / fConst3672) + 1.06935835f);
		fConst3736 = (2.0f * (1.06935835f - fConst3701));
		fConst3737 = (2.0f * (53.5361519f - fConst3701));
		fConst3738 = (((fConst3711 + -3.18972731f) / fConst3710) + 4.07678175f);
		fConst3739 = (1.0f / fConst3713);
		fConst3740 = (2.0f * (4.07678175f - fConst3739));
		fConst3741 = (2.0f * (0.000407678192f - fConst3720));
		fConst3742 = (((fConst3711 + -0.743130445f) / fConst3710) + 1.4500711f);
		fConst3743 = (2.0f * (1.4500711f - fConst3739));
		fConst3744 = (2.0f * (1.4500711f - fConst3717));
		fConst3745 = (((fConst3711 + -0.157482162f) / fConst3710) + 0.935140193f);
		fConst3746 = (2.0f * (0.935140193f - fConst3739));
		fConst3747 = (2.0f * (0.935140193f - fConst3714));
		fConst3748 = std::tan((206.387024f / fConst0));
		fConst3749 = (1.0f / fConst3748);
		fConst3750 = (1.0f / (((fConst3749 + 0.157482162f) / fConst3748) + 0.935140193f));
		fConst3751 = mydsp_faustpower2_f(fConst3748);
		fConst3752 = (50.0638084f / fConst3751);
		fConst3753 = (fConst3752 + 0.935140193f);
		fConst3754 = (1.0f / (((fConst3749 + 0.743130445f) / fConst3748) + 1.4500711f));
		fConst3755 = (11.0520525f / fConst3751);
		fConst3756 = (fConst3755 + 1.4500711f);
		fConst3757 = (1.0f / (((fConst3749 + 3.18972731f) / fConst3748) + 4.07678175f));
		fConst3758 = (0.00176617282f / fConst3751);
		fConst3759 = (fConst3758 + 0.000407678192f);
		fConst3760 = (1.0f / (((fConst3711 + 0.168404877f) / fConst3710) + 1.06935835f));
		fConst3761 = (fConst3739 + 53.5361519f);
		fConst3762 = (1.0f / (((fConst3711 + 0.51247865f) / fConst3710) + 0.689621389f));
		fConst3763 = (fConst3739 + 7.62173128f);
		fConst3764 = (1.0f / (((fConst3711 + 0.782413065f) / fConst3710) + 0.245291501f));
		fConst3765 = (9.99999975e-05f / fConst3713);
		fConst3766 = (fConst3765 + 0.000433227193f);
		fConst3767 = (((fConst3711 + -0.782413065f) / fConst3710) + 0.245291501f);
		fConst3768 = (2.0f * (0.245291501f - fConst3739));
		fConst3769 = (2.0f * (0.000433227193f - fConst3765));
		fConst3770 = (((fConst3711 + -0.51247865f) / fConst3710) + 0.689621389f);
		fConst3771 = (2.0f * (0.689621389f - fConst3739));
		fConst3772 = (2.0f * (7.62173128f - fConst3739));
		fConst3773 = (((fConst3711 + -0.168404877f) / fConst3710) + 1.06935835f);
		fConst3774 = (2.0f * (1.06935835f - fConst3739));
		fConst3775 = (2.0f * (53.5361519f - fConst3739));
		fConst3776 = (((fConst3749 + -3.18972731f) / fConst3748) + 4.07678175f);
		fConst3777 = (1.0f / fConst3751);
		fConst3778 = (2.0f * (4.07678175f - fConst3777));
		fConst3779 = (2.0f * (0.000407678192f - fConst3758));
		fConst3780 = (((fConst3749 + -0.743130445f) / fConst3748) + 1.4500711f);
		fConst3781 = (2.0f * (1.4500711f - fConst3777));
		fConst3782 = (2.0f * (1.4500711f - fConst3755));
		fConst3783 = (((fConst3749 + -0.157482162f) / fConst3748) + 0.935140193f);
		fConst3784 = (2.0f * (0.935140193f - fConst3777));
		fConst3785 = (2.0f * (0.935140193f - fConst3752));
		fConst3786 = std::tan((194.803421f / fConst0));
		fConst3787 = (1.0f / fConst3786);
		fConst3788 = (1.0f / (((fConst3787 + 0.157482162f) / fConst3786) + 0.935140193f));
		fConst3789 = mydsp_faustpower2_f(fConst3786);
		fConst3790 = (50.0638084f / fConst3789);
		fConst3791 = (fConst3790 + 0.935140193f);
		fConst3792 = (1.0f / (((fConst3787 + 0.743130445f) / fConst3786) + 1.4500711f));
		fConst3793 = (11.0520525f / fConst3789);
		fConst3794 = (fConst3793 + 1.4500711f);
		fConst3795 = (1.0f / (((fConst3787 + 3.18972731f) / fConst3786) + 4.07678175f));
		fConst3796 = (0.00176617282f / fConst3789);
		fConst3797 = (fConst3796 + 0.000407678192f);
		fConst3798 = (1.0f / (((fConst3749 + 0.168404877f) / fConst3748) + 1.06935835f));
		fConst3799 = (fConst3777 + 53.5361519f);
		fConst3800 = (1.0f / (((fConst3749 + 0.51247865f) / fConst3748) + 0.689621389f));
		fConst3801 = (fConst3777 + 7.62173128f);
		fConst3802 = (1.0f / (((fConst3749 + 0.782413065f) / fConst3748) + 0.245291501f));
		fConst3803 = (9.99999975e-05f / fConst3751);
		fConst3804 = (fConst3803 + 0.000433227193f);
		fConst3805 = (((fConst3749 + -0.782413065f) / fConst3748) + 0.245291501f);
		fConst3806 = (2.0f * (0.245291501f - fConst3777));
		fConst3807 = (2.0f * (0.000433227193f - fConst3803));
		fConst3808 = (((fConst3749 + -0.51247865f) / fConst3748) + 0.689621389f);
		fConst3809 = (2.0f * (0.689621389f - fConst3777));
		fConst3810 = (2.0f * (7.62173128f - fConst3777));
		fConst3811 = (((fConst3749 + -0.168404877f) / fConst3748) + 1.06935835f);
		fConst3812 = (2.0f * (1.06935835f - fConst3777));
		fConst3813 = (2.0f * (53.5361519f - fConst3777));
		fConst3814 = (((fConst3787 + -3.18972731f) / fConst3786) + 4.07678175f);
		fConst3815 = (1.0f / fConst3789);
		fConst3816 = (2.0f * (4.07678175f - fConst3815));
		fConst3817 = (2.0f * (0.000407678192f - fConst3796));
		fConst3818 = (((fConst3787 + -0.743130445f) / fConst3786) + 1.4500711f);
		fConst3819 = (2.0f * (1.4500711f - fConst3815));
		fConst3820 = (2.0f * (1.4500711f - fConst3793));
		fConst3821 = (((fConst3787 + -0.157482162f) / fConst3786) + 0.935140193f);
		fConst3822 = (2.0f * (0.935140193f - fConst3815));
		fConst3823 = (2.0f * (0.935140193f - fConst3790));
		fConst3824 = std::tan((183.869934f / fConst0));
		fConst3825 = (1.0f / fConst3824);
		fConst3826 = (1.0f / (((fConst3825 + 0.157482162f) / fConst3824) + 0.935140193f));
		fConst3827 = mydsp_faustpower2_f(fConst3824);
		fConst3828 = (50.0638084f / fConst3827);
		fConst3829 = (fConst3828 + 0.935140193f);
		fConst3830 = (1.0f / (((fConst3825 + 0.743130445f) / fConst3824) + 1.4500711f));
		fConst3831 = (11.0520525f / fConst3827);
		fConst3832 = (fConst3831 + 1.4500711f);
		fConst3833 = (1.0f / (((fConst3825 + 3.18972731f) / fConst3824) + 4.07678175f));
		fConst3834 = (0.00176617282f / fConst3827);
		fConst3835 = (fConst3834 + 0.000407678192f);
		fConst3836 = (1.0f / (((fConst3787 + 0.168404877f) / fConst3786) + 1.06935835f));
		fConst3837 = (fConst3815 + 53.5361519f);
		fConst3838 = (1.0f / (((fConst3787 + 0.51247865f) / fConst3786) + 0.689621389f));
		fConst3839 = (fConst3815 + 7.62173128f);
		fConst3840 = (1.0f / (((fConst3787 + 0.782413065f) / fConst3786) + 0.245291501f));
		fConst3841 = (9.99999975e-05f / fConst3789);
		fConst3842 = (fConst3841 + 0.000433227193f);
		fConst3843 = (((fConst3787 + -0.782413065f) / fConst3786) + 0.245291501f);
		fConst3844 = (2.0f * (0.245291501f - fConst3815));
		fConst3845 = (2.0f * (0.000433227193f - fConst3841));
		fConst3846 = (((fConst3787 + -0.51247865f) / fConst3786) + 0.689621389f);
		fConst3847 = (2.0f * (0.689621389f - fConst3815));
		fConst3848 = (2.0f * (7.62173128f - fConst3815));
		fConst3849 = (((fConst3787 + -0.168404877f) / fConst3786) + 1.06935835f);
		fConst3850 = (2.0f * (1.06935835f - fConst3815));
		fConst3851 = (2.0f * (53.5361519f - fConst3815));
		fConst3852 = (((fConst3825 + -3.18972731f) / fConst3824) + 4.07678175f);
		fConst3853 = (1.0f / fConst3827);
		fConst3854 = (2.0f * (4.07678175f - fConst3853));
		fConst3855 = (2.0f * (0.000407678192f - fConst3834));
		fConst3856 = (((fConst3825 + -0.743130445f) / fConst3824) + 1.4500711f);
		fConst3857 = (2.0f * (1.4500711f - fConst3853));
		fConst3858 = (2.0f * (1.4500711f - fConst3831));
		fConst3859 = (((fConst3825 + -0.157482162f) / fConst3824) + 0.935140193f);
		fConst3860 = (2.0f * (0.935140193f - fConst3853));
		fConst3861 = (2.0f * (0.935140193f - fConst3828));
		fConst3862 = std::tan((173.55011f / fConst0));
		fConst3863 = (1.0f / fConst3862);
		fConst3864 = (1.0f / (((fConst3863 + 0.157482162f) / fConst3862) + 0.935140193f));
		fConst3865 = mydsp_faustpower2_f(fConst3862);
		fConst3866 = (50.0638084f / fConst3865);
		fConst3867 = (fConst3866 + 0.935140193f);
		fConst3868 = (1.0f / (((fConst3863 + 0.743130445f) / fConst3862) + 1.4500711f));
		fConst3869 = (11.0520525f / fConst3865);
		fConst3870 = (fConst3869 + 1.4500711f);
		fConst3871 = (1.0f / (((fConst3863 + 3.18972731f) / fConst3862) + 4.07678175f));
		fConst3872 = (0.00176617282f / fConst3865);
		fConst3873 = (fConst3872 + 0.000407678192f);
		fConst3874 = (1.0f / (((fConst3825 + 0.168404877f) / fConst3824) + 1.06935835f));
		fConst3875 = (fConst3853 + 53.5361519f);
		fConst3876 = (1.0f / (((fConst3825 + 0.51247865f) / fConst3824) + 0.689621389f));
		fConst3877 = (fConst3853 + 7.62173128f);
		fConst3878 = (1.0f / (((fConst3825 + 0.782413065f) / fConst3824) + 0.245291501f));
		fConst3879 = (9.99999975e-05f / fConst3827);
		fConst3880 = (fConst3879 + 0.000433227193f);
		fConst3881 = (((fConst3825 + -0.782413065f) / fConst3824) + 0.245291501f);
		fConst3882 = (2.0f * (0.245291501f - fConst3853));
		fConst3883 = (2.0f * (0.000433227193f - fConst3879));
		fConst3884 = (((fConst3825 + -0.51247865f) / fConst3824) + 0.689621389f);
		fConst3885 = (2.0f * (0.689621389f - fConst3853));
		fConst3886 = (2.0f * (7.62173128f - fConst3853));
		fConst3887 = (((fConst3825 + -0.168404877f) / fConst3824) + 1.06935835f);
		fConst3888 = (2.0f * (1.06935835f - fConst3853));
		fConst3889 = (2.0f * (53.5361519f - fConst3853));
		fConst3890 = (((fConst3863 + -3.18972731f) / fConst3862) + 4.07678175f);
		fConst3891 = (1.0f / fConst3865);
		fConst3892 = (2.0f * (4.07678175f - fConst3891));
		fConst3893 = (2.0f * (0.000407678192f - fConst3872));
		fConst3894 = (((fConst3863 + -0.743130445f) / fConst3862) + 1.4500711f);
		fConst3895 = (2.0f * (1.4500711f - fConst3891));
		fConst3896 = (2.0f * (1.4500711f - fConst3869));
		fConst3897 = (((fConst3863 + -0.157482162f) / fConst3862) + 0.935140193f);
		fConst3898 = (2.0f * (0.935140193f - fConst3891));
		fConst3899 = (2.0f * (0.935140193f - fConst3866));
		fConst3900 = std::tan((163.809494f / fConst0));
		fConst3901 = (1.0f / fConst3900);
		fConst3902 = (1.0f / (((fConst3901 + 0.157482162f) / fConst3900) + 0.935140193f));
		fConst3903 = mydsp_faustpower2_f(fConst3900);
		fConst3904 = (50.0638084f / fConst3903);
		fConst3905 = (fConst3904 + 0.935140193f);
		fConst3906 = (1.0f / (((fConst3901 + 0.743130445f) / fConst3900) + 1.4500711f));
		fConst3907 = (11.0520525f / fConst3903);
		fConst3908 = (fConst3907 + 1.4500711f);
		fConst3909 = (1.0f / (((fConst3901 + 3.18972731f) / fConst3900) + 4.07678175f));
		fConst3910 = (0.00176617282f / fConst3903);
		fConst3911 = (fConst3910 + 0.000407678192f);
		fConst3912 = (1.0f / (((fConst3863 + 0.168404877f) / fConst3862) + 1.06935835f));
		fConst3913 = (fConst3891 + 53.5361519f);
		fConst3914 = (1.0f / (((fConst3863 + 0.51247865f) / fConst3862) + 0.689621389f));
		fConst3915 = (fConst3891 + 7.62173128f);
		fConst3916 = (1.0f / (((fConst3863 + 0.782413065f) / fConst3862) + 0.245291501f));
		fConst3917 = (9.99999975e-05f / fConst3865);
		fConst3918 = (fConst3917 + 0.000433227193f);
		fConst3919 = (((fConst3863 + -0.782413065f) / fConst3862) + 0.245291501f);
		fConst3920 = (2.0f * (0.245291501f - fConst3891));
		fConst3921 = (2.0f * (0.000433227193f - fConst3917));
		fConst3922 = (((fConst3863 + -0.51247865f) / fConst3862) + 0.689621389f);
		fConst3923 = (2.0f * (0.689621389f - fConst3891));
		fConst3924 = (2.0f * (7.62173128f - fConst3891));
		fConst3925 = (((fConst3863 + -0.168404877f) / fConst3862) + 1.06935835f);
		fConst3926 = (2.0f * (1.06935835f - fConst3891));
		fConst3927 = (2.0f * (53.5361519f - fConst3891));
		fConst3928 = (((fConst3901 + -3.18972731f) / fConst3900) + 4.07678175f);
		fConst3929 = (1.0f / fConst3903);
		fConst3930 = (2.0f * (4.07678175f - fConst3929));
		fConst3931 = (2.0f * (0.000407678192f - fConst3910));
		fConst3932 = (((fConst3901 + -0.743130445f) / fConst3900) + 1.4500711f);
		fConst3933 = (2.0f * (1.4500711f - fConst3929));
		fConst3934 = (2.0f * (1.4500711f - fConst3907));
		fConst3935 = (((fConst3901 + -0.157482162f) / fConst3900) + 0.935140193f);
		fConst3936 = (2.0f * (0.935140193f - fConst3929));
		fConst3937 = (2.0f * (0.935140193f - fConst3904));
		fConst3938 = std::tan((154.61557f / fConst0));
		fConst3939 = (1.0f / fConst3938);
		fConst3940 = (1.0f / (((fConst3939 + 0.157482162f) / fConst3938) + 0.935140193f));
		fConst3941 = mydsp_faustpower2_f(fConst3938);
		fConst3942 = (50.0638084f / fConst3941);
		fConst3943 = (fConst3942 + 0.935140193f);
		fConst3944 = (1.0f / (((fConst3939 + 0.743130445f) / fConst3938) + 1.4500711f));
		fConst3945 = (11.0520525f / fConst3941);
		fConst3946 = (fConst3945 + 1.4500711f);
		fConst3947 = (1.0f / (((fConst3939 + 3.18972731f) / fConst3938) + 4.07678175f));
		fConst3948 = (0.00176617282f / fConst3941);
		fConst3949 = (fConst3948 + 0.000407678192f);
		fConst3950 = (1.0f / (((fConst3901 + 0.168404877f) / fConst3900) + 1.06935835f));
		fConst3951 = (fConst3929 + 53.5361519f);
		fConst3952 = (1.0f / (((fConst3901 + 0.51247865f) / fConst3900) + 0.689621389f));
		fConst3953 = (fConst3929 + 7.62173128f);
		fConst3954 = (1.0f / (((fConst3901 + 0.782413065f) / fConst3900) + 0.245291501f));
		fConst3955 = (9.99999975e-05f / fConst3903);
		fConst3956 = (fConst3955 + 0.000433227193f);
		fConst3957 = (((fConst3901 + -0.782413065f) / fConst3900) + 0.245291501f);
		fConst3958 = (2.0f * (0.245291501f - fConst3929));
		fConst3959 = (2.0f * (0.000433227193f - fConst3955));
		fConst3960 = (((fConst3901 + -0.51247865f) / fConst3900) + 0.689621389f);
		fConst3961 = (2.0f * (0.689621389f - fConst3929));
		fConst3962 = (2.0f * (7.62173128f - fConst3929));
		fConst3963 = (((fConst3901 + -0.168404877f) / fConst3900) + 1.06935835f);
		fConst3964 = (2.0f * (1.06935835f - fConst3929));
		fConst3965 = (2.0f * (53.5361519f - fConst3929));
		fConst3966 = (((fConst3939 + -3.18972731f) / fConst3938) + 4.07678175f);
		fConst3967 = (1.0f / fConst3941);
		fConst3968 = (2.0f * (4.07678175f - fConst3967));
		fConst3969 = (2.0f * (0.000407678192f - fConst3948));
		fConst3970 = (((fConst3939 + -0.743130445f) / fConst3938) + 1.4500711f);
		fConst3971 = (2.0f * (1.4500711f - fConst3967));
		fConst3972 = (2.0f * (1.4500711f - fConst3945));
		fConst3973 = (((fConst3939 + -0.157482162f) / fConst3938) + 0.935140193f);
		fConst3974 = (2.0f * (0.935140193f - fConst3967));
		fConst3975 = (2.0f * (0.935140193f - fConst3942));
		fConst3976 = std::tan((145.937668f / fConst0));
		fConst3977 = (1.0f / fConst3976);
		fConst3978 = (1.0f / (((fConst3977 + 0.157482162f) / fConst3976) + 0.935140193f));
		fConst3979 = mydsp_faustpower2_f(fConst3976);
		fConst3980 = (50.0638084f / fConst3979);
		fConst3981 = (fConst3980 + 0.935140193f);
		fConst3982 = (1.0f / (((fConst3977 + 0.743130445f) / fConst3976) + 1.4500711f));
		fConst3983 = (11.0520525f / fConst3979);
		fConst3984 = (fConst3983 + 1.4500711f);
		fConst3985 = (1.0f / (((fConst3977 + 3.18972731f) / fConst3976) + 4.07678175f));
		fConst3986 = (0.00176617282f / fConst3979);
		fConst3987 = (fConst3986 + 0.000407678192f);
		fConst3988 = (1.0f / (((fConst3939 + 0.168404877f) / fConst3938) + 1.06935835f));
		fConst3989 = (fConst3967 + 53.5361519f);
		fConst3990 = (1.0f / (((fConst3939 + 0.51247865f) / fConst3938) + 0.689621389f));
		fConst3991 = (fConst3967 + 7.62173128f);
		fConst3992 = (1.0f / (((fConst3939 + 0.782413065f) / fConst3938) + 0.245291501f));
		fConst3993 = (9.99999975e-05f / fConst3941);
		fConst3994 = (fConst3993 + 0.000433227193f);
		fConst3995 = (((fConst3939 + -0.782413065f) / fConst3938) + 0.245291501f);
		fConst3996 = (2.0f * (0.245291501f - fConst3967));
		fConst3997 = (2.0f * (0.000433227193f - fConst3993));
		fConst3998 = (((fConst3939 + -0.51247865f) / fConst3938) + 0.689621389f);
		fConst3999 = (2.0f * (0.689621389f - fConst3967));
		fConst4000 = (2.0f * (7.62173128f - fConst3967));
		fConst4001 = (((fConst3939 + -0.168404877f) / fConst3938) + 1.06935835f);
		fConst4002 = (2.0f * (1.06935835f - fConst3967));
		fConst4003 = (2.0f * (53.5361519f - fConst3967));
		fConst4004 = (((fConst3977 + -3.18972731f) / fConst3976) + 4.07678175f);
		fConst4005 = (1.0f / fConst3979);
		fConst4006 = (2.0f * (4.07678175f - fConst4005));
		fConst4007 = (2.0f * (0.000407678192f - fConst3986));
		fConst4008 = (((fConst3977 + -0.743130445f) / fConst3976) + 1.4500711f);
		fConst4009 = (2.0f * (1.4500711f - fConst4005));
		fConst4010 = (2.0f * (1.4500711f - fConst3983));
		fConst4011 = (((fConst3977 + -0.157482162f) / fConst3976) + 0.935140193f);
		fConst4012 = (2.0f * (0.935140193f - fConst4005));
		fConst4013 = (2.0f * (0.935140193f - fConst3980));
		fConst4014 = std::tan((137.746811f / fConst0));
		fConst4015 = (1.0f / fConst4014);
		fConst4016 = (1.0f / (((fConst4015 + 0.157482162f) / fConst4014) + 0.935140193f));
		fConst4017 = mydsp_faustpower2_f(fConst4014);
		fConst4018 = (50.0638084f / fConst4017);
		fConst4019 = (fConst4018 + 0.935140193f);
		fConst4020 = (1.0f / (((fConst4015 + 0.743130445f) / fConst4014) + 1.4500711f));
		fConst4021 = (11.0520525f / fConst4017);
		fConst4022 = (fConst4021 + 1.4500711f);
		fConst4023 = (1.0f / (((fConst4015 + 3.18972731f) / fConst4014) + 4.07678175f));
		fConst4024 = (0.00176617282f / fConst4017);
		fConst4025 = (fConst4024 + 0.000407678192f);
		fConst4026 = (1.0f / (((fConst3977 + 0.168404877f) / fConst3976) + 1.06935835f));
		fConst4027 = (fConst4005 + 53.5361519f);
		fConst4028 = (1.0f / (((fConst3977 + 0.51247865f) / fConst3976) + 0.689621389f));
		fConst4029 = (fConst4005 + 7.62173128f);
		fConst4030 = (1.0f / (((fConst3977 + 0.782413065f) / fConst3976) + 0.245291501f));
		fConst4031 = (9.99999975e-05f / fConst3979);
		fConst4032 = (fConst4031 + 0.000433227193f);
		fConst4033 = (((fConst3977 + -0.782413065f) / fConst3976) + 0.245291501f);
		fConst4034 = (2.0f * (0.245291501f - fConst4005));
		fConst4035 = (2.0f * (0.000433227193f - fConst4031));
		fConst4036 = (((fConst3977 + -0.51247865f) / fConst3976) + 0.689621389f);
		fConst4037 = (2.0f * (0.689621389f - fConst4005));
		fConst4038 = (2.0f * (7.62173128f - fConst4005));
		fConst4039 = (((fConst3977 + -0.168404877f) / fConst3976) + 1.06935835f);
		fConst4040 = (2.0f * (1.06935835f - fConst4005));
		fConst4041 = (2.0f * (53.5361519f - fConst4005));
		fConst4042 = (((fConst4015 + -3.18972731f) / fConst4014) + 4.07678175f);
		fConst4043 = (1.0f / fConst4017);
		fConst4044 = (2.0f * (4.07678175f - fConst4043));
		fConst4045 = (2.0f * (0.000407678192f - fConst4024));
		fConst4046 = (((fConst4015 + -0.743130445f) / fConst4014) + 1.4500711f);
		fConst4047 = (2.0f * (1.4500711f - fConst4043));
		fConst4048 = (2.0f * (1.4500711f - fConst4021));
		fConst4049 = (((fConst4015 + -0.157482162f) / fConst4014) + 0.935140193f);
		fConst4050 = (2.0f * (0.935140193f - fConst4043));
		fConst4051 = (2.0f * (0.935140193f - fConst4018));
		fConst4052 = std::tan((130.015686f / fConst0));
		fConst4053 = (1.0f / fConst4052);
		fConst4054 = (1.0f / (((fConst4053 + 0.157482162f) / fConst4052) + 0.935140193f));
		fConst4055 = mydsp_faustpower2_f(fConst4052);
		fConst4056 = (50.0638084f / fConst4055);
		fConst4057 = (fConst4056 + 0.935140193f);
		fConst4058 = (1.0f / (((fConst4053 + 0.743130445f) / fConst4052) + 1.4500711f));
		fConst4059 = (11.0520525f / fConst4055);
		fConst4060 = (fConst4059 + 1.4500711f);
		fConst4061 = (1.0f / (((fConst4053 + 3.18972731f) / fConst4052) + 4.07678175f));
		fConst4062 = (0.00176617282f / fConst4055);
		fConst4063 = (fConst4062 + 0.000407678192f);
		fConst4064 = (1.0f / (((fConst4015 + 0.168404877f) / fConst4014) + 1.06935835f));
		fConst4065 = (fConst4043 + 53.5361519f);
		fConst4066 = (1.0f / (((fConst4015 + 0.51247865f) / fConst4014) + 0.689621389f));
		fConst4067 = (fConst4043 + 7.62173128f);
		fConst4068 = (1.0f / (((fConst4015 + 0.782413065f) / fConst4014) + 0.245291501f));
		fConst4069 = (9.99999975e-05f / fConst4017);
		fConst4070 = (fConst4069 + 0.000433227193f);
		fConst4071 = (((fConst4015 + -0.782413065f) / fConst4014) + 0.245291501f);
		fConst4072 = (2.0f * (0.245291501f - fConst4043));
		fConst4073 = (2.0f * (0.000433227193f - fConst4069));
		fConst4074 = (((fConst4015 + -0.51247865f) / fConst4014) + 0.689621389f);
		fConst4075 = (2.0f * (0.689621389f - fConst4043));
		fConst4076 = (2.0f * (7.62173128f - fConst4043));
		fConst4077 = (((fConst4015 + -0.168404877f) / fConst4014) + 1.06935835f);
		fConst4078 = (2.0f * (1.06935835f - fConst4043));
		fConst4079 = (2.0f * (53.5361519f - fConst4043));
		fConst4080 = (((fConst4053 + -3.18972731f) / fConst4052) + 4.07678175f);
		fConst4081 = (1.0f / fConst4055);
		fConst4082 = (2.0f * (4.07678175f - fConst4081));
		fConst4083 = (2.0f * (0.000407678192f - fConst4062));
		fConst4084 = (((fConst4053 + -0.743130445f) / fConst4052) + 1.4500711f);
		fConst4085 = (2.0f * (1.4500711f - fConst4081));
		fConst4086 = (2.0f * (1.4500711f - fConst4059));
		fConst4087 = (((fConst4053 + -0.157482162f) / fConst4052) + 0.935140193f);
		fConst4088 = (2.0f * (0.935140193f - fConst4081));
		fConst4089 = (2.0f * (0.935140193f - fConst4056));
		fConst4090 = std::tan((122.71846f / fConst0));
		fConst4091 = (1.0f / fConst4090);
		fConst4092 = (1.0f / (((fConst4091 + 0.157482162f) / fConst4090) + 0.935140193f));
		fConst4093 = mydsp_faustpower2_f(fConst4090);
		fConst4094 = (50.0638084f / fConst4093);
		fConst4095 = (fConst4094 + 0.935140193f);
		fConst4096 = (1.0f / (((fConst4091 + 0.743130445f) / fConst4090) + 1.4500711f));
		fConst4097 = (11.0520525f / fConst4093);
		fConst4098 = (fConst4097 + 1.4500711f);
		fConst4099 = (1.0f / (((fConst4091 + 3.18972731f) / fConst4090) + 4.07678175f));
		fConst4100 = (0.00176617282f / fConst4093);
		fConst4101 = (fConst4100 + 0.000407678192f);
		fConst4102 = (1.0f / (((fConst4053 + 0.168404877f) / fConst4052) + 1.06935835f));
		fConst4103 = (fConst4081 + 53.5361519f);
		fConst4104 = (1.0f / (((fConst4053 + 0.51247865f) / fConst4052) + 0.689621389f));
		fConst4105 = (fConst4081 + 7.62173128f);
		fConst4106 = (1.0f / (((fConst4053 + 0.782413065f) / fConst4052) + 0.245291501f));
		fConst4107 = (9.99999975e-05f / fConst4055);
		fConst4108 = (fConst4107 + 0.000433227193f);
		fConst4109 = (((fConst4053 + -0.782413065f) / fConst4052) + 0.245291501f);
		fConst4110 = (2.0f * (0.245291501f - fConst4081));
		fConst4111 = (2.0f * (0.000433227193f - fConst4107));
		fConst4112 = (((fConst4053 + -0.51247865f) / fConst4052) + 0.689621389f);
		fConst4113 = (2.0f * (0.689621389f - fConst4081));
		fConst4114 = (2.0f * (7.62173128f - fConst4081));
		fConst4115 = (((fConst4053 + -0.168404877f) / fConst4052) + 1.06935835f);
		fConst4116 = (2.0f * (1.06935835f - fConst4081));
		fConst4117 = (2.0f * (53.5361519f - fConst4081));
		fConst4118 = (((fConst4091 + -3.18972731f) / fConst4090) + 4.07678175f);
		fConst4119 = (1.0f / fConst4093);
		fConst4120 = (2.0f * (4.07678175f - fConst4119));
		fConst4121 = (2.0f * (0.000407678192f - fConst4100));
		fConst4122 = (((fConst4091 + -0.743130445f) / fConst4090) + 1.4500711f);
		fConst4123 = (2.0f * (1.4500711f - fConst4119));
		fConst4124 = (2.0f * (1.4500711f - fConst4097));
		fConst4125 = (((fConst4091 + -0.157482162f) / fConst4090) + 0.935140193f);
		fConst4126 = (2.0f * (0.935140193f - fConst4119));
		fConst4127 = (2.0f * (0.935140193f - fConst4094));
		fConst4128 = std::tan((115.830803f / fConst0));
		fConst4129 = (1.0f / fConst4128);
		fConst4130 = (1.0f / (((fConst4129 + 0.157482162f) / fConst4128) + 0.935140193f));
		fConst4131 = mydsp_faustpower2_f(fConst4128);
		fConst4132 = (50.0638084f / fConst4131);
		fConst4133 = (fConst4132 + 0.935140193f);
		fConst4134 = (1.0f / (((fConst4129 + 0.743130445f) / fConst4128) + 1.4500711f));
		fConst4135 = (11.0520525f / fConst4131);
		fConst4136 = (fConst4135 + 1.4500711f);
		fConst4137 = (1.0f / (((fConst4129 + 3.18972731f) / fConst4128) + 4.07678175f));
		fConst4138 = (0.00176617282f / fConst4131);
		fConst4139 = (fConst4138 + 0.000407678192f);
		fConst4140 = (1.0f / (((fConst4091 + 0.168404877f) / fConst4090) + 1.06935835f));
		fConst4141 = (fConst4119 + 53.5361519f);
		fConst4142 = (1.0f / (((fConst4091 + 0.51247865f) / fConst4090) + 0.689621389f));
		fConst4143 = (fConst4119 + 7.62173128f);
		fConst4144 = (1.0f / (((fConst4091 + 0.782413065f) / fConst4090) + 0.245291501f));
		fConst4145 = (9.99999975e-05f / fConst4093);
		fConst4146 = (fConst4145 + 0.000433227193f);
		fConst4147 = (((fConst4091 + -0.782413065f) / fConst4090) + 0.245291501f);
		fConst4148 = (2.0f * (0.245291501f - fConst4119));
		fConst4149 = (2.0f * (0.000433227193f - fConst4145));
		fConst4150 = (((fConst4091 + -0.51247865f) / fConst4090) + 0.689621389f);
		fConst4151 = (2.0f * (0.689621389f - fConst4119));
		fConst4152 = (2.0f * (7.62173128f - fConst4119));
		fConst4153 = (((fConst4091 + -0.168404877f) / fConst4090) + 1.06935835f);
		fConst4154 = (2.0f * (1.06935835f - fConst4119));
		fConst4155 = (2.0f * (53.5361519f - fConst4119));
		fConst4156 = (((fConst4129 + -3.18972731f) / fConst4128) + 4.07678175f);
		fConst4157 = (1.0f / fConst4131);
		fConst4158 = (2.0f * (4.07678175f - fConst4157));
		fConst4159 = (2.0f * (0.000407678192f - fConst4138));
		fConst4160 = (((fConst4129 + -0.743130445f) / fConst4128) + 1.4500711f);
		fConst4161 = (2.0f * (1.4500711f - fConst4157));
		fConst4162 = (2.0f * (1.4500711f - fConst4135));
		fConst4163 = (((fConst4129 + -0.157482162f) / fConst4128) + 0.935140193f);
		fConst4164 = (2.0f * (0.935140193f - fConst4157));
		fConst4165 = (2.0f * (0.935140193f - fConst4132));
		fConst4166 = std::tan((109.32972f / fConst0));
		fConst4167 = (1.0f / fConst4166);
		fConst4168 = (1.0f / (((fConst4167 + 0.157482162f) / fConst4166) + 0.935140193f));
		fConst4169 = mydsp_faustpower2_f(fConst4166);
		fConst4170 = (50.0638084f / fConst4169);
		fConst4171 = (fConst4170 + 0.935140193f);
		fConst4172 = (1.0f / (((fConst4167 + 0.743130445f) / fConst4166) + 1.4500711f));
		fConst4173 = (11.0520525f / fConst4169);
		fConst4174 = (fConst4173 + 1.4500711f);
		fConst4175 = (1.0f / (((fConst4167 + 3.18972731f) / fConst4166) + 4.07678175f));
		fConst4176 = (0.00176617282f / fConst4169);
		fConst4177 = (fConst4176 + 0.000407678192f);
		fConst4178 = (1.0f / (((fConst4129 + 0.168404877f) / fConst4128) + 1.06935835f));
		fConst4179 = (fConst4157 + 53.5361519f);
		fConst4180 = (1.0f / (((fConst4129 + 0.51247865f) / fConst4128) + 0.689621389f));
		fConst4181 = (fConst4157 + 7.62173128f);
		fConst4182 = (1.0f / (((fConst4129 + 0.782413065f) / fConst4128) + 0.245291501f));
		fConst4183 = (9.99999975e-05f / fConst4131);
		fConst4184 = (fConst4183 + 0.000433227193f);
		fConst4185 = (((fConst4129 + -0.782413065f) / fConst4128) + 0.245291501f);
		fConst4186 = (2.0f * (0.245291501f - fConst4157));
		fConst4187 = (2.0f * (0.000433227193f - fConst4183));
		fConst4188 = (((fConst4129 + -0.51247865f) / fConst4128) + 0.689621389f);
		fConst4189 = (2.0f * (0.689621389f - fConst4157));
		fConst4190 = (2.0f * (7.62173128f - fConst4157));
		fConst4191 = (((fConst4129 + -0.168404877f) / fConst4128) + 1.06935835f);
		fConst4192 = (2.0f * (1.06935835f - fConst4157));
		fConst4193 = (2.0f * (53.5361519f - fConst4157));
		fConst4194 = (((fConst4167 + -3.18972731f) / fConst4166) + 4.07678175f);
		fConst4195 = (1.0f / fConst4169);
		fConst4196 = (2.0f * (4.07678175f - fConst4195));
		fConst4197 = (2.0f * (0.000407678192f - fConst4176));
		fConst4198 = (((fConst4167 + -0.743130445f) / fConst4166) + 1.4500711f);
		fConst4199 = (2.0f * (1.4500711f - fConst4195));
		fConst4200 = (2.0f * (1.4500711f - fConst4173));
		fConst4201 = (((fConst4167 + -0.157482162f) / fConst4166) + 0.935140193f);
		fConst4202 = (2.0f * (0.935140193f - fConst4195));
		fConst4203 = (2.0f * (0.935140193f - fConst4170));
		fConst4204 = std::tan((103.193512f / fConst0));
		fConst4205 = (1.0f / fConst4204);
		fConst4206 = (1.0f / (((fConst4205 + 0.157482162f) / fConst4204) + 0.935140193f));
		fConst4207 = mydsp_faustpower2_f(fConst4204);
		fConst4208 = (50.0638084f / fConst4207);
		fConst4209 = (fConst4208 + 0.935140193f);
		fConst4210 = (1.0f / (((fConst4205 + 0.743130445f) / fConst4204) + 1.4500711f));
		fConst4211 = (11.0520525f / fConst4207);
		fConst4212 = (fConst4211 + 1.4500711f);
		fConst4213 = (1.0f / (((fConst4205 + 3.18972731f) / fConst4204) + 4.07678175f));
		fConst4214 = (0.00176617282f / fConst4207);
		fConst4215 = (fConst4214 + 0.000407678192f);
		fConst4216 = (1.0f / (((fConst4167 + 0.168404877f) / fConst4166) + 1.06935835f));
		fConst4217 = (fConst4195 + 53.5361519f);
		fConst4218 = (1.0f / (((fConst4167 + 0.51247865f) / fConst4166) + 0.689621389f));
		fConst4219 = (fConst4195 + 7.62173128f);
		fConst4220 = (1.0f / (((fConst4167 + 0.782413065f) / fConst4166) + 0.245291501f));
		fConst4221 = (9.99999975e-05f / fConst4169);
		fConst4222 = (fConst4221 + 0.000433227193f);
		fConst4223 = (((fConst4167 + -0.782413065f) / fConst4166) + 0.245291501f);
		fConst4224 = (2.0f * (0.245291501f - fConst4195));
		fConst4225 = (2.0f * (0.000433227193f - fConst4221));
		fConst4226 = (((fConst4167 + -0.51247865f) / fConst4166) + 0.689621389f);
		fConst4227 = (2.0f * (0.689621389f - fConst4195));
		fConst4228 = (2.0f * (7.62173128f - fConst4195));
		fConst4229 = (((fConst4167 + -0.168404877f) / fConst4166) + 1.06935835f);
		fConst4230 = (2.0f * (1.06935835f - fConst4195));
		fConst4231 = (2.0f * (53.5361519f - fConst4195));
		fConst4232 = (((fConst4205 + -3.18972731f) / fConst4204) + 4.07678175f);
		fConst4233 = (1.0f / fConst4207);
		fConst4234 = (2.0f * (4.07678175f - fConst4233));
		fConst4235 = (2.0f * (0.000407678192f - fConst4214));
		fConst4236 = (((fConst4205 + -0.743130445f) / fConst4204) + 1.4500711f);
		fConst4237 = (2.0f * (1.4500711f - fConst4233));
		fConst4238 = (2.0f * (1.4500711f - fConst4211));
		fConst4239 = (((fConst4205 + -0.157482162f) / fConst4204) + 0.935140193f);
		fConst4240 = (2.0f * (0.935140193f - fConst4233));
		fConst4241 = (2.0f * (0.935140193f - fConst4208));
		fConst4242 = std::tan((97.4017105f / fConst0));
		fConst4243 = (1.0f / fConst4242);
		fConst4244 = (1.0f / (((fConst4243 + 0.157482162f) / fConst4242) + 0.935140193f));
		fConst4245 = mydsp_faustpower2_f(fConst4242);
		fConst4246 = (50.0638084f / fConst4245);
		fConst4247 = (fConst4246 + 0.935140193f);
		fConst4248 = (1.0f / (((fConst4243 + 0.743130445f) / fConst4242) + 1.4500711f));
		fConst4249 = (11.0520525f / fConst4245);
		fConst4250 = (fConst4249 + 1.4500711f);
		fConst4251 = (1.0f / (((fConst4243 + 3.18972731f) / fConst4242) + 4.07678175f));
		fConst4252 = (0.00176617282f / fConst4245);
		fConst4253 = (fConst4252 + 0.000407678192f);
		fConst4254 = (1.0f / (((fConst4205 + 0.168404877f) / fConst4204) + 1.06935835f));
		fConst4255 = (fConst4233 + 53.5361519f);
		fConst4256 = (1.0f / (((fConst4205 + 0.51247865f) / fConst4204) + 0.689621389f));
		fConst4257 = (fConst4233 + 7.62173128f);
		fConst4258 = (1.0f / (((fConst4205 + 0.782413065f) / fConst4204) + 0.245291501f));
		fConst4259 = (9.99999975e-05f / fConst4207);
		fConst4260 = (fConst4259 + 0.000433227193f);
		fConst4261 = (((fConst4205 + -0.782413065f) / fConst4204) + 0.245291501f);
		fConst4262 = (2.0f * (0.245291501f - fConst4233));
		fConst4263 = (2.0f * (0.000433227193f - fConst4259));
		fConst4264 = (((fConst4205 + -0.51247865f) / fConst4204) + 0.689621389f);
		fConst4265 = (2.0f * (0.689621389f - fConst4233));
		fConst4266 = (2.0f * (7.62173128f - fConst4233));
		fConst4267 = (((fConst4205 + -0.168404877f) / fConst4204) + 1.06935835f);
		fConst4268 = (2.0f * (1.06935835f - fConst4233));
		fConst4269 = (2.0f * (53.5361519f - fConst4233));
		fConst4270 = (((fConst4243 + -3.18972731f) / fConst4242) + 4.07678175f);
		fConst4271 = (1.0f / fConst4245);
		fConst4272 = (2.0f * (4.07678175f - fConst4271));
		fConst4273 = (2.0f * (0.000407678192f - fConst4252));
		fConst4274 = (((fConst4243 + -0.743130445f) / fConst4242) + 1.4500711f);
		fConst4275 = (2.0f * (1.4500711f - fConst4271));
		fConst4276 = (2.0f * (1.4500711f - fConst4249));
		fConst4277 = (((fConst4243 + -0.157482162f) / fConst4242) + 0.935140193f);
		fConst4278 = (2.0f * (0.935140193f - fConst4271));
		fConst4279 = (2.0f * (0.935140193f - fConst4246));
		fConst4280 = std::tan((91.934967f / fConst0));
		fConst4281 = (1.0f / fConst4280);
		fConst4282 = (1.0f / (((fConst4281 + 0.157482162f) / fConst4280) + 0.935140193f));
		fConst4283 = mydsp_faustpower2_f(fConst4280);
		fConst4284 = (50.0638084f / fConst4283);
		fConst4285 = (fConst4284 + 0.935140193f);
		fConst4286 = (1.0f / (((fConst4281 + 0.743130445f) / fConst4280) + 1.4500711f));
		fConst4287 = (11.0520525f / fConst4283);
		fConst4288 = (fConst4287 + 1.4500711f);
		fConst4289 = (1.0f / (((fConst4281 + 3.18972731f) / fConst4280) + 4.07678175f));
		fConst4290 = (0.00176617282f / fConst4283);
		fConst4291 = (fConst4290 + 0.000407678192f);
		fConst4292 = (1.0f / (((fConst4243 + 0.168404877f) / fConst4242) + 1.06935835f));
		fConst4293 = (fConst4271 + 53.5361519f);
		fConst4294 = (1.0f / (((fConst4243 + 0.51247865f) / fConst4242) + 0.689621389f));
		fConst4295 = (fConst4271 + 7.62173128f);
		fConst4296 = (1.0f / (((fConst4243 + 0.782413065f) / fConst4242) + 0.245291501f));
		fConst4297 = (9.99999975e-05f / fConst4245);
		fConst4298 = (fConst4297 + 0.000433227193f);
		fConst4299 = (((fConst4243 + -0.782413065f) / fConst4242) + 0.245291501f);
		fConst4300 = (2.0f * (0.245291501f - fConst4271));
		fConst4301 = (2.0f * (0.000433227193f - fConst4297));
		fConst4302 = (((fConst4243 + -0.51247865f) / fConst4242) + 0.689621389f);
		fConst4303 = (2.0f * (0.689621389f - fConst4271));
		fConst4304 = (2.0f * (7.62173128f - fConst4271));
		fConst4305 = (((fConst4243 + -0.168404877f) / fConst4242) + 1.06935835f);
		fConst4306 = (2.0f * (1.06935835f - fConst4271));
		fConst4307 = (2.0f * (53.5361519f - fConst4271));
		fConst4308 = (((fConst4281 + -3.18972731f) / fConst4280) + 4.07678175f);
		fConst4309 = (1.0f / fConst4283);
		fConst4310 = (2.0f * (4.07678175f - fConst4309));
		fConst4311 = (2.0f * (0.000407678192f - fConst4290));
		fConst4312 = (((fConst4281 + -0.743130445f) / fConst4280) + 1.4500711f);
		fConst4313 = (2.0f * (1.4500711f - fConst4309));
		fConst4314 = (2.0f * (1.4500711f - fConst4287));
		fConst4315 = (((fConst4281 + -0.157482162f) / fConst4280) + 0.935140193f);
		fConst4316 = (2.0f * (0.935140193f - fConst4309));
		fConst4317 = (2.0f * (0.935140193f - fConst4284));
		fConst4318 = std::tan((86.7750549f / fConst0));
		fConst4319 = (1.0f / fConst4318);
		fConst4320 = (1.0f / (((fConst4319 + 0.157482162f) / fConst4318) + 0.935140193f));
		fConst4321 = mydsp_faustpower2_f(fConst4318);
		fConst4322 = (50.0638084f / fConst4321);
		fConst4323 = (fConst4322 + 0.935140193f);
		fConst4324 = (1.0f / (((fConst4319 + 0.743130445f) / fConst4318) + 1.4500711f));
		fConst4325 = (11.0520525f / fConst4321);
		fConst4326 = (fConst4325 + 1.4500711f);
		fConst4327 = (1.0f / (((fConst4319 + 3.18972731f) / fConst4318) + 4.07678175f));
		fConst4328 = (0.00176617282f / fConst4321);
		fConst4329 = (fConst4328 + 0.000407678192f);
		fConst4330 = (1.0f / (((fConst4281 + 0.168404877f) / fConst4280) + 1.06935835f));
		fConst4331 = (fConst4309 + 53.5361519f);
		fConst4332 = (1.0f / (((fConst4281 + 0.51247865f) / fConst4280) + 0.689621389f));
		fConst4333 = (fConst4309 + 7.62173128f);
		fConst4334 = (1.0f / (((fConst4281 + 0.782413065f) / fConst4280) + 0.245291501f));
		fConst4335 = (9.99999975e-05f / fConst4283);
		fConst4336 = (fConst4335 + 0.000433227193f);
		fConst4337 = (((fConst4281 + -0.782413065f) / fConst4280) + 0.245291501f);
		fConst4338 = (2.0f * (0.245291501f - fConst4309));
		fConst4339 = (2.0f * (0.000433227193f - fConst4335));
		fConst4340 = (((fConst4281 + -0.51247865f) / fConst4280) + 0.689621389f);
		fConst4341 = (2.0f * (0.689621389f - fConst4309));
		fConst4342 = (2.0f * (7.62173128f - fConst4309));
		fConst4343 = (((fConst4281 + -0.168404877f) / fConst4280) + 1.06935835f);
		fConst4344 = (2.0f * (1.06935835f - fConst4309));
		fConst4345 = (2.0f * (53.5361519f - fConst4309));
		fConst4346 = (((fConst4319 + -3.18972731f) / fConst4318) + 4.07678175f);
		fConst4347 = (1.0f / fConst4321);
		fConst4348 = (2.0f * (4.07678175f - fConst4347));
		fConst4349 = (2.0f * (0.000407678192f - fConst4328));
		fConst4350 = (((fConst4319 + -0.743130445f) / fConst4318) + 1.4500711f);
		fConst4351 = (2.0f * (1.4500711f - fConst4347));
		fConst4352 = (2.0f * (1.4500711f - fConst4325));
		fConst4353 = (((fConst4319 + -0.157482162f) / fConst4318) + 0.935140193f);
		fConst4354 = (2.0f * (0.935140193f - fConst4347));
		fConst4355 = (2.0f * (0.935140193f - fConst4322));
		fConst4356 = std::tan((81.904747f / fConst0));
		fConst4357 = (1.0f / fConst4356);
		fConst4358 = (1.0f / (((fConst4357 + 0.157482162f) / fConst4356) + 0.935140193f));
		fConst4359 = mydsp_faustpower2_f(fConst4356);
		fConst4360 = (50.0638084f / fConst4359);
		fConst4361 = (fConst4360 + 0.935140193f);
		fConst4362 = (1.0f / (((fConst4357 + 0.743130445f) / fConst4356) + 1.4500711f));
		fConst4363 = (11.0520525f / fConst4359);
		fConst4364 = (fConst4363 + 1.4500711f);
		fConst4365 = (1.0f / (((fConst4357 + 3.18972731f) / fConst4356) + 4.07678175f));
		fConst4366 = (0.00176617282f / fConst4359);
		fConst4367 = (fConst4366 + 0.000407678192f);
		fConst4368 = (1.0f / (((fConst4319 + 0.168404877f) / fConst4318) + 1.06935835f));
		fConst4369 = (fConst4347 + 53.5361519f);
		fConst4370 = (1.0f / (((fConst4319 + 0.51247865f) / fConst4318) + 0.689621389f));
		fConst4371 = (fConst4347 + 7.62173128f);
		fConst4372 = (1.0f / (((fConst4319 + 0.782413065f) / fConst4318) + 0.245291501f));
		fConst4373 = (9.99999975e-05f / fConst4321);
		fConst4374 = (fConst4373 + 0.000433227193f);
		fConst4375 = (((fConst4319 + -0.782413065f) / fConst4318) + 0.245291501f);
		fConst4376 = (2.0f * (0.245291501f - fConst4347));
		fConst4377 = (2.0f * (0.000433227193f - fConst4373));
		fConst4378 = (((fConst4319 + -0.51247865f) / fConst4318) + 0.689621389f);
		fConst4379 = (2.0f * (0.689621389f - fConst4347));
		fConst4380 = (2.0f * (7.62173128f - fConst4347));
		fConst4381 = (((fConst4319 + -0.168404877f) / fConst4318) + 1.06935835f);
		fConst4382 = (2.0f * (1.06935835f - fConst4347));
		fConst4383 = (2.0f * (53.5361519f - fConst4347));
		fConst4384 = (((fConst4357 + -3.18972731f) / fConst4356) + 4.07678175f);
		fConst4385 = (1.0f / fConst4359);
		fConst4386 = (2.0f * (4.07678175f - fConst4385));
		fConst4387 = (2.0f * (0.000407678192f - fConst4366));
		fConst4388 = (((fConst4357 + -0.743130445f) / fConst4356) + 1.4500711f);
		fConst4389 = (2.0f * (1.4500711f - fConst4385));
		fConst4390 = (2.0f * (1.4500711f - fConst4363));
		fConst4391 = (((fConst4357 + -0.157482162f) / fConst4356) + 0.935140193f);
		fConst4392 = (2.0f * (0.935140193f - fConst4385));
		fConst4393 = (2.0f * (0.935140193f - fConst4360));
		fConst4394 = std::tan((77.307785f / fConst0));
		fConst4395 = (1.0f / fConst4394);
		fConst4396 = (1.0f / (((fConst4395 + 0.157482162f) / fConst4394) + 0.935140193f));
		fConst4397 = mydsp_faustpower2_f(fConst4394);
		fConst4398 = (50.0638084f / fConst4397);
		fConst4399 = (fConst4398 + 0.935140193f);
		fConst4400 = (1.0f / (((fConst4395 + 0.743130445f) / fConst4394) + 1.4500711f));
		fConst4401 = (11.0520525f / fConst4397);
		fConst4402 = (fConst4401 + 1.4500711f);
		fConst4403 = (1.0f / (((fConst4395 + 3.18972731f) / fConst4394) + 4.07678175f));
		fConst4404 = (0.00176617282f / fConst4397);
		fConst4405 = (fConst4404 + 0.000407678192f);
		fConst4406 = (1.0f / (((fConst4357 + 0.168404877f) / fConst4356) + 1.06935835f));
		fConst4407 = (fConst4385 + 53.5361519f);
		fConst4408 = (1.0f / (((fConst4357 + 0.51247865f) / fConst4356) + 0.689621389f));
		fConst4409 = (fConst4385 + 7.62173128f);
		fConst4410 = (1.0f / (((fConst4357 + 0.782413065f) / fConst4356) + 0.245291501f));
		fConst4411 = (9.99999975e-05f / fConst4359);
		fConst4412 = (fConst4411 + 0.000433227193f);
		fConst4413 = (((fConst4357 + -0.782413065f) / fConst4356) + 0.245291501f);
		fConst4414 = (2.0f * (0.245291501f - fConst4385));
		fConst4415 = (2.0f * (0.000433227193f - fConst4411));
		fConst4416 = (((fConst4357 + -0.51247865f) / fConst4356) + 0.689621389f);
		fConst4417 = (2.0f * (0.689621389f - fConst4385));
		fConst4418 = (2.0f * (7.62173128f - fConst4385));
		fConst4419 = (((fConst4357 + -0.168404877f) / fConst4356) + 1.06935835f);
		fConst4420 = (2.0f * (1.06935835f - fConst4385));
		fConst4421 = (2.0f * (53.5361519f - fConst4385));
		fConst4422 = (((fConst4395 + -3.18972731f) / fConst4394) + 4.07678175f);
		fConst4423 = (1.0f / fConst4397);
		fConst4424 = (2.0f * (4.07678175f - fConst4423));
		fConst4425 = (2.0f * (0.000407678192f - fConst4404));
		fConst4426 = (((fConst4395 + -0.743130445f) / fConst4394) + 1.4500711f);
		fConst4427 = (2.0f * (1.4500711f - fConst4423));
		fConst4428 = (2.0f * (1.4500711f - fConst4401));
		fConst4429 = (((fConst4395 + -0.157482162f) / fConst4394) + 0.935140193f);
		fConst4430 = (2.0f * (0.935140193f - fConst4423));
		fConst4431 = (2.0f * (0.935140193f - fConst4398));
		fConst4432 = std::tan((72.9688339f / fConst0));
		fConst4433 = (1.0f / fConst4432);
		fConst4434 = (1.0f / (((fConst4433 + 0.157482162f) / fConst4432) + 0.935140193f));
		fConst4435 = mydsp_faustpower2_f(fConst4432);
		fConst4436 = (50.0638084f / fConst4435);
		fConst4437 = (fConst4436 + 0.935140193f);
		fConst4438 = (1.0f / (((fConst4433 + 0.743130445f) / fConst4432) + 1.4500711f));
		fConst4439 = (11.0520525f / fConst4435);
		fConst4440 = (fConst4439 + 1.4500711f);
		fConst4441 = (1.0f / (((fConst4433 + 3.18972731f) / fConst4432) + 4.07678175f));
		fConst4442 = (0.00176617282f / fConst4435);
		fConst4443 = (fConst4442 + 0.000407678192f);
		fConst4444 = (1.0f / (((fConst4395 + 0.168404877f) / fConst4394) + 1.06935835f));
		fConst4445 = (fConst4423 + 53.5361519f);
		fConst4446 = (1.0f / (((fConst4395 + 0.51247865f) / fConst4394) + 0.689621389f));
		fConst4447 = (fConst4423 + 7.62173128f);
		fConst4448 = (1.0f / (((fConst4395 + 0.782413065f) / fConst4394) + 0.245291501f));
		fConst4449 = (9.99999975e-05f / fConst4397);
		fConst4450 = (fConst4449 + 0.000433227193f);
		fConst4451 = (((fConst4395 + -0.782413065f) / fConst4394) + 0.245291501f);
		fConst4452 = (2.0f * (0.245291501f - fConst4423));
		fConst4453 = (2.0f * (0.000433227193f - fConst4449));
		fConst4454 = (((fConst4395 + -0.51247865f) / fConst4394) + 0.689621389f);
		fConst4455 = (2.0f * (0.689621389f - fConst4423));
		fConst4456 = (2.0f * (7.62173128f - fConst4423));
		fConst4457 = (((fConst4395 + -0.168404877f) / fConst4394) + 1.06935835f);
		fConst4458 = (2.0f * (1.06935835f - fConst4423));
		fConst4459 = (2.0f * (53.5361519f - fConst4423));
		fConst4460 = (((fConst4433 + -3.18972731f) / fConst4432) + 4.07678175f);
		fConst4461 = (1.0f / fConst4435);
		fConst4462 = (2.0f * (4.07678175f - fConst4461));
		fConst4463 = (2.0f * (0.000407678192f - fConst4442));
		fConst4464 = (((fConst4433 + -0.743130445f) / fConst4432) + 1.4500711f);
		fConst4465 = (2.0f * (1.4500711f - fConst4461));
		fConst4466 = (2.0f * (1.4500711f - fConst4439));
		fConst4467 = (((fConst4433 + -0.157482162f) / fConst4432) + 0.935140193f);
		fConst4468 = (2.0f * (0.935140193f - fConst4461));
		fConst4469 = (2.0f * (0.935140193f - fConst4436));
		fConst4470 = std::tan((68.8734055f / fConst0));
		fConst4471 = (1.0f / fConst4470);
		fConst4472 = (1.0f / (((fConst4471 + 0.157482162f) / fConst4470) + 0.935140193f));
		fConst4473 = mydsp_faustpower2_f(fConst4470);
		fConst4474 = (50.0638084f / fConst4473);
		fConst4475 = (fConst4474 + 0.935140193f);
		fConst4476 = (1.0f / (((fConst4471 + 0.743130445f) / fConst4470) + 1.4500711f));
		fConst4477 = (11.0520525f / fConst4473);
		fConst4478 = (fConst4477 + 1.4500711f);
		fConst4479 = (1.0f / (((fConst4471 + 3.18972731f) / fConst4470) + 4.07678175f));
		fConst4480 = (0.00176617282f / fConst4473);
		fConst4481 = (fConst4480 + 0.000407678192f);
		fConst4482 = (1.0f / (((fConst4433 + 0.168404877f) / fConst4432) + 1.06935835f));
		fConst4483 = (fConst4461 + 53.5361519f);
		fConst4484 = (1.0f / (((fConst4433 + 0.51247865f) / fConst4432) + 0.689621389f));
		fConst4485 = (fConst4461 + 7.62173128f);
		fConst4486 = (1.0f / (((fConst4433 + 0.782413065f) / fConst4432) + 0.245291501f));
		fConst4487 = (9.99999975e-05f / fConst4435);
		fConst4488 = (fConst4487 + 0.000433227193f);
		fConst4489 = (((fConst4433 + -0.782413065f) / fConst4432) + 0.245291501f);
		fConst4490 = (2.0f * (0.245291501f - fConst4461));
		fConst4491 = (2.0f * (0.000433227193f - fConst4487));
		fConst4492 = (((fConst4433 + -0.51247865f) / fConst4432) + 0.689621389f);
		fConst4493 = (2.0f * (0.689621389f - fConst4461));
		fConst4494 = (2.0f * (7.62173128f - fConst4461));
		fConst4495 = (((fConst4433 + -0.168404877f) / fConst4432) + 1.06935835f);
		fConst4496 = (2.0f * (1.06935835f - fConst4461));
		fConst4497 = (2.0f * (53.5361519f - fConst4461));
		fConst4498 = (((fConst4471 + -3.18972731f) / fConst4470) + 4.07678175f);
		fConst4499 = (1.0f / fConst4473);
		fConst4500 = (2.0f * (4.07678175f - fConst4499));
		fConst4501 = (2.0f * (0.000407678192f - fConst4480));
		fConst4502 = (((fConst4471 + -0.743130445f) / fConst4470) + 1.4500711f);
		fConst4503 = (2.0f * (1.4500711f - fConst4499));
		fConst4504 = (2.0f * (1.4500711f - fConst4477));
		fConst4505 = (((fConst4471 + -0.157482162f) / fConst4470) + 0.935140193f);
		fConst4506 = (2.0f * (0.935140193f - fConst4499));
		fConst4507 = (2.0f * (0.935140193f - fConst4474));
		fConst4508 = (1.0f / (((fConst4471 + 0.168404877f) / fConst4470) + 1.06935835f));
		fConst4509 = (fConst4499 + 53.5361519f);
		fConst4510 = (1.0f / (((fConst4471 + 0.51247865f) / fConst4470) + 0.689621389f));
		fConst4511 = (fConst4499 + 7.62173128f);
		fConst4512 = (1.0f / (((fConst4471 + 0.782413065f) / fConst4470) + 0.245291501f));
		fConst4513 = (9.99999975e-05f / fConst4473);
		fConst4514 = (fConst4513 + 0.000433227193f);
		fConst4515 = (((fConst4471 + -0.782413065f) / fConst4470) + 0.245291501f);
		fConst4516 = (2.0f * (0.245291501f - fConst4499));
		fConst4517 = (2.0f * (0.000433227193f - fConst4513));
		fConst4518 = (((fConst4471 + -0.51247865f) / fConst4470) + 0.689621389f);
		fConst4519 = (2.0f * (0.689621389f - fConst4499));
		fConst4520 = (2.0f * (7.62173128f - fConst4499));
		fConst4521 = (((fConst4471 + -0.168404877f) / fConst4470) + 1.06935835f);
		fConst4522 = (2.0f * (1.06935835f - fConst4499));
		fConst4523 = (2.0f * (53.5361519f - fConst4499));
		
	}
	
	virtual void instanceResetUserInterface() {
		//fHslider0 = FAUSTFLOAT(50.0f);
		//fHslider1 = FAUSTFLOAT(100.0f);
		
	}
	
	virtual void instanceClear() {
		for (int l0 = 0; (l0 < 3); l0 = (l0 + 1)) {
			fRec3[l0] = 0.0f;
			
		}
		for (int l1 = 0; (l1 < 3); l1 = (l1 + 1)) {
			fRec2[l1] = 0.0f;
			
		}
		for (int l2 = 0; (l2 < 3); l2 = (l2 + 1)) {
			fRec1[l2] = 0.0f;
			
		}
		for (int l3 = 0; (l3 < 2); l3 = (l3 + 1)) {
			fRec0[l3] = 0.0f;
			
		}
		for (int l4 = 0; (l4 < 3); l4 = (l4 + 1)) {
			fRec10[l4] = 0.0f;
			
		}
		for (int l5 = 0; (l5 < 3); l5 = (l5 + 1)) {
			fRec9[l5] = 0.0f;
			
		}
		for (int l6 = 0; (l6 < 3); l6 = (l6 + 1)) {
			fRec8[l6] = 0.0f;
			
		}
		for (int l7 = 0; (l7 < 3); l7 = (l7 + 1)) {
			fRec7[l7] = 0.0f;
			
		}
		for (int l8 = 0; (l8 < 3); l8 = (l8 + 1)) {
			fRec6[l8] = 0.0f;
			
		}
		for (int l9 = 0; (l9 < 3); l9 = (l9 + 1)) {
			fRec5[l9] = 0.0f;
			
		}
		for (int l10 = 0; (l10 < 2); l10 = (l10 + 1)) {
			fRec4[l10] = 0.0f;
			
		}
		for (int l11 = 0; (l11 < 3); l11 = (l11 + 1)) {
			fRec17[l11] = 0.0f;
			
		}
		for (int l12 = 0; (l12 < 3); l12 = (l12 + 1)) {
			fRec16[l12] = 0.0f;
			
		}
		for (int l13 = 0; (l13 < 3); l13 = (l13 + 1)) {
			fRec15[l13] = 0.0f;
			
		}
		for (int l14 = 0; (l14 < 3); l14 = (l14 + 1)) {
			fRec14[l14] = 0.0f;
			
		}
		for (int l15 = 0; (l15 < 3); l15 = (l15 + 1)) {
			fRec13[l15] = 0.0f;
			
		}
		for (int l16 = 0; (l16 < 3); l16 = (l16 + 1)) {
			fRec12[l16] = 0.0f;
			
		}
		for (int l17 = 0; (l17 < 2); l17 = (l17 + 1)) {
			fRec11[l17] = 0.0f;
			
		}
		for (int l18 = 0; (l18 < 3); l18 = (l18 + 1)) {
			fRec24[l18] = 0.0f;
			
		}
		for (int l19 = 0; (l19 < 3); l19 = (l19 + 1)) {
			fRec23[l19] = 0.0f;
			
		}
		for (int l20 = 0; (l20 < 3); l20 = (l20 + 1)) {
			fRec22[l20] = 0.0f;
			
		}
		for (int l21 = 0; (l21 < 3); l21 = (l21 + 1)) {
			fRec21[l21] = 0.0f;
			
		}
		for (int l22 = 0; (l22 < 3); l22 = (l22 + 1)) {
			fRec20[l22] = 0.0f;
			
		}
		for (int l23 = 0; (l23 < 3); l23 = (l23 + 1)) {
			fRec19[l23] = 0.0f;
			
		}
		for (int l24 = 0; (l24 < 2); l24 = (l24 + 1)) {
			fRec18[l24] = 0.0f;
			
		}
		for (int l25 = 0; (l25 < 3); l25 = (l25 + 1)) {
			fRec31[l25] = 0.0f;
			
		}
		for (int l26 = 0; (l26 < 3); l26 = (l26 + 1)) {
			fRec30[l26] = 0.0f;
			
		}
		for (int l27 = 0; (l27 < 3); l27 = (l27 + 1)) {
			fRec29[l27] = 0.0f;
			
		}
		for (int l28 = 0; (l28 < 3); l28 = (l28 + 1)) {
			fRec28[l28] = 0.0f;
			
		}
		for (int l29 = 0; (l29 < 3); l29 = (l29 + 1)) {
			fRec27[l29] = 0.0f;
			
		}
		for (int l30 = 0; (l30 < 3); l30 = (l30 + 1)) {
			fRec26[l30] = 0.0f;
			
		}
		for (int l31 = 0; (l31 < 2); l31 = (l31 + 1)) {
			fRec25[l31] = 0.0f;
			
		}
		for (int l32 = 0; (l32 < 3); l32 = (l32 + 1)) {
			fRec38[l32] = 0.0f;
			
		}
		for (int l33 = 0; (l33 < 3); l33 = (l33 + 1)) {
			fRec37[l33] = 0.0f;
			
		}
		for (int l34 = 0; (l34 < 3); l34 = (l34 + 1)) {
			fRec36[l34] = 0.0f;
			
		}
		for (int l35 = 0; (l35 < 3); l35 = (l35 + 1)) {
			fRec35[l35] = 0.0f;
			
		}
		for (int l36 = 0; (l36 < 3); l36 = (l36 + 1)) {
			fRec34[l36] = 0.0f;
			
		}
		for (int l37 = 0; (l37 < 3); l37 = (l37 + 1)) {
			fRec33[l37] = 0.0f;
			
		}
		for (int l38 = 0; (l38 < 2); l38 = (l38 + 1)) {
			fRec32[l38] = 0.0f;
			
		}
		for (int l39 = 0; (l39 < 3); l39 = (l39 + 1)) {
			fRec45[l39] = 0.0f;
			
		}
		for (int l40 = 0; (l40 < 3); l40 = (l40 + 1)) {
			fRec44[l40] = 0.0f;
			
		}
		for (int l41 = 0; (l41 < 3); l41 = (l41 + 1)) {
			fRec43[l41] = 0.0f;
			
		}
		for (int l42 = 0; (l42 < 3); l42 = (l42 + 1)) {
			fRec42[l42] = 0.0f;
			
		}
		for (int l43 = 0; (l43 < 3); l43 = (l43 + 1)) {
			fRec41[l43] = 0.0f;
			
		}
		for (int l44 = 0; (l44 < 3); l44 = (l44 + 1)) {
			fRec40[l44] = 0.0f;
			
		}
		for (int l45 = 0; (l45 < 2); l45 = (l45 + 1)) {
			fRec39[l45] = 0.0f;
			
		}
		for (int l46 = 0; (l46 < 3); l46 = (l46 + 1)) {
			fRec52[l46] = 0.0f;
			
		}
		for (int l47 = 0; (l47 < 3); l47 = (l47 + 1)) {
			fRec51[l47] = 0.0f;
			
		}
		for (int l48 = 0; (l48 < 3); l48 = (l48 + 1)) {
			fRec50[l48] = 0.0f;
			
		}
		for (int l49 = 0; (l49 < 3); l49 = (l49 + 1)) {
			fRec49[l49] = 0.0f;
			
		}
		for (int l50 = 0; (l50 < 3); l50 = (l50 + 1)) {
			fRec48[l50] = 0.0f;
			
		}
		for (int l51 = 0; (l51 < 3); l51 = (l51 + 1)) {
			fRec47[l51] = 0.0f;
			
		}
		for (int l52 = 0; (l52 < 2); l52 = (l52 + 1)) {
			fRec46[l52] = 0.0f;
			
		}
		for (int l53 = 0; (l53 < 3); l53 = (l53 + 1)) {
			fRec59[l53] = 0.0f;
			
		}
		for (int l54 = 0; (l54 < 3); l54 = (l54 + 1)) {
			fRec58[l54] = 0.0f;
			
		}
		for (int l55 = 0; (l55 < 3); l55 = (l55 + 1)) {
			fRec57[l55] = 0.0f;
			
		}
		for (int l56 = 0; (l56 < 3); l56 = (l56 + 1)) {
			fRec56[l56] = 0.0f;
			
		}
		for (int l57 = 0; (l57 < 3); l57 = (l57 + 1)) {
			fRec55[l57] = 0.0f;
			
		}
		for (int l58 = 0; (l58 < 3); l58 = (l58 + 1)) {
			fRec54[l58] = 0.0f;
			
		}
		for (int l59 = 0; (l59 < 2); l59 = (l59 + 1)) {
			fRec53[l59] = 0.0f;
			
		}
		for (int l60 = 0; (l60 < 3); l60 = (l60 + 1)) {
			fRec66[l60] = 0.0f;
			
		}
		for (int l61 = 0; (l61 < 3); l61 = (l61 + 1)) {
			fRec65[l61] = 0.0f;
			
		}
		for (int l62 = 0; (l62 < 3); l62 = (l62 + 1)) {
			fRec64[l62] = 0.0f;
			
		}
		for (int l63 = 0; (l63 < 3); l63 = (l63 + 1)) {
			fRec63[l63] = 0.0f;
			
		}
		for (int l64 = 0; (l64 < 3); l64 = (l64 + 1)) {
			fRec62[l64] = 0.0f;
			
		}
		for (int l65 = 0; (l65 < 3); l65 = (l65 + 1)) {
			fRec61[l65] = 0.0f;
			
		}
		for (int l66 = 0; (l66 < 2); l66 = (l66 + 1)) {
			fRec60[l66] = 0.0f;
			
		}
		for (int l67 = 0; (l67 < 3); l67 = (l67 + 1)) {
			fRec73[l67] = 0.0f;
			
		}
		for (int l68 = 0; (l68 < 3); l68 = (l68 + 1)) {
			fRec72[l68] = 0.0f;
			
		}
		for (int l69 = 0; (l69 < 3); l69 = (l69 + 1)) {
			fRec71[l69] = 0.0f;
			
		}
		for (int l70 = 0; (l70 < 3); l70 = (l70 + 1)) {
			fRec70[l70] = 0.0f;
			
		}
		for (int l71 = 0; (l71 < 3); l71 = (l71 + 1)) {
			fRec69[l71] = 0.0f;
			
		}
		for (int l72 = 0; (l72 < 3); l72 = (l72 + 1)) {
			fRec68[l72] = 0.0f;
			
		}
		for (int l73 = 0; (l73 < 2); l73 = (l73 + 1)) {
			fRec67[l73] = 0.0f;
			
		}
		for (int l74 = 0; (l74 < 3); l74 = (l74 + 1)) {
			fRec80[l74] = 0.0f;
			
		}
		for (int l75 = 0; (l75 < 3); l75 = (l75 + 1)) {
			fRec79[l75] = 0.0f;
			
		}
		for (int l76 = 0; (l76 < 3); l76 = (l76 + 1)) {
			fRec78[l76] = 0.0f;
			
		}
		for (int l77 = 0; (l77 < 3); l77 = (l77 + 1)) {
			fRec77[l77] = 0.0f;
			
		}
		for (int l78 = 0; (l78 < 3); l78 = (l78 + 1)) {
			fRec76[l78] = 0.0f;
			
		}
		for (int l79 = 0; (l79 < 3); l79 = (l79 + 1)) {
			fRec75[l79] = 0.0f;
			
		}
		for (int l80 = 0; (l80 < 2); l80 = (l80 + 1)) {
			fRec74[l80] = 0.0f;
			
		}
		for (int l81 = 0; (l81 < 3); l81 = (l81 + 1)) {
			fRec87[l81] = 0.0f;
			
		}
		for (int l82 = 0; (l82 < 3); l82 = (l82 + 1)) {
			fRec86[l82] = 0.0f;
			
		}
		for (int l83 = 0; (l83 < 3); l83 = (l83 + 1)) {
			fRec85[l83] = 0.0f;
			
		}
		for (int l84 = 0; (l84 < 3); l84 = (l84 + 1)) {
			fRec84[l84] = 0.0f;
			
		}
		for (int l85 = 0; (l85 < 3); l85 = (l85 + 1)) {
			fRec83[l85] = 0.0f;
			
		}
		for (int l86 = 0; (l86 < 3); l86 = (l86 + 1)) {
			fRec82[l86] = 0.0f;
			
		}
		for (int l87 = 0; (l87 < 2); l87 = (l87 + 1)) {
			fRec81[l87] = 0.0f;
			
		}
		for (int l88 = 0; (l88 < 3); l88 = (l88 + 1)) {
			fRec94[l88] = 0.0f;
			
		}
		for (int l89 = 0; (l89 < 3); l89 = (l89 + 1)) {
			fRec93[l89] = 0.0f;
			
		}
		for (int l90 = 0; (l90 < 3); l90 = (l90 + 1)) {
			fRec92[l90] = 0.0f;
			
		}
		for (int l91 = 0; (l91 < 3); l91 = (l91 + 1)) {
			fRec91[l91] = 0.0f;
			
		}
		for (int l92 = 0; (l92 < 3); l92 = (l92 + 1)) {
			fRec90[l92] = 0.0f;
			
		}
		for (int l93 = 0; (l93 < 3); l93 = (l93 + 1)) {
			fRec89[l93] = 0.0f;
			
		}
		for (int l94 = 0; (l94 < 2); l94 = (l94 + 1)) {
			fRec88[l94] = 0.0f;
			
		}
		for (int l95 = 0; (l95 < 3); l95 = (l95 + 1)) {
			fRec101[l95] = 0.0f;
			
		}
		for (int l96 = 0; (l96 < 3); l96 = (l96 + 1)) {
			fRec100[l96] = 0.0f;
			
		}
		for (int l97 = 0; (l97 < 3); l97 = (l97 + 1)) {
			fRec99[l97] = 0.0f;
			
		}
		for (int l98 = 0; (l98 < 3); l98 = (l98 + 1)) {
			fRec98[l98] = 0.0f;
			
		}
		for (int l99 = 0; (l99 < 3); l99 = (l99 + 1)) {
			fRec97[l99] = 0.0f;
			
		}
		for (int l100 = 0; (l100 < 3); l100 = (l100 + 1)) {
			fRec96[l100] = 0.0f;
			
		}
		for (int l101 = 0; (l101 < 2); l101 = (l101 + 1)) {
			fRec95[l101] = 0.0f;
			
		}
		for (int l102 = 0; (l102 < 3); l102 = (l102 + 1)) {
			fRec108[l102] = 0.0f;
			
		}
		for (int l103 = 0; (l103 < 3); l103 = (l103 + 1)) {
			fRec107[l103] = 0.0f;
			
		}
		for (int l104 = 0; (l104 < 3); l104 = (l104 + 1)) {
			fRec106[l104] = 0.0f;
			
		}
		for (int l105 = 0; (l105 < 3); l105 = (l105 + 1)) {
			fRec105[l105] = 0.0f;
			
		}
		for (int l106 = 0; (l106 < 3); l106 = (l106 + 1)) {
			fRec104[l106] = 0.0f;
			
		}
		for (int l107 = 0; (l107 < 3); l107 = (l107 + 1)) {
			fRec103[l107] = 0.0f;
			
		}
		for (int l108 = 0; (l108 < 2); l108 = (l108 + 1)) {
			fRec102[l108] = 0.0f;
			
		}
		for (int l109 = 0; (l109 < 3); l109 = (l109 + 1)) {
			fRec115[l109] = 0.0f;
			
		}
		for (int l110 = 0; (l110 < 3); l110 = (l110 + 1)) {
			fRec114[l110] = 0.0f;
			
		}
		for (int l111 = 0; (l111 < 3); l111 = (l111 + 1)) {
			fRec113[l111] = 0.0f;
			
		}
		for (int l112 = 0; (l112 < 3); l112 = (l112 + 1)) {
			fRec112[l112] = 0.0f;
			
		}
		for (int l113 = 0; (l113 < 3); l113 = (l113 + 1)) {
			fRec111[l113] = 0.0f;
			
		}
		for (int l114 = 0; (l114 < 3); l114 = (l114 + 1)) {
			fRec110[l114] = 0.0f;
			
		}
		for (int l115 = 0; (l115 < 2); l115 = (l115 + 1)) {
			fRec109[l115] = 0.0f;
			
		}
		for (int l116 = 0; (l116 < 3); l116 = (l116 + 1)) {
			fRec122[l116] = 0.0f;
			
		}
		for (int l117 = 0; (l117 < 3); l117 = (l117 + 1)) {
			fRec121[l117] = 0.0f;
			
		}
		for (int l118 = 0; (l118 < 3); l118 = (l118 + 1)) {
			fRec120[l118] = 0.0f;
			
		}
		for (int l119 = 0; (l119 < 3); l119 = (l119 + 1)) {
			fRec119[l119] = 0.0f;
			
		}
		for (int l120 = 0; (l120 < 3); l120 = (l120 + 1)) {
			fRec118[l120] = 0.0f;
			
		}
		for (int l121 = 0; (l121 < 3); l121 = (l121 + 1)) {
			fRec117[l121] = 0.0f;
			
		}
		for (int l122 = 0; (l122 < 2); l122 = (l122 + 1)) {
			fRec116[l122] = 0.0f;
			
		}
		for (int l123 = 0; (l123 < 3); l123 = (l123 + 1)) {
			fRec129[l123] = 0.0f;
			
		}
		for (int l124 = 0; (l124 < 3); l124 = (l124 + 1)) {
			fRec128[l124] = 0.0f;
			
		}
		for (int l125 = 0; (l125 < 3); l125 = (l125 + 1)) {
			fRec127[l125] = 0.0f;
			
		}
		for (int l126 = 0; (l126 < 3); l126 = (l126 + 1)) {
			fRec126[l126] = 0.0f;
			
		}
		for (int l127 = 0; (l127 < 3); l127 = (l127 + 1)) {
			fRec125[l127] = 0.0f;
			
		}
		for (int l128 = 0; (l128 < 3); l128 = (l128 + 1)) {
			fRec124[l128] = 0.0f;
			
		}
		for (int l129 = 0; (l129 < 2); l129 = (l129 + 1)) {
			fRec123[l129] = 0.0f;
			
		}
		for (int l130 = 0; (l130 < 3); l130 = (l130 + 1)) {
			fRec136[l130] = 0.0f;
			
		}
		for (int l131 = 0; (l131 < 3); l131 = (l131 + 1)) {
			fRec135[l131] = 0.0f;
			
		}
		for (int l132 = 0; (l132 < 3); l132 = (l132 + 1)) {
			fRec134[l132] = 0.0f;
			
		}
		for (int l133 = 0; (l133 < 3); l133 = (l133 + 1)) {
			fRec133[l133] = 0.0f;
			
		}
		for (int l134 = 0; (l134 < 3); l134 = (l134 + 1)) {
			fRec132[l134] = 0.0f;
			
		}
		for (int l135 = 0; (l135 < 3); l135 = (l135 + 1)) {
			fRec131[l135] = 0.0f;
			
		}
		for (int l136 = 0; (l136 < 2); l136 = (l136 + 1)) {
			fRec130[l136] = 0.0f;
			
		}
		for (int l137 = 0; (l137 < 3); l137 = (l137 + 1)) {
			fRec143[l137] = 0.0f;
			
		}
		for (int l138 = 0; (l138 < 3); l138 = (l138 + 1)) {
			fRec142[l138] = 0.0f;
			
		}
		for (int l139 = 0; (l139 < 3); l139 = (l139 + 1)) {
			fRec141[l139] = 0.0f;
			
		}
		for (int l140 = 0; (l140 < 3); l140 = (l140 + 1)) {
			fRec140[l140] = 0.0f;
			
		}
		for (int l141 = 0; (l141 < 3); l141 = (l141 + 1)) {
			fRec139[l141] = 0.0f;
			
		}
		for (int l142 = 0; (l142 < 3); l142 = (l142 + 1)) {
			fRec138[l142] = 0.0f;
			
		}
		for (int l143 = 0; (l143 < 2); l143 = (l143 + 1)) {
			fRec137[l143] = 0.0f;
			
		}
		for (int l144 = 0; (l144 < 3); l144 = (l144 + 1)) {
			fRec150[l144] = 0.0f;
			
		}
		for (int l145 = 0; (l145 < 3); l145 = (l145 + 1)) {
			fRec149[l145] = 0.0f;
			
		}
		for (int l146 = 0; (l146 < 3); l146 = (l146 + 1)) {
			fRec148[l146] = 0.0f;
			
		}
		for (int l147 = 0; (l147 < 3); l147 = (l147 + 1)) {
			fRec147[l147] = 0.0f;
			
		}
		for (int l148 = 0; (l148 < 3); l148 = (l148 + 1)) {
			fRec146[l148] = 0.0f;
			
		}
		for (int l149 = 0; (l149 < 3); l149 = (l149 + 1)) {
			fRec145[l149] = 0.0f;
			
		}
		for (int l150 = 0; (l150 < 2); l150 = (l150 + 1)) {
			fRec144[l150] = 0.0f;
			
		}
		for (int l151 = 0; (l151 < 3); l151 = (l151 + 1)) {
			fRec157[l151] = 0.0f;
			
		}
		for (int l152 = 0; (l152 < 3); l152 = (l152 + 1)) {
			fRec156[l152] = 0.0f;
			
		}
		for (int l153 = 0; (l153 < 3); l153 = (l153 + 1)) {
			fRec155[l153] = 0.0f;
			
		}
		for (int l154 = 0; (l154 < 3); l154 = (l154 + 1)) {
			fRec154[l154] = 0.0f;
			
		}
		for (int l155 = 0; (l155 < 3); l155 = (l155 + 1)) {
			fRec153[l155] = 0.0f;
			
		}
		for (int l156 = 0; (l156 < 3); l156 = (l156 + 1)) {
			fRec152[l156] = 0.0f;
			
		}
		for (int l157 = 0; (l157 < 2); l157 = (l157 + 1)) {
			fRec151[l157] = 0.0f;
			
		}
		for (int l158 = 0; (l158 < 3); l158 = (l158 + 1)) {
			fRec164[l158] = 0.0f;
			
		}
		for (int l159 = 0; (l159 < 3); l159 = (l159 + 1)) {
			fRec163[l159] = 0.0f;
			
		}
		for (int l160 = 0; (l160 < 3); l160 = (l160 + 1)) {
			fRec162[l160] = 0.0f;
			
		}
		for (int l161 = 0; (l161 < 3); l161 = (l161 + 1)) {
			fRec161[l161] = 0.0f;
			
		}
		for (int l162 = 0; (l162 < 3); l162 = (l162 + 1)) {
			fRec160[l162] = 0.0f;
			
		}
		for (int l163 = 0; (l163 < 3); l163 = (l163 + 1)) {
			fRec159[l163] = 0.0f;
			
		}
		for (int l164 = 0; (l164 < 2); l164 = (l164 + 1)) {
			fRec158[l164] = 0.0f;
			
		}
		for (int l165 = 0; (l165 < 3); l165 = (l165 + 1)) {
			fRec171[l165] = 0.0f;
			
		}
		for (int l166 = 0; (l166 < 3); l166 = (l166 + 1)) {
			fRec170[l166] = 0.0f;
			
		}
		for (int l167 = 0; (l167 < 3); l167 = (l167 + 1)) {
			fRec169[l167] = 0.0f;
			
		}
		for (int l168 = 0; (l168 < 3); l168 = (l168 + 1)) {
			fRec168[l168] = 0.0f;
			
		}
		for (int l169 = 0; (l169 < 3); l169 = (l169 + 1)) {
			fRec167[l169] = 0.0f;
			
		}
		for (int l170 = 0; (l170 < 3); l170 = (l170 + 1)) {
			fRec166[l170] = 0.0f;
			
		}
		for (int l171 = 0; (l171 < 2); l171 = (l171 + 1)) {
			fRec165[l171] = 0.0f;
			
		}
		for (int l172 = 0; (l172 < 3); l172 = (l172 + 1)) {
			fRec178[l172] = 0.0f;
			
		}
		for (int l173 = 0; (l173 < 3); l173 = (l173 + 1)) {
			fRec177[l173] = 0.0f;
			
		}
		for (int l174 = 0; (l174 < 3); l174 = (l174 + 1)) {
			fRec176[l174] = 0.0f;
			
		}
		for (int l175 = 0; (l175 < 3); l175 = (l175 + 1)) {
			fRec175[l175] = 0.0f;
			
		}
		for (int l176 = 0; (l176 < 3); l176 = (l176 + 1)) {
			fRec174[l176] = 0.0f;
			
		}
		for (int l177 = 0; (l177 < 3); l177 = (l177 + 1)) {
			fRec173[l177] = 0.0f;
			
		}
		for (int l178 = 0; (l178 < 2); l178 = (l178 + 1)) {
			fRec172[l178] = 0.0f;
			
		}
		for (int l179 = 0; (l179 < 3); l179 = (l179 + 1)) {
			fRec185[l179] = 0.0f;
			
		}
		for (int l180 = 0; (l180 < 3); l180 = (l180 + 1)) {
			fRec184[l180] = 0.0f;
			
		}
		for (int l181 = 0; (l181 < 3); l181 = (l181 + 1)) {
			fRec183[l181] = 0.0f;
			
		}
		for (int l182 = 0; (l182 < 3); l182 = (l182 + 1)) {
			fRec182[l182] = 0.0f;
			
		}
		for (int l183 = 0; (l183 < 3); l183 = (l183 + 1)) {
			fRec181[l183] = 0.0f;
			
		}
		for (int l184 = 0; (l184 < 3); l184 = (l184 + 1)) {
			fRec180[l184] = 0.0f;
			
		}
		for (int l185 = 0; (l185 < 2); l185 = (l185 + 1)) {
			fRec179[l185] = 0.0f;
			
		}
		for (int l186 = 0; (l186 < 3); l186 = (l186 + 1)) {
			fRec192[l186] = 0.0f;
			
		}
		for (int l187 = 0; (l187 < 3); l187 = (l187 + 1)) {
			fRec191[l187] = 0.0f;
			
		}
		for (int l188 = 0; (l188 < 3); l188 = (l188 + 1)) {
			fRec190[l188] = 0.0f;
			
		}
		for (int l189 = 0; (l189 < 3); l189 = (l189 + 1)) {
			fRec189[l189] = 0.0f;
			
		}
		for (int l190 = 0; (l190 < 3); l190 = (l190 + 1)) {
			fRec188[l190] = 0.0f;
			
		}
		for (int l191 = 0; (l191 < 3); l191 = (l191 + 1)) {
			fRec187[l191] = 0.0f;
			
		}
		for (int l192 = 0; (l192 < 2); l192 = (l192 + 1)) {
			fRec186[l192] = 0.0f;
			
		}
		for (int l193 = 0; (l193 < 3); l193 = (l193 + 1)) {
			fRec199[l193] = 0.0f;
			
		}
		for (int l194 = 0; (l194 < 3); l194 = (l194 + 1)) {
			fRec198[l194] = 0.0f;
			
		}
		for (int l195 = 0; (l195 < 3); l195 = (l195 + 1)) {
			fRec197[l195] = 0.0f;
			
		}
		for (int l196 = 0; (l196 < 3); l196 = (l196 + 1)) {
			fRec196[l196] = 0.0f;
			
		}
		for (int l197 = 0; (l197 < 3); l197 = (l197 + 1)) {
			fRec195[l197] = 0.0f;
			
		}
		for (int l198 = 0; (l198 < 3); l198 = (l198 + 1)) {
			fRec194[l198] = 0.0f;
			
		}
		for (int l199 = 0; (l199 < 2); l199 = (l199 + 1)) {
			fRec193[l199] = 0.0f;
			
		}
		for (int l200 = 0; (l200 < 3); l200 = (l200 + 1)) {
			fRec206[l200] = 0.0f;
			
		}
		for (int l201 = 0; (l201 < 3); l201 = (l201 + 1)) {
			fRec205[l201] = 0.0f;
			
		}
		for (int l202 = 0; (l202 < 3); l202 = (l202 + 1)) {
			fRec204[l202] = 0.0f;
			
		}
		for (int l203 = 0; (l203 < 3); l203 = (l203 + 1)) {
			fRec203[l203] = 0.0f;
			
		}
		for (int l204 = 0; (l204 < 3); l204 = (l204 + 1)) {
			fRec202[l204] = 0.0f;
			
		}
		for (int l205 = 0; (l205 < 3); l205 = (l205 + 1)) {
			fRec201[l205] = 0.0f;
			
		}
		for (int l206 = 0; (l206 < 2); l206 = (l206 + 1)) {
			fRec200[l206] = 0.0f;
			
		}
		for (int l207 = 0; (l207 < 3); l207 = (l207 + 1)) {
			fRec213[l207] = 0.0f;
			
		}
		for (int l208 = 0; (l208 < 3); l208 = (l208 + 1)) {
			fRec212[l208] = 0.0f;
			
		}
		for (int l209 = 0; (l209 < 3); l209 = (l209 + 1)) {
			fRec211[l209] = 0.0f;
			
		}
		for (int l210 = 0; (l210 < 3); l210 = (l210 + 1)) {
			fRec210[l210] = 0.0f;
			
		}
		for (int l211 = 0; (l211 < 3); l211 = (l211 + 1)) {
			fRec209[l211] = 0.0f;
			
		}
		for (int l212 = 0; (l212 < 3); l212 = (l212 + 1)) {
			fRec208[l212] = 0.0f;
			
		}
		for (int l213 = 0; (l213 < 2); l213 = (l213 + 1)) {
			fRec207[l213] = 0.0f;
			
		}
		for (int l214 = 0; (l214 < 3); l214 = (l214 + 1)) {
			fRec220[l214] = 0.0f;
			
		}
		for (int l215 = 0; (l215 < 3); l215 = (l215 + 1)) {
			fRec219[l215] = 0.0f;
			
		}
		for (int l216 = 0; (l216 < 3); l216 = (l216 + 1)) {
			fRec218[l216] = 0.0f;
			
		}
		for (int l217 = 0; (l217 < 3); l217 = (l217 + 1)) {
			fRec217[l217] = 0.0f;
			
		}
		for (int l218 = 0; (l218 < 3); l218 = (l218 + 1)) {
			fRec216[l218] = 0.0f;
			
		}
		for (int l219 = 0; (l219 < 3); l219 = (l219 + 1)) {
			fRec215[l219] = 0.0f;
			
		}
		for (int l220 = 0; (l220 < 2); l220 = (l220 + 1)) {
			fRec214[l220] = 0.0f;
			
		}
		for (int l221 = 0; (l221 < 3); l221 = (l221 + 1)) {
			fRec227[l221] = 0.0f;
			
		}
		for (int l222 = 0; (l222 < 3); l222 = (l222 + 1)) {
			fRec226[l222] = 0.0f;
			
		}
		for (int l223 = 0; (l223 < 3); l223 = (l223 + 1)) {
			fRec225[l223] = 0.0f;
			
		}
		for (int l224 = 0; (l224 < 3); l224 = (l224 + 1)) {
			fRec224[l224] = 0.0f;
			
		}
		for (int l225 = 0; (l225 < 3); l225 = (l225 + 1)) {
			fRec223[l225] = 0.0f;
			
		}
		for (int l226 = 0; (l226 < 3); l226 = (l226 + 1)) {
			fRec222[l226] = 0.0f;
			
		}
		for (int l227 = 0; (l227 < 2); l227 = (l227 + 1)) {
			fRec221[l227] = 0.0f;
			
		}
		for (int l228 = 0; (l228 < 3); l228 = (l228 + 1)) {
			fRec234[l228] = 0.0f;
			
		}
		for (int l229 = 0; (l229 < 3); l229 = (l229 + 1)) {
			fRec233[l229] = 0.0f;
			
		}
		for (int l230 = 0; (l230 < 3); l230 = (l230 + 1)) {
			fRec232[l230] = 0.0f;
			
		}
		for (int l231 = 0; (l231 < 3); l231 = (l231 + 1)) {
			fRec231[l231] = 0.0f;
			
		}
		for (int l232 = 0; (l232 < 3); l232 = (l232 + 1)) {
			fRec230[l232] = 0.0f;
			
		}
		for (int l233 = 0; (l233 < 3); l233 = (l233 + 1)) {
			fRec229[l233] = 0.0f;
			
		}
		for (int l234 = 0; (l234 < 2); l234 = (l234 + 1)) {
			fRec228[l234] = 0.0f;
			
		}
		for (int l235 = 0; (l235 < 3); l235 = (l235 + 1)) {
			fRec241[l235] = 0.0f;
			
		}
		for (int l236 = 0; (l236 < 3); l236 = (l236 + 1)) {
			fRec240[l236] = 0.0f;
			
		}
		for (int l237 = 0; (l237 < 3); l237 = (l237 + 1)) {
			fRec239[l237] = 0.0f;
			
		}
		for (int l238 = 0; (l238 < 3); l238 = (l238 + 1)) {
			fRec238[l238] = 0.0f;
			
		}
		for (int l239 = 0; (l239 < 3); l239 = (l239 + 1)) {
			fRec237[l239] = 0.0f;
			
		}
		for (int l240 = 0; (l240 < 3); l240 = (l240 + 1)) {
			fRec236[l240] = 0.0f;
			
		}
		for (int l241 = 0; (l241 < 2); l241 = (l241 + 1)) {
			fRec235[l241] = 0.0f;
			
		}
		for (int l242 = 0; (l242 < 3); l242 = (l242 + 1)) {
			fRec248[l242] = 0.0f;
			
		}
		for (int l243 = 0; (l243 < 3); l243 = (l243 + 1)) {
			fRec247[l243] = 0.0f;
			
		}
		for (int l244 = 0; (l244 < 3); l244 = (l244 + 1)) {
			fRec246[l244] = 0.0f;
			
		}
		for (int l245 = 0; (l245 < 3); l245 = (l245 + 1)) {
			fRec245[l245] = 0.0f;
			
		}
		for (int l246 = 0; (l246 < 3); l246 = (l246 + 1)) {
			fRec244[l246] = 0.0f;
			
		}
		for (int l247 = 0; (l247 < 3); l247 = (l247 + 1)) {
			fRec243[l247] = 0.0f;
			
		}
		for (int l248 = 0; (l248 < 2); l248 = (l248 + 1)) {
			fRec242[l248] = 0.0f;
			
		}
		for (int l249 = 0; (l249 < 3); l249 = (l249 + 1)) {
			fRec255[l249] = 0.0f;
			
		}
		for (int l250 = 0; (l250 < 3); l250 = (l250 + 1)) {
			fRec254[l250] = 0.0f;
			
		}
		for (int l251 = 0; (l251 < 3); l251 = (l251 + 1)) {
			fRec253[l251] = 0.0f;
			
		}
		for (int l252 = 0; (l252 < 3); l252 = (l252 + 1)) {
			fRec252[l252] = 0.0f;
			
		}
		for (int l253 = 0; (l253 < 3); l253 = (l253 + 1)) {
			fRec251[l253] = 0.0f;
			
		}
		for (int l254 = 0; (l254 < 3); l254 = (l254 + 1)) {
			fRec250[l254] = 0.0f;
			
		}
		for (int l255 = 0; (l255 < 2); l255 = (l255 + 1)) {
			fRec249[l255] = 0.0f;
			
		}
		for (int l256 = 0; (l256 < 3); l256 = (l256 + 1)) {
			fRec262[l256] = 0.0f;
			
		}
		for (int l257 = 0; (l257 < 3); l257 = (l257 + 1)) {
			fRec261[l257] = 0.0f;
			
		}
		for (int l258 = 0; (l258 < 3); l258 = (l258 + 1)) {
			fRec260[l258] = 0.0f;
			
		}
		for (int l259 = 0; (l259 < 3); l259 = (l259 + 1)) {
			fRec259[l259] = 0.0f;
			
		}
		for (int l260 = 0; (l260 < 3); l260 = (l260 + 1)) {
			fRec258[l260] = 0.0f;
			
		}
		for (int l261 = 0; (l261 < 3); l261 = (l261 + 1)) {
			fRec257[l261] = 0.0f;
			
		}
		for (int l262 = 0; (l262 < 2); l262 = (l262 + 1)) {
			fRec256[l262] = 0.0f;
			
		}
		for (int l263 = 0; (l263 < 3); l263 = (l263 + 1)) {
			fRec269[l263] = 0.0f;
			
		}
		for (int l264 = 0; (l264 < 3); l264 = (l264 + 1)) {
			fRec268[l264] = 0.0f;
			
		}
		for (int l265 = 0; (l265 < 3); l265 = (l265 + 1)) {
			fRec267[l265] = 0.0f;
			
		}
		for (int l266 = 0; (l266 < 3); l266 = (l266 + 1)) {
			fRec266[l266] = 0.0f;
			
		}
		for (int l267 = 0; (l267 < 3); l267 = (l267 + 1)) {
			fRec265[l267] = 0.0f;
			
		}
		for (int l268 = 0; (l268 < 3); l268 = (l268 + 1)) {
			fRec264[l268] = 0.0f;
			
		}
		for (int l269 = 0; (l269 < 2); l269 = (l269 + 1)) {
			fRec263[l269] = 0.0f;
			
		}
		for (int l270 = 0; (l270 < 3); l270 = (l270 + 1)) {
			fRec276[l270] = 0.0f;
			
		}
		for (int l271 = 0; (l271 < 3); l271 = (l271 + 1)) {
			fRec275[l271] = 0.0f;
			
		}
		for (int l272 = 0; (l272 < 3); l272 = (l272 + 1)) {
			fRec274[l272] = 0.0f;
			
		}
		for (int l273 = 0; (l273 < 3); l273 = (l273 + 1)) {
			fRec273[l273] = 0.0f;
			
		}
		for (int l274 = 0; (l274 < 3); l274 = (l274 + 1)) {
			fRec272[l274] = 0.0f;
			
		}
		for (int l275 = 0; (l275 < 3); l275 = (l275 + 1)) {
			fRec271[l275] = 0.0f;
			
		}
		for (int l276 = 0; (l276 < 2); l276 = (l276 + 1)) {
			fRec270[l276] = 0.0f;
			
		}
		for (int l277 = 0; (l277 < 3); l277 = (l277 + 1)) {
			fRec283[l277] = 0.0f;
			
		}
		for (int l278 = 0; (l278 < 3); l278 = (l278 + 1)) {
			fRec282[l278] = 0.0f;
			
		}
		for (int l279 = 0; (l279 < 3); l279 = (l279 + 1)) {
			fRec281[l279] = 0.0f;
			
		}
		for (int l280 = 0; (l280 < 3); l280 = (l280 + 1)) {
			fRec280[l280] = 0.0f;
			
		}
		for (int l281 = 0; (l281 < 3); l281 = (l281 + 1)) {
			fRec279[l281] = 0.0f;
			
		}
		for (int l282 = 0; (l282 < 3); l282 = (l282 + 1)) {
			fRec278[l282] = 0.0f;
			
		}
		for (int l283 = 0; (l283 < 2); l283 = (l283 + 1)) {
			fRec277[l283] = 0.0f;
			
		}
		for (int l284 = 0; (l284 < 3); l284 = (l284 + 1)) {
			fRec290[l284] = 0.0f;
			
		}
		for (int l285 = 0; (l285 < 3); l285 = (l285 + 1)) {
			fRec289[l285] = 0.0f;
			
		}
		for (int l286 = 0; (l286 < 3); l286 = (l286 + 1)) {
			fRec288[l286] = 0.0f;
			
		}
		for (int l287 = 0; (l287 < 3); l287 = (l287 + 1)) {
			fRec287[l287] = 0.0f;
			
		}
		for (int l288 = 0; (l288 < 3); l288 = (l288 + 1)) {
			fRec286[l288] = 0.0f;
			
		}
		for (int l289 = 0; (l289 < 3); l289 = (l289 + 1)) {
			fRec285[l289] = 0.0f;
			
		}
		for (int l290 = 0; (l290 < 2); l290 = (l290 + 1)) {
			fRec284[l290] = 0.0f;
			
		}
		for (int l291 = 0; (l291 < 3); l291 = (l291 + 1)) {
			fRec297[l291] = 0.0f;
			
		}
		for (int l292 = 0; (l292 < 3); l292 = (l292 + 1)) {
			fRec296[l292] = 0.0f;
			
		}
		for (int l293 = 0; (l293 < 3); l293 = (l293 + 1)) {
			fRec295[l293] = 0.0f;
			
		}
		for (int l294 = 0; (l294 < 3); l294 = (l294 + 1)) {
			fRec294[l294] = 0.0f;
			
		}
		for (int l295 = 0; (l295 < 3); l295 = (l295 + 1)) {
			fRec293[l295] = 0.0f;
			
		}
		for (int l296 = 0; (l296 < 3); l296 = (l296 + 1)) {
			fRec292[l296] = 0.0f;
			
		}
		for (int l297 = 0; (l297 < 2); l297 = (l297 + 1)) {
			fRec291[l297] = 0.0f;
			
		}
		for (int l298 = 0; (l298 < 3); l298 = (l298 + 1)) {
			fRec304[l298] = 0.0f;
			
		}
		for (int l299 = 0; (l299 < 3); l299 = (l299 + 1)) {
			fRec303[l299] = 0.0f;
			
		}
		for (int l300 = 0; (l300 < 3); l300 = (l300 + 1)) {
			fRec302[l300] = 0.0f;
			
		}
		for (int l301 = 0; (l301 < 3); l301 = (l301 + 1)) {
			fRec301[l301] = 0.0f;
			
		}
		for (int l302 = 0; (l302 < 3); l302 = (l302 + 1)) {
			fRec300[l302] = 0.0f;
			
		}
		for (int l303 = 0; (l303 < 3); l303 = (l303 + 1)) {
			fRec299[l303] = 0.0f;
			
		}
		for (int l304 = 0; (l304 < 2); l304 = (l304 + 1)) {
			fRec298[l304] = 0.0f;
			
		}
		for (int l305 = 0; (l305 < 3); l305 = (l305 + 1)) {
			fRec311[l305] = 0.0f;
			
		}
		for (int l306 = 0; (l306 < 3); l306 = (l306 + 1)) {
			fRec310[l306] = 0.0f;
			
		}
		for (int l307 = 0; (l307 < 3); l307 = (l307 + 1)) {
			fRec309[l307] = 0.0f;
			
		}
		for (int l308 = 0; (l308 < 3); l308 = (l308 + 1)) {
			fRec308[l308] = 0.0f;
			
		}
		for (int l309 = 0; (l309 < 3); l309 = (l309 + 1)) {
			fRec307[l309] = 0.0f;
			
		}
		for (int l310 = 0; (l310 < 3); l310 = (l310 + 1)) {
			fRec306[l310] = 0.0f;
			
		}
		for (int l311 = 0; (l311 < 2); l311 = (l311 + 1)) {
			fRec305[l311] = 0.0f;
			
		}
		for (int l312 = 0; (l312 < 3); l312 = (l312 + 1)) {
			fRec318[l312] = 0.0f;
			
		}
		for (int l313 = 0; (l313 < 3); l313 = (l313 + 1)) {
			fRec317[l313] = 0.0f;
			
		}
		for (int l314 = 0; (l314 < 3); l314 = (l314 + 1)) {
			fRec316[l314] = 0.0f;
			
		}
		for (int l315 = 0; (l315 < 3); l315 = (l315 + 1)) {
			fRec315[l315] = 0.0f;
			
		}
		for (int l316 = 0; (l316 < 3); l316 = (l316 + 1)) {
			fRec314[l316] = 0.0f;
			
		}
		for (int l317 = 0; (l317 < 3); l317 = (l317 + 1)) {
			fRec313[l317] = 0.0f;
			
		}
		for (int l318 = 0; (l318 < 2); l318 = (l318 + 1)) {
			fRec312[l318] = 0.0f;
			
		}
		for (int l319 = 0; (l319 < 3); l319 = (l319 + 1)) {
			fRec325[l319] = 0.0f;
			
		}
		for (int l320 = 0; (l320 < 3); l320 = (l320 + 1)) {
			fRec324[l320] = 0.0f;
			
		}
		for (int l321 = 0; (l321 < 3); l321 = (l321 + 1)) {
			fRec323[l321] = 0.0f;
			
		}
		for (int l322 = 0; (l322 < 3); l322 = (l322 + 1)) {
			fRec322[l322] = 0.0f;
			
		}
		for (int l323 = 0; (l323 < 3); l323 = (l323 + 1)) {
			fRec321[l323] = 0.0f;
			
		}
		for (int l324 = 0; (l324 < 3); l324 = (l324 + 1)) {
			fRec320[l324] = 0.0f;
			
		}
		for (int l325 = 0; (l325 < 2); l325 = (l325 + 1)) {
			fRec319[l325] = 0.0f;
			
		}
		for (int l326 = 0; (l326 < 3); l326 = (l326 + 1)) {
			fRec332[l326] = 0.0f;
			
		}
		for (int l327 = 0; (l327 < 3); l327 = (l327 + 1)) {
			fRec331[l327] = 0.0f;
			
		}
		for (int l328 = 0; (l328 < 3); l328 = (l328 + 1)) {
			fRec330[l328] = 0.0f;
			
		}
		for (int l329 = 0; (l329 < 3); l329 = (l329 + 1)) {
			fRec329[l329] = 0.0f;
			
		}
		for (int l330 = 0; (l330 < 3); l330 = (l330 + 1)) {
			fRec328[l330] = 0.0f;
			
		}
		for (int l331 = 0; (l331 < 3); l331 = (l331 + 1)) {
			fRec327[l331] = 0.0f;
			
		}
		for (int l332 = 0; (l332 < 2); l332 = (l332 + 1)) {
			fRec326[l332] = 0.0f;
			
		}
		for (int l333 = 0; (l333 < 3); l333 = (l333 + 1)) {
			fRec339[l333] = 0.0f;
			
		}
		for (int l334 = 0; (l334 < 3); l334 = (l334 + 1)) {
			fRec338[l334] = 0.0f;
			
		}
		for (int l335 = 0; (l335 < 3); l335 = (l335 + 1)) {
			fRec337[l335] = 0.0f;
			
		}
		for (int l336 = 0; (l336 < 3); l336 = (l336 + 1)) {
			fRec336[l336] = 0.0f;
			
		}
		for (int l337 = 0; (l337 < 3); l337 = (l337 + 1)) {
			fRec335[l337] = 0.0f;
			
		}
		for (int l338 = 0; (l338 < 3); l338 = (l338 + 1)) {
			fRec334[l338] = 0.0f;
			
		}
		for (int l339 = 0; (l339 < 2); l339 = (l339 + 1)) {
			fRec333[l339] = 0.0f;
			
		}
		for (int l340 = 0; (l340 < 3); l340 = (l340 + 1)) {
			fRec346[l340] = 0.0f;
			
		}
		for (int l341 = 0; (l341 < 3); l341 = (l341 + 1)) {
			fRec345[l341] = 0.0f;
			
		}
		for (int l342 = 0; (l342 < 3); l342 = (l342 + 1)) {
			fRec344[l342] = 0.0f;
			
		}
		for (int l343 = 0; (l343 < 3); l343 = (l343 + 1)) {
			fRec343[l343] = 0.0f;
			
		}
		for (int l344 = 0; (l344 < 3); l344 = (l344 + 1)) {
			fRec342[l344] = 0.0f;
			
		}
		for (int l345 = 0; (l345 < 3); l345 = (l345 + 1)) {
			fRec341[l345] = 0.0f;
			
		}
		for (int l346 = 0; (l346 < 2); l346 = (l346 + 1)) {
			fRec340[l346] = 0.0f;
			
		}
		for (int l347 = 0; (l347 < 3); l347 = (l347 + 1)) {
			fRec353[l347] = 0.0f;
			
		}
		for (int l348 = 0; (l348 < 3); l348 = (l348 + 1)) {
			fRec352[l348] = 0.0f;
			
		}
		for (int l349 = 0; (l349 < 3); l349 = (l349 + 1)) {
			fRec351[l349] = 0.0f;
			
		}
		for (int l350 = 0; (l350 < 3); l350 = (l350 + 1)) {
			fRec350[l350] = 0.0f;
			
		}
		for (int l351 = 0; (l351 < 3); l351 = (l351 + 1)) {
			fRec349[l351] = 0.0f;
			
		}
		for (int l352 = 0; (l352 < 3); l352 = (l352 + 1)) {
			fRec348[l352] = 0.0f;
			
		}
		for (int l353 = 0; (l353 < 2); l353 = (l353 + 1)) {
			fRec347[l353] = 0.0f;
			
		}
		for (int l354 = 0; (l354 < 3); l354 = (l354 + 1)) {
			fRec360[l354] = 0.0f;
			
		}
		for (int l355 = 0; (l355 < 3); l355 = (l355 + 1)) {
			fRec359[l355] = 0.0f;
			
		}
		for (int l356 = 0; (l356 < 3); l356 = (l356 + 1)) {
			fRec358[l356] = 0.0f;
			
		}
		for (int l357 = 0; (l357 < 3); l357 = (l357 + 1)) {
			fRec357[l357] = 0.0f;
			
		}
		for (int l358 = 0; (l358 < 3); l358 = (l358 + 1)) {
			fRec356[l358] = 0.0f;
			
		}
		for (int l359 = 0; (l359 < 3); l359 = (l359 + 1)) {
			fRec355[l359] = 0.0f;
			
		}
		for (int l360 = 0; (l360 < 2); l360 = (l360 + 1)) {
			fRec354[l360] = 0.0f;
			
		}
		for (int l361 = 0; (l361 < 3); l361 = (l361 + 1)) {
			fRec367[l361] = 0.0f;
			
		}
		for (int l362 = 0; (l362 < 3); l362 = (l362 + 1)) {
			fRec366[l362] = 0.0f;
			
		}
		for (int l363 = 0; (l363 < 3); l363 = (l363 + 1)) {
			fRec365[l363] = 0.0f;
			
		}
		for (int l364 = 0; (l364 < 3); l364 = (l364 + 1)) {
			fRec364[l364] = 0.0f;
			
		}
		for (int l365 = 0; (l365 < 3); l365 = (l365 + 1)) {
			fRec363[l365] = 0.0f;
			
		}
		for (int l366 = 0; (l366 < 3); l366 = (l366 + 1)) {
			fRec362[l366] = 0.0f;
			
		}
		for (int l367 = 0; (l367 < 2); l367 = (l367 + 1)) {
			fRec361[l367] = 0.0f;
			
		}
		for (int l368 = 0; (l368 < 3); l368 = (l368 + 1)) {
			fRec374[l368] = 0.0f;
			
		}
		for (int l369 = 0; (l369 < 3); l369 = (l369 + 1)) {
			fRec373[l369] = 0.0f;
			
		}
		for (int l370 = 0; (l370 < 3); l370 = (l370 + 1)) {
			fRec372[l370] = 0.0f;
			
		}
		for (int l371 = 0; (l371 < 3); l371 = (l371 + 1)) {
			fRec371[l371] = 0.0f;
			
		}
		for (int l372 = 0; (l372 < 3); l372 = (l372 + 1)) {
			fRec370[l372] = 0.0f;
			
		}
		for (int l373 = 0; (l373 < 3); l373 = (l373 + 1)) {
			fRec369[l373] = 0.0f;
			
		}
		for (int l374 = 0; (l374 < 2); l374 = (l374 + 1)) {
			fRec368[l374] = 0.0f;
			
		}
		for (int l375 = 0; (l375 < 3); l375 = (l375 + 1)) {
			fRec381[l375] = 0.0f;
			
		}
		for (int l376 = 0; (l376 < 3); l376 = (l376 + 1)) {
			fRec380[l376] = 0.0f;
			
		}
		for (int l377 = 0; (l377 < 3); l377 = (l377 + 1)) {
			fRec379[l377] = 0.0f;
			
		}
		for (int l378 = 0; (l378 < 3); l378 = (l378 + 1)) {
			fRec378[l378] = 0.0f;
			
		}
		for (int l379 = 0; (l379 < 3); l379 = (l379 + 1)) {
			fRec377[l379] = 0.0f;
			
		}
		for (int l380 = 0; (l380 < 3); l380 = (l380 + 1)) {
			fRec376[l380] = 0.0f;
			
		}
		for (int l381 = 0; (l381 < 2); l381 = (l381 + 1)) {
			fRec375[l381] = 0.0f;
			
		}
		for (int l382 = 0; (l382 < 3); l382 = (l382 + 1)) {
			fRec388[l382] = 0.0f;
			
		}
		for (int l383 = 0; (l383 < 3); l383 = (l383 + 1)) {
			fRec387[l383] = 0.0f;
			
		}
		for (int l384 = 0; (l384 < 3); l384 = (l384 + 1)) {
			fRec386[l384] = 0.0f;
			
		}
		for (int l385 = 0; (l385 < 3); l385 = (l385 + 1)) {
			fRec385[l385] = 0.0f;
			
		}
		for (int l386 = 0; (l386 < 3); l386 = (l386 + 1)) {
			fRec384[l386] = 0.0f;
			
		}
		for (int l387 = 0; (l387 < 3); l387 = (l387 + 1)) {
			fRec383[l387] = 0.0f;
			
		}
		for (int l388 = 0; (l388 < 2); l388 = (l388 + 1)) {
			fRec382[l388] = 0.0f;
			
		}
		for (int l389 = 0; (l389 < 3); l389 = (l389 + 1)) {
			fRec395[l389] = 0.0f;
			
		}
		for (int l390 = 0; (l390 < 3); l390 = (l390 + 1)) {
			fRec394[l390] = 0.0f;
			
		}
		for (int l391 = 0; (l391 < 3); l391 = (l391 + 1)) {
			fRec393[l391] = 0.0f;
			
		}
		for (int l392 = 0; (l392 < 3); l392 = (l392 + 1)) {
			fRec392[l392] = 0.0f;
			
		}
		for (int l393 = 0; (l393 < 3); l393 = (l393 + 1)) {
			fRec391[l393] = 0.0f;
			
		}
		for (int l394 = 0; (l394 < 3); l394 = (l394 + 1)) {
			fRec390[l394] = 0.0f;
			
		}
		for (int l395 = 0; (l395 < 2); l395 = (l395 + 1)) {
			fRec389[l395] = 0.0f;
			
		}
		for (int l396 = 0; (l396 < 3); l396 = (l396 + 1)) {
			fRec402[l396] = 0.0f;
			
		}
		for (int l397 = 0; (l397 < 3); l397 = (l397 + 1)) {
			fRec401[l397] = 0.0f;
			
		}
		for (int l398 = 0; (l398 < 3); l398 = (l398 + 1)) {
			fRec400[l398] = 0.0f;
			
		}
		for (int l399 = 0; (l399 < 3); l399 = (l399 + 1)) {
			fRec399[l399] = 0.0f;
			
		}
		for (int l400 = 0; (l400 < 3); l400 = (l400 + 1)) {
			fRec398[l400] = 0.0f;
			
		}
		for (int l401 = 0; (l401 < 3); l401 = (l401 + 1)) {
			fRec397[l401] = 0.0f;
			
		}
		for (int l402 = 0; (l402 < 2); l402 = (l402 + 1)) {
			fRec396[l402] = 0.0f;
			
		}
		for (int l403 = 0; (l403 < 3); l403 = (l403 + 1)) {
			fRec409[l403] = 0.0f;
			
		}
		for (int l404 = 0; (l404 < 3); l404 = (l404 + 1)) {
			fRec408[l404] = 0.0f;
			
		}
		for (int l405 = 0; (l405 < 3); l405 = (l405 + 1)) {
			fRec407[l405] = 0.0f;
			
		}
		for (int l406 = 0; (l406 < 3); l406 = (l406 + 1)) {
			fRec406[l406] = 0.0f;
			
		}
		for (int l407 = 0; (l407 < 3); l407 = (l407 + 1)) {
			fRec405[l407] = 0.0f;
			
		}
		for (int l408 = 0; (l408 < 3); l408 = (l408 + 1)) {
			fRec404[l408] = 0.0f;
			
		}
		for (int l409 = 0; (l409 < 2); l409 = (l409 + 1)) {
			fRec403[l409] = 0.0f;
			
		}
		for (int l410 = 0; (l410 < 3); l410 = (l410 + 1)) {
			fRec416[l410] = 0.0f;
			
		}
		for (int l411 = 0; (l411 < 3); l411 = (l411 + 1)) {
			fRec415[l411] = 0.0f;
			
		}
		for (int l412 = 0; (l412 < 3); l412 = (l412 + 1)) {
			fRec414[l412] = 0.0f;
			
		}
		for (int l413 = 0; (l413 < 3); l413 = (l413 + 1)) {
			fRec413[l413] = 0.0f;
			
		}
		for (int l414 = 0; (l414 < 3); l414 = (l414 + 1)) {
			fRec412[l414] = 0.0f;
			
		}
		for (int l415 = 0; (l415 < 3); l415 = (l415 + 1)) {
			fRec411[l415] = 0.0f;
			
		}
		for (int l416 = 0; (l416 < 2); l416 = (l416 + 1)) {
			fRec410[l416] = 0.0f;
			
		}
		for (int l417 = 0; (l417 < 3); l417 = (l417 + 1)) {
			fRec423[l417] = 0.0f;
			
		}
		for (int l418 = 0; (l418 < 3); l418 = (l418 + 1)) {
			fRec422[l418] = 0.0f;
			
		}
		for (int l419 = 0; (l419 < 3); l419 = (l419 + 1)) {
			fRec421[l419] = 0.0f;
			
		}
		for (int l420 = 0; (l420 < 3); l420 = (l420 + 1)) {
			fRec420[l420] = 0.0f;
			
		}
		for (int l421 = 0; (l421 < 3); l421 = (l421 + 1)) {
			fRec419[l421] = 0.0f;
			
		}
		for (int l422 = 0; (l422 < 3); l422 = (l422 + 1)) {
			fRec418[l422] = 0.0f;
			
		}
		for (int l423 = 0; (l423 < 2); l423 = (l423 + 1)) {
			fRec417[l423] = 0.0f;
			
		}
		for (int l424 = 0; (l424 < 3); l424 = (l424 + 1)) {
			fRec430[l424] = 0.0f;
			
		}
		for (int l425 = 0; (l425 < 3); l425 = (l425 + 1)) {
			fRec429[l425] = 0.0f;
			
		}
		for (int l426 = 0; (l426 < 3); l426 = (l426 + 1)) {
			fRec428[l426] = 0.0f;
			
		}
		for (int l427 = 0; (l427 < 3); l427 = (l427 + 1)) {
			fRec427[l427] = 0.0f;
			
		}
		for (int l428 = 0; (l428 < 3); l428 = (l428 + 1)) {
			fRec426[l428] = 0.0f;
			
		}
		for (int l429 = 0; (l429 < 3); l429 = (l429 + 1)) {
			fRec425[l429] = 0.0f;
			
		}
		for (int l430 = 0; (l430 < 2); l430 = (l430 + 1)) {
			fRec424[l430] = 0.0f;
			
		}
		for (int l431 = 0; (l431 < 3); l431 = (l431 + 1)) {
			fRec437[l431] = 0.0f;
			
		}
		for (int l432 = 0; (l432 < 3); l432 = (l432 + 1)) {
			fRec436[l432] = 0.0f;
			
		}
		for (int l433 = 0; (l433 < 3); l433 = (l433 + 1)) {
			fRec435[l433] = 0.0f;
			
		}
		for (int l434 = 0; (l434 < 3); l434 = (l434 + 1)) {
			fRec434[l434] = 0.0f;
			
		}
		for (int l435 = 0; (l435 < 3); l435 = (l435 + 1)) {
			fRec433[l435] = 0.0f;
			
		}
		for (int l436 = 0; (l436 < 3); l436 = (l436 + 1)) {
			fRec432[l436] = 0.0f;
			
		}
		for (int l437 = 0; (l437 < 2); l437 = (l437 + 1)) {
			fRec431[l437] = 0.0f;
			
		}
		for (int l438 = 0; (l438 < 3); l438 = (l438 + 1)) {
			fRec444[l438] = 0.0f;
			
		}
		for (int l439 = 0; (l439 < 3); l439 = (l439 + 1)) {
			fRec443[l439] = 0.0f;
			
		}
		for (int l440 = 0; (l440 < 3); l440 = (l440 + 1)) {
			fRec442[l440] = 0.0f;
			
		}
		for (int l441 = 0; (l441 < 3); l441 = (l441 + 1)) {
			fRec441[l441] = 0.0f;
			
		}
		for (int l442 = 0; (l442 < 3); l442 = (l442 + 1)) {
			fRec440[l442] = 0.0f;
			
		}
		for (int l443 = 0; (l443 < 3); l443 = (l443 + 1)) {
			fRec439[l443] = 0.0f;
			
		}
		for (int l444 = 0; (l444 < 2); l444 = (l444 + 1)) {
			fRec438[l444] = 0.0f;
			
		}
		for (int l445 = 0; (l445 < 3); l445 = (l445 + 1)) {
			fRec451[l445] = 0.0f;
			
		}
		for (int l446 = 0; (l446 < 3); l446 = (l446 + 1)) {
			fRec450[l446] = 0.0f;
			
		}
		for (int l447 = 0; (l447 < 3); l447 = (l447 + 1)) {
			fRec449[l447] = 0.0f;
			
		}
		for (int l448 = 0; (l448 < 3); l448 = (l448 + 1)) {
			fRec448[l448] = 0.0f;
			
		}
		for (int l449 = 0; (l449 < 3); l449 = (l449 + 1)) {
			fRec447[l449] = 0.0f;
			
		}
		for (int l450 = 0; (l450 < 3); l450 = (l450 + 1)) {
			fRec446[l450] = 0.0f;
			
		}
		for (int l451 = 0; (l451 < 2); l451 = (l451 + 1)) {
			fRec445[l451] = 0.0f;
			
		}
		for (int l452 = 0; (l452 < 3); l452 = (l452 + 1)) {
			fRec458[l452] = 0.0f;
			
		}
		for (int l453 = 0; (l453 < 3); l453 = (l453 + 1)) {
			fRec457[l453] = 0.0f;
			
		}
		for (int l454 = 0; (l454 < 3); l454 = (l454 + 1)) {
			fRec456[l454] = 0.0f;
			
		}
		for (int l455 = 0; (l455 < 3); l455 = (l455 + 1)) {
			fRec455[l455] = 0.0f;
			
		}
		for (int l456 = 0; (l456 < 3); l456 = (l456 + 1)) {
			fRec454[l456] = 0.0f;
			
		}
		for (int l457 = 0; (l457 < 3); l457 = (l457 + 1)) {
			fRec453[l457] = 0.0f;
			
		}
		for (int l458 = 0; (l458 < 2); l458 = (l458 + 1)) {
			fRec452[l458] = 0.0f;
			
		}
		for (int l459 = 0; (l459 < 3); l459 = (l459 + 1)) {
			fRec465[l459] = 0.0f;
			
		}
		for (int l460 = 0; (l460 < 3); l460 = (l460 + 1)) {
			fRec464[l460] = 0.0f;
			
		}
		for (int l461 = 0; (l461 < 3); l461 = (l461 + 1)) {
			fRec463[l461] = 0.0f;
			
		}
		for (int l462 = 0; (l462 < 3); l462 = (l462 + 1)) {
			fRec462[l462] = 0.0f;
			
		}
		for (int l463 = 0; (l463 < 3); l463 = (l463 + 1)) {
			fRec461[l463] = 0.0f;
			
		}
		for (int l464 = 0; (l464 < 3); l464 = (l464 + 1)) {
			fRec460[l464] = 0.0f;
			
		}
		for (int l465 = 0; (l465 < 2); l465 = (l465 + 1)) {
			fRec459[l465] = 0.0f;
			
		}
		for (int l466 = 0; (l466 < 3); l466 = (l466 + 1)) {
			fRec472[l466] = 0.0f;
			
		}
		for (int l467 = 0; (l467 < 3); l467 = (l467 + 1)) {
			fRec471[l467] = 0.0f;
			
		}
		for (int l468 = 0; (l468 < 3); l468 = (l468 + 1)) {
			fRec470[l468] = 0.0f;
			
		}
		for (int l469 = 0; (l469 < 3); l469 = (l469 + 1)) {
			fRec469[l469] = 0.0f;
			
		}
		for (int l470 = 0; (l470 < 3); l470 = (l470 + 1)) {
			fRec468[l470] = 0.0f;
			
		}
		for (int l471 = 0; (l471 < 3); l471 = (l471 + 1)) {
			fRec467[l471] = 0.0f;
			
		}
		for (int l472 = 0; (l472 < 2); l472 = (l472 + 1)) {
			fRec466[l472] = 0.0f;
			
		}
		for (int l473 = 0; (l473 < 3); l473 = (l473 + 1)) {
			fRec479[l473] = 0.0f;
			
		}
		for (int l474 = 0; (l474 < 3); l474 = (l474 + 1)) {
			fRec478[l474] = 0.0f;
			
		}
		for (int l475 = 0; (l475 < 3); l475 = (l475 + 1)) {
			fRec477[l475] = 0.0f;
			
		}
		for (int l476 = 0; (l476 < 3); l476 = (l476 + 1)) {
			fRec476[l476] = 0.0f;
			
		}
		for (int l477 = 0; (l477 < 3); l477 = (l477 + 1)) {
			fRec475[l477] = 0.0f;
			
		}
		for (int l478 = 0; (l478 < 3); l478 = (l478 + 1)) {
			fRec474[l478] = 0.0f;
			
		}
		for (int l479 = 0; (l479 < 2); l479 = (l479 + 1)) {
			fRec473[l479] = 0.0f;
			
		}
		for (int l480 = 0; (l480 < 3); l480 = (l480 + 1)) {
			fRec486[l480] = 0.0f;
			
		}
		for (int l481 = 0; (l481 < 3); l481 = (l481 + 1)) {
			fRec485[l481] = 0.0f;
			
		}
		for (int l482 = 0; (l482 < 3); l482 = (l482 + 1)) {
			fRec484[l482] = 0.0f;
			
		}
		for (int l483 = 0; (l483 < 3); l483 = (l483 + 1)) {
			fRec483[l483] = 0.0f;
			
		}
		for (int l484 = 0; (l484 < 3); l484 = (l484 + 1)) {
			fRec482[l484] = 0.0f;
			
		}
		for (int l485 = 0; (l485 < 3); l485 = (l485 + 1)) {
			fRec481[l485] = 0.0f;
			
		}
		for (int l486 = 0; (l486 < 2); l486 = (l486 + 1)) {
			fRec480[l486] = 0.0f;
			
		}
		for (int l487 = 0; (l487 < 3); l487 = (l487 + 1)) {
			fRec493[l487] = 0.0f;
			
		}
		for (int l488 = 0; (l488 < 3); l488 = (l488 + 1)) {
			fRec492[l488] = 0.0f;
			
		}
		for (int l489 = 0; (l489 < 3); l489 = (l489 + 1)) {
			fRec491[l489] = 0.0f;
			
		}
		for (int l490 = 0; (l490 < 3); l490 = (l490 + 1)) {
			fRec490[l490] = 0.0f;
			
		}
		for (int l491 = 0; (l491 < 3); l491 = (l491 + 1)) {
			fRec489[l491] = 0.0f;
			
		}
		for (int l492 = 0; (l492 < 3); l492 = (l492 + 1)) {
			fRec488[l492] = 0.0f;
			
		}
		for (int l493 = 0; (l493 < 2); l493 = (l493 + 1)) {
			fRec487[l493] = 0.0f;
			
		}
		for (int l494 = 0; (l494 < 3); l494 = (l494 + 1)) {
			fRec500[l494] = 0.0f;
			
		}
		for (int l495 = 0; (l495 < 3); l495 = (l495 + 1)) {
			fRec499[l495] = 0.0f;
			
		}
		for (int l496 = 0; (l496 < 3); l496 = (l496 + 1)) {
			fRec498[l496] = 0.0f;
			
		}
		for (int l497 = 0; (l497 < 3); l497 = (l497 + 1)) {
			fRec497[l497] = 0.0f;
			
		}
		for (int l498 = 0; (l498 < 3); l498 = (l498 + 1)) {
			fRec496[l498] = 0.0f;
			
		}
		for (int l499 = 0; (l499 < 3); l499 = (l499 + 1)) {
			fRec495[l499] = 0.0f;
			
		}
		for (int l500 = 0; (l500 < 2); l500 = (l500 + 1)) {
			fRec494[l500] = 0.0f;
			
		}
		for (int l501 = 0; (l501 < 3); l501 = (l501 + 1)) {
			fRec507[l501] = 0.0f;
			
		}
		for (int l502 = 0; (l502 < 3); l502 = (l502 + 1)) {
			fRec506[l502] = 0.0f;
			
		}
		for (int l503 = 0; (l503 < 3); l503 = (l503 + 1)) {
			fRec505[l503] = 0.0f;
			
		}
		for (int l504 = 0; (l504 < 3); l504 = (l504 + 1)) {
			fRec504[l504] = 0.0f;
			
		}
		for (int l505 = 0; (l505 < 3); l505 = (l505 + 1)) {
			fRec503[l505] = 0.0f;
			
		}
		for (int l506 = 0; (l506 < 3); l506 = (l506 + 1)) {
			fRec502[l506] = 0.0f;
			
		}
		for (int l507 = 0; (l507 < 2); l507 = (l507 + 1)) {
			fRec501[l507] = 0.0f;
			
		}
		for (int l508 = 0; (l508 < 3); l508 = (l508 + 1)) {
			fRec514[l508] = 0.0f;
			
		}
		for (int l509 = 0; (l509 < 3); l509 = (l509 + 1)) {
			fRec513[l509] = 0.0f;
			
		}
		for (int l510 = 0; (l510 < 3); l510 = (l510 + 1)) {
			fRec512[l510] = 0.0f;
			
		}
		for (int l511 = 0; (l511 < 3); l511 = (l511 + 1)) {
			fRec511[l511] = 0.0f;
			
		}
		for (int l512 = 0; (l512 < 3); l512 = (l512 + 1)) {
			fRec510[l512] = 0.0f;
			
		}
		for (int l513 = 0; (l513 < 3); l513 = (l513 + 1)) {
			fRec509[l513] = 0.0f;
			
		}
		for (int l514 = 0; (l514 < 2); l514 = (l514 + 1)) {
			fRec508[l514] = 0.0f;
			
		}
		for (int l515 = 0; (l515 < 3); l515 = (l515 + 1)) {
			fRec521[l515] = 0.0f;
			
		}
		for (int l516 = 0; (l516 < 3); l516 = (l516 + 1)) {
			fRec520[l516] = 0.0f;
			
		}
		for (int l517 = 0; (l517 < 3); l517 = (l517 + 1)) {
			fRec519[l517] = 0.0f;
			
		}
		for (int l518 = 0; (l518 < 3); l518 = (l518 + 1)) {
			fRec518[l518] = 0.0f;
			
		}
		for (int l519 = 0; (l519 < 3); l519 = (l519 + 1)) {
			fRec517[l519] = 0.0f;
			
		}
		for (int l520 = 0; (l520 < 3); l520 = (l520 + 1)) {
			fRec516[l520] = 0.0f;
			
		}
		for (int l521 = 0; (l521 < 2); l521 = (l521 + 1)) {
			fRec515[l521] = 0.0f;
			
		}
		for (int l522 = 0; (l522 < 3); l522 = (l522 + 1)) {
			fRec528[l522] = 0.0f;
			
		}
		for (int l523 = 0; (l523 < 3); l523 = (l523 + 1)) {
			fRec527[l523] = 0.0f;
			
		}
		for (int l524 = 0; (l524 < 3); l524 = (l524 + 1)) {
			fRec526[l524] = 0.0f;
			
		}
		for (int l525 = 0; (l525 < 3); l525 = (l525 + 1)) {
			fRec525[l525] = 0.0f;
			
		}
		for (int l526 = 0; (l526 < 3); l526 = (l526 + 1)) {
			fRec524[l526] = 0.0f;
			
		}
		for (int l527 = 0; (l527 < 3); l527 = (l527 + 1)) {
			fRec523[l527] = 0.0f;
			
		}
		for (int l528 = 0; (l528 < 2); l528 = (l528 + 1)) {
			fRec522[l528] = 0.0f;
			
		}
		for (int l529 = 0; (l529 < 3); l529 = (l529 + 1)) {
			fRec535[l529] = 0.0f;
			
		}
		for (int l530 = 0; (l530 < 3); l530 = (l530 + 1)) {
			fRec534[l530] = 0.0f;
			
		}
		for (int l531 = 0; (l531 < 3); l531 = (l531 + 1)) {
			fRec533[l531] = 0.0f;
			
		}
		for (int l532 = 0; (l532 < 3); l532 = (l532 + 1)) {
			fRec532[l532] = 0.0f;
			
		}
		for (int l533 = 0; (l533 < 3); l533 = (l533 + 1)) {
			fRec531[l533] = 0.0f;
			
		}
		for (int l534 = 0; (l534 < 3); l534 = (l534 + 1)) {
			fRec530[l534] = 0.0f;
			
		}
		for (int l535 = 0; (l535 < 2); l535 = (l535 + 1)) {
			fRec529[l535] = 0.0f;
			
		}
		for (int l536 = 0; (l536 < 3); l536 = (l536 + 1)) {
			fRec542[l536] = 0.0f;
			
		}
		for (int l537 = 0; (l537 < 3); l537 = (l537 + 1)) {
			fRec541[l537] = 0.0f;
			
		}
		for (int l538 = 0; (l538 < 3); l538 = (l538 + 1)) {
			fRec540[l538] = 0.0f;
			
		}
		for (int l539 = 0; (l539 < 3); l539 = (l539 + 1)) {
			fRec539[l539] = 0.0f;
			
		}
		for (int l540 = 0; (l540 < 3); l540 = (l540 + 1)) {
			fRec538[l540] = 0.0f;
			
		}
		for (int l541 = 0; (l541 < 3); l541 = (l541 + 1)) {
			fRec537[l541] = 0.0f;
			
		}
		for (int l542 = 0; (l542 < 2); l542 = (l542 + 1)) {
			fRec536[l542] = 0.0f;
			
		}
		for (int l543 = 0; (l543 < 3); l543 = (l543 + 1)) {
			fRec549[l543] = 0.0f;
			
		}
		for (int l544 = 0; (l544 < 3); l544 = (l544 + 1)) {
			fRec548[l544] = 0.0f;
			
		}
		for (int l545 = 0; (l545 < 3); l545 = (l545 + 1)) {
			fRec547[l545] = 0.0f;
			
		}
		for (int l546 = 0; (l546 < 3); l546 = (l546 + 1)) {
			fRec546[l546] = 0.0f;
			
		}
		for (int l547 = 0; (l547 < 3); l547 = (l547 + 1)) {
			fRec545[l547] = 0.0f;
			
		}
		for (int l548 = 0; (l548 < 3); l548 = (l548 + 1)) {
			fRec544[l548] = 0.0f;
			
		}
		for (int l549 = 0; (l549 < 2); l549 = (l549 + 1)) {
			fRec543[l549] = 0.0f;
			
		}
		for (int l550 = 0; (l550 < 3); l550 = (l550 + 1)) {
			fRec556[l550] = 0.0f;
			
		}
		for (int l551 = 0; (l551 < 3); l551 = (l551 + 1)) {
			fRec555[l551] = 0.0f;
			
		}
		for (int l552 = 0; (l552 < 3); l552 = (l552 + 1)) {
			fRec554[l552] = 0.0f;
			
		}
		for (int l553 = 0; (l553 < 3); l553 = (l553 + 1)) {
			fRec553[l553] = 0.0f;
			
		}
		for (int l554 = 0; (l554 < 3); l554 = (l554 + 1)) {
			fRec552[l554] = 0.0f;
			
		}
		for (int l555 = 0; (l555 < 3); l555 = (l555 + 1)) {
			fRec551[l555] = 0.0f;
			
		}
		for (int l556 = 0; (l556 < 2); l556 = (l556 + 1)) {
			fRec550[l556] = 0.0f;
			
		}
		for (int l557 = 0; (l557 < 3); l557 = (l557 + 1)) {
			fRec563[l557] = 0.0f;
			
		}
		for (int l558 = 0; (l558 < 3); l558 = (l558 + 1)) {
			fRec562[l558] = 0.0f;
			
		}
		for (int l559 = 0; (l559 < 3); l559 = (l559 + 1)) {
			fRec561[l559] = 0.0f;
			
		}
		for (int l560 = 0; (l560 < 3); l560 = (l560 + 1)) {
			fRec560[l560] = 0.0f;
			
		}
		for (int l561 = 0; (l561 < 3); l561 = (l561 + 1)) {
			fRec559[l561] = 0.0f;
			
		}
		for (int l562 = 0; (l562 < 3); l562 = (l562 + 1)) {
			fRec558[l562] = 0.0f;
			
		}
		for (int l563 = 0; (l563 < 2); l563 = (l563 + 1)) {
			fRec557[l563] = 0.0f;
			
		}
		for (int l564 = 0; (l564 < 3); l564 = (l564 + 1)) {
			fRec570[l564] = 0.0f;
			
		}
		for (int l565 = 0; (l565 < 3); l565 = (l565 + 1)) {
			fRec569[l565] = 0.0f;
			
		}
		for (int l566 = 0; (l566 < 3); l566 = (l566 + 1)) {
			fRec568[l566] = 0.0f;
			
		}
		for (int l567 = 0; (l567 < 3); l567 = (l567 + 1)) {
			fRec567[l567] = 0.0f;
			
		}
		for (int l568 = 0; (l568 < 3); l568 = (l568 + 1)) {
			fRec566[l568] = 0.0f;
			
		}
		for (int l569 = 0; (l569 < 3); l569 = (l569 + 1)) {
			fRec565[l569] = 0.0f;
			
		}
		for (int l570 = 0; (l570 < 2); l570 = (l570 + 1)) {
			fRec564[l570] = 0.0f;
			
		}
		for (int l571 = 0; (l571 < 3); l571 = (l571 + 1)) {
			fRec577[l571] = 0.0f;
			
		}
		for (int l572 = 0; (l572 < 3); l572 = (l572 + 1)) {
			fRec576[l572] = 0.0f;
			
		}
		for (int l573 = 0; (l573 < 3); l573 = (l573 + 1)) {
			fRec575[l573] = 0.0f;
			
		}
		for (int l574 = 0; (l574 < 3); l574 = (l574 + 1)) {
			fRec574[l574] = 0.0f;
			
		}
		for (int l575 = 0; (l575 < 3); l575 = (l575 + 1)) {
			fRec573[l575] = 0.0f;
			
		}
		for (int l576 = 0; (l576 < 3); l576 = (l576 + 1)) {
			fRec572[l576] = 0.0f;
			
		}
		for (int l577 = 0; (l577 < 2); l577 = (l577 + 1)) {
			fRec571[l577] = 0.0f;
			
		}
		for (int l578 = 0; (l578 < 3); l578 = (l578 + 1)) {
			fRec584[l578] = 0.0f;
			
		}
		for (int l579 = 0; (l579 < 3); l579 = (l579 + 1)) {
			fRec583[l579] = 0.0f;
			
		}
		for (int l580 = 0; (l580 < 3); l580 = (l580 + 1)) {
			fRec582[l580] = 0.0f;
			
		}
		for (int l581 = 0; (l581 < 3); l581 = (l581 + 1)) {
			fRec581[l581] = 0.0f;
			
		}
		for (int l582 = 0; (l582 < 3); l582 = (l582 + 1)) {
			fRec580[l582] = 0.0f;
			
		}
		for (int l583 = 0; (l583 < 3); l583 = (l583 + 1)) {
			fRec579[l583] = 0.0f;
			
		}
		for (int l584 = 0; (l584 < 2); l584 = (l584 + 1)) {
			fRec578[l584] = 0.0f;
			
		}
		for (int l585 = 0; (l585 < 3); l585 = (l585 + 1)) {
			fRec591[l585] = 0.0f;
			
		}
		for (int l586 = 0; (l586 < 3); l586 = (l586 + 1)) {
			fRec590[l586] = 0.0f;
			
		}
		for (int l587 = 0; (l587 < 3); l587 = (l587 + 1)) {
			fRec589[l587] = 0.0f;
			
		}
		for (int l588 = 0; (l588 < 3); l588 = (l588 + 1)) {
			fRec588[l588] = 0.0f;
			
		}
		for (int l589 = 0; (l589 < 3); l589 = (l589 + 1)) {
			fRec587[l589] = 0.0f;
			
		}
		for (int l590 = 0; (l590 < 3); l590 = (l590 + 1)) {
			fRec586[l590] = 0.0f;
			
		}
		for (int l591 = 0; (l591 < 2); l591 = (l591 + 1)) {
			fRec585[l591] = 0.0f;
			
		}
		for (int l592 = 0; (l592 < 3); l592 = (l592 + 1)) {
			fRec598[l592] = 0.0f;
			
		}
		for (int l593 = 0; (l593 < 3); l593 = (l593 + 1)) {
			fRec597[l593] = 0.0f;
			
		}
		for (int l594 = 0; (l594 < 3); l594 = (l594 + 1)) {
			fRec596[l594] = 0.0f;
			
		}
		for (int l595 = 0; (l595 < 3); l595 = (l595 + 1)) {
			fRec595[l595] = 0.0f;
			
		}
		for (int l596 = 0; (l596 < 3); l596 = (l596 + 1)) {
			fRec594[l596] = 0.0f;
			
		}
		for (int l597 = 0; (l597 < 3); l597 = (l597 + 1)) {
			fRec593[l597] = 0.0f;
			
		}
		for (int l598 = 0; (l598 < 2); l598 = (l598 + 1)) {
			fRec592[l598] = 0.0f;
			
		}
		for (int l599 = 0; (l599 < 3); l599 = (l599 + 1)) {
			fRec605[l599] = 0.0f;
			
		}
		for (int l600 = 0; (l600 < 3); l600 = (l600 + 1)) {
			fRec604[l600] = 0.0f;
			
		}
		for (int l601 = 0; (l601 < 3); l601 = (l601 + 1)) {
			fRec603[l601] = 0.0f;
			
		}
		for (int l602 = 0; (l602 < 3); l602 = (l602 + 1)) {
			fRec602[l602] = 0.0f;
			
		}
		for (int l603 = 0; (l603 < 3); l603 = (l603 + 1)) {
			fRec601[l603] = 0.0f;
			
		}
		for (int l604 = 0; (l604 < 3); l604 = (l604 + 1)) {
			fRec600[l604] = 0.0f;
			
		}
		for (int l605 = 0; (l605 < 2); l605 = (l605 + 1)) {
			fRec599[l605] = 0.0f;
			
		}
		for (int l606 = 0; (l606 < 3); l606 = (l606 + 1)) {
			fRec612[l606] = 0.0f;
			
		}
		for (int l607 = 0; (l607 < 3); l607 = (l607 + 1)) {
			fRec611[l607] = 0.0f;
			
		}
		for (int l608 = 0; (l608 < 3); l608 = (l608 + 1)) {
			fRec610[l608] = 0.0f;
			
		}
		for (int l609 = 0; (l609 < 3); l609 = (l609 + 1)) {
			fRec609[l609] = 0.0f;
			
		}
		for (int l610 = 0; (l610 < 3); l610 = (l610 + 1)) {
			fRec608[l610] = 0.0f;
			
		}
		for (int l611 = 0; (l611 < 3); l611 = (l611 + 1)) {
			fRec607[l611] = 0.0f;
			
		}
		for (int l612 = 0; (l612 < 2); l612 = (l612 + 1)) {
			fRec606[l612] = 0.0f;
			
		}
		for (int l613 = 0; (l613 < 3); l613 = (l613 + 1)) {
			fRec619[l613] = 0.0f;
			
		}
		for (int l614 = 0; (l614 < 3); l614 = (l614 + 1)) {
			fRec618[l614] = 0.0f;
			
		}
		for (int l615 = 0; (l615 < 3); l615 = (l615 + 1)) {
			fRec617[l615] = 0.0f;
			
		}
		for (int l616 = 0; (l616 < 3); l616 = (l616 + 1)) {
			fRec616[l616] = 0.0f;
			
		}
		for (int l617 = 0; (l617 < 3); l617 = (l617 + 1)) {
			fRec615[l617] = 0.0f;
			
		}
		for (int l618 = 0; (l618 < 3); l618 = (l618 + 1)) {
			fRec614[l618] = 0.0f;
			
		}
		for (int l619 = 0; (l619 < 2); l619 = (l619 + 1)) {
			fRec613[l619] = 0.0f;
			
		}
		for (int l620 = 0; (l620 < 3); l620 = (l620 + 1)) {
			fRec626[l620] = 0.0f;
			
		}
		for (int l621 = 0; (l621 < 3); l621 = (l621 + 1)) {
			fRec625[l621] = 0.0f;
			
		}
		for (int l622 = 0; (l622 < 3); l622 = (l622 + 1)) {
			fRec624[l622] = 0.0f;
			
		}
		for (int l623 = 0; (l623 < 3); l623 = (l623 + 1)) {
			fRec623[l623] = 0.0f;
			
		}
		for (int l624 = 0; (l624 < 3); l624 = (l624 + 1)) {
			fRec622[l624] = 0.0f;
			
		}
		for (int l625 = 0; (l625 < 3); l625 = (l625 + 1)) {
			fRec621[l625] = 0.0f;
			
		}
		for (int l626 = 0; (l626 < 2); l626 = (l626 + 1)) {
			fRec620[l626] = 0.0f;
			
		}
		for (int l627 = 0; (l627 < 3); l627 = (l627 + 1)) {
			fRec633[l627] = 0.0f;
			
		}
		for (int l628 = 0; (l628 < 3); l628 = (l628 + 1)) {
			fRec632[l628] = 0.0f;
			
		}
		for (int l629 = 0; (l629 < 3); l629 = (l629 + 1)) {
			fRec631[l629] = 0.0f;
			
		}
		for (int l630 = 0; (l630 < 3); l630 = (l630 + 1)) {
			fRec630[l630] = 0.0f;
			
		}
		for (int l631 = 0; (l631 < 3); l631 = (l631 + 1)) {
			fRec629[l631] = 0.0f;
			
		}
		for (int l632 = 0; (l632 < 3); l632 = (l632 + 1)) {
			fRec628[l632] = 0.0f;
			
		}
		for (int l633 = 0; (l633 < 2); l633 = (l633 + 1)) {
			fRec627[l633] = 0.0f;
			
		}
		for (int l634 = 0; (l634 < 3); l634 = (l634 + 1)) {
			fRec640[l634] = 0.0f;
			
		}
		for (int l635 = 0; (l635 < 3); l635 = (l635 + 1)) {
			fRec639[l635] = 0.0f;
			
		}
		for (int l636 = 0; (l636 < 3); l636 = (l636 + 1)) {
			fRec638[l636] = 0.0f;
			
		}
		for (int l637 = 0; (l637 < 3); l637 = (l637 + 1)) {
			fRec637[l637] = 0.0f;
			
		}
		for (int l638 = 0; (l638 < 3); l638 = (l638 + 1)) {
			fRec636[l638] = 0.0f;
			
		}
		for (int l639 = 0; (l639 < 3); l639 = (l639 + 1)) {
			fRec635[l639] = 0.0f;
			
		}
		for (int l640 = 0; (l640 < 2); l640 = (l640 + 1)) {
			fRec634[l640] = 0.0f;
			
		}
		for (int l641 = 0; (l641 < 3); l641 = (l641 + 1)) {
			fRec647[l641] = 0.0f;
			
		}
		for (int l642 = 0; (l642 < 3); l642 = (l642 + 1)) {
			fRec646[l642] = 0.0f;
			
		}
		for (int l643 = 0; (l643 < 3); l643 = (l643 + 1)) {
			fRec645[l643] = 0.0f;
			
		}
		for (int l644 = 0; (l644 < 3); l644 = (l644 + 1)) {
			fRec644[l644] = 0.0f;
			
		}
		for (int l645 = 0; (l645 < 3); l645 = (l645 + 1)) {
			fRec643[l645] = 0.0f;
			
		}
		for (int l646 = 0; (l646 < 3); l646 = (l646 + 1)) {
			fRec642[l646] = 0.0f;
			
		}
		for (int l647 = 0; (l647 < 2); l647 = (l647 + 1)) {
			fRec641[l647] = 0.0f;
			
		}
		for (int l648 = 0; (l648 < 3); l648 = (l648 + 1)) {
			fRec654[l648] = 0.0f;
			
		}
		for (int l649 = 0; (l649 < 3); l649 = (l649 + 1)) {
			fRec653[l649] = 0.0f;
			
		}
		for (int l650 = 0; (l650 < 3); l650 = (l650 + 1)) {
			fRec652[l650] = 0.0f;
			
		}
		for (int l651 = 0; (l651 < 3); l651 = (l651 + 1)) {
			fRec651[l651] = 0.0f;
			
		}
		for (int l652 = 0; (l652 < 3); l652 = (l652 + 1)) {
			fRec650[l652] = 0.0f;
			
		}
		for (int l653 = 0; (l653 < 3); l653 = (l653 + 1)) {
			fRec649[l653] = 0.0f;
			
		}
		for (int l654 = 0; (l654 < 2); l654 = (l654 + 1)) {
			fRec648[l654] = 0.0f;
			
		}
		for (int l655 = 0; (l655 < 3); l655 = (l655 + 1)) {
			fRec661[l655] = 0.0f;
			
		}
		for (int l656 = 0; (l656 < 3); l656 = (l656 + 1)) {
			fRec660[l656] = 0.0f;
			
		}
		for (int l657 = 0; (l657 < 3); l657 = (l657 + 1)) {
			fRec659[l657] = 0.0f;
			
		}
		for (int l658 = 0; (l658 < 3); l658 = (l658 + 1)) {
			fRec658[l658] = 0.0f;
			
		}
		for (int l659 = 0; (l659 < 3); l659 = (l659 + 1)) {
			fRec657[l659] = 0.0f;
			
		}
		for (int l660 = 0; (l660 < 3); l660 = (l660 + 1)) {
			fRec656[l660] = 0.0f;
			
		}
		for (int l661 = 0; (l661 < 2); l661 = (l661 + 1)) {
			fRec655[l661] = 0.0f;
			
		}
		for (int l662 = 0; (l662 < 3); l662 = (l662 + 1)) {
			fRec668[l662] = 0.0f;
			
		}
		for (int l663 = 0; (l663 < 3); l663 = (l663 + 1)) {
			fRec667[l663] = 0.0f;
			
		}
		for (int l664 = 0; (l664 < 3); l664 = (l664 + 1)) {
			fRec666[l664] = 0.0f;
			
		}
		for (int l665 = 0; (l665 < 3); l665 = (l665 + 1)) {
			fRec665[l665] = 0.0f;
			
		}
		for (int l666 = 0; (l666 < 3); l666 = (l666 + 1)) {
			fRec664[l666] = 0.0f;
			
		}
		for (int l667 = 0; (l667 < 3); l667 = (l667 + 1)) {
			fRec663[l667] = 0.0f;
			
		}
		for (int l668 = 0; (l668 < 2); l668 = (l668 + 1)) {
			fRec662[l668] = 0.0f;
			
		}
		for (int l669 = 0; (l669 < 3); l669 = (l669 + 1)) {
			fRec675[l669] = 0.0f;
			
		}
		for (int l670 = 0; (l670 < 3); l670 = (l670 + 1)) {
			fRec674[l670] = 0.0f;
			
		}
		for (int l671 = 0; (l671 < 3); l671 = (l671 + 1)) {
			fRec673[l671] = 0.0f;
			
		}
		for (int l672 = 0; (l672 < 3); l672 = (l672 + 1)) {
			fRec672[l672] = 0.0f;
			
		}
		for (int l673 = 0; (l673 < 3); l673 = (l673 + 1)) {
			fRec671[l673] = 0.0f;
			
		}
		for (int l674 = 0; (l674 < 3); l674 = (l674 + 1)) {
			fRec670[l674] = 0.0f;
			
		}
		for (int l675 = 0; (l675 < 2); l675 = (l675 + 1)) {
			fRec669[l675] = 0.0f;
			
		}
		for (int l676 = 0; (l676 < 3); l676 = (l676 + 1)) {
			fRec682[l676] = 0.0f;
			
		}
		for (int l677 = 0; (l677 < 3); l677 = (l677 + 1)) {
			fRec681[l677] = 0.0f;
			
		}
		for (int l678 = 0; (l678 < 3); l678 = (l678 + 1)) {
			fRec680[l678] = 0.0f;
			
		}
		for (int l679 = 0; (l679 < 3); l679 = (l679 + 1)) {
			fRec679[l679] = 0.0f;
			
		}
		for (int l680 = 0; (l680 < 3); l680 = (l680 + 1)) {
			fRec678[l680] = 0.0f;
			
		}
		for (int l681 = 0; (l681 < 3); l681 = (l681 + 1)) {
			fRec677[l681] = 0.0f;
			
		}
		for (int l682 = 0; (l682 < 2); l682 = (l682 + 1)) {
			fRec676[l682] = 0.0f;
			
		}
		for (int l683 = 0; (l683 < 3); l683 = (l683 + 1)) {
			fRec689[l683] = 0.0f;
			
		}
		for (int l684 = 0; (l684 < 3); l684 = (l684 + 1)) {
			fRec688[l684] = 0.0f;
			
		}
		for (int l685 = 0; (l685 < 3); l685 = (l685 + 1)) {
			fRec687[l685] = 0.0f;
			
		}
		for (int l686 = 0; (l686 < 3); l686 = (l686 + 1)) {
			fRec686[l686] = 0.0f;
			
		}
		for (int l687 = 0; (l687 < 3); l687 = (l687 + 1)) {
			fRec685[l687] = 0.0f;
			
		}
		for (int l688 = 0; (l688 < 3); l688 = (l688 + 1)) {
			fRec684[l688] = 0.0f;
			
		}
		for (int l689 = 0; (l689 < 2); l689 = (l689 + 1)) {
			fRec683[l689] = 0.0f;
			
		}
		for (int l690 = 0; (l690 < 3); l690 = (l690 + 1)) {
			fRec696[l690] = 0.0f;
			
		}
		for (int l691 = 0; (l691 < 3); l691 = (l691 + 1)) {
			fRec695[l691] = 0.0f;
			
		}
		for (int l692 = 0; (l692 < 3); l692 = (l692 + 1)) {
			fRec694[l692] = 0.0f;
			
		}
		for (int l693 = 0; (l693 < 3); l693 = (l693 + 1)) {
			fRec693[l693] = 0.0f;
			
		}
		for (int l694 = 0; (l694 < 3); l694 = (l694 + 1)) {
			fRec692[l694] = 0.0f;
			
		}
		for (int l695 = 0; (l695 < 3); l695 = (l695 + 1)) {
			fRec691[l695] = 0.0f;
			
		}
		for (int l696 = 0; (l696 < 2); l696 = (l696 + 1)) {
			fRec690[l696] = 0.0f;
			
		}
		for (int l697 = 0; (l697 < 3); l697 = (l697 + 1)) {
			fRec703[l697] = 0.0f;
			
		}
		for (int l698 = 0; (l698 < 3); l698 = (l698 + 1)) {
			fRec702[l698] = 0.0f;
			
		}
		for (int l699 = 0; (l699 < 3); l699 = (l699 + 1)) {
			fRec701[l699] = 0.0f;
			
		}
		for (int l700 = 0; (l700 < 3); l700 = (l700 + 1)) {
			fRec700[l700] = 0.0f;
			
		}
		for (int l701 = 0; (l701 < 3); l701 = (l701 + 1)) {
			fRec699[l701] = 0.0f;
			
		}
		for (int l702 = 0; (l702 < 3); l702 = (l702 + 1)) {
			fRec698[l702] = 0.0f;
			
		}
		for (int l703 = 0; (l703 < 2); l703 = (l703 + 1)) {
			fRec697[l703] = 0.0f;
			
		}
		for (int l704 = 0; (l704 < 3); l704 = (l704 + 1)) {
			fRec710[l704] = 0.0f;
			
		}
		for (int l705 = 0; (l705 < 3); l705 = (l705 + 1)) {
			fRec709[l705] = 0.0f;
			
		}
		for (int l706 = 0; (l706 < 3); l706 = (l706 + 1)) {
			fRec708[l706] = 0.0f;
			
		}
		for (int l707 = 0; (l707 < 3); l707 = (l707 + 1)) {
			fRec707[l707] = 0.0f;
			
		}
		for (int l708 = 0; (l708 < 3); l708 = (l708 + 1)) {
			fRec706[l708] = 0.0f;
			
		}
		for (int l709 = 0; (l709 < 3); l709 = (l709 + 1)) {
			fRec705[l709] = 0.0f;
			
		}
		for (int l710 = 0; (l710 < 2); l710 = (l710 + 1)) {
			fRec704[l710] = 0.0f;
			
		}
		for (int l711 = 0; (l711 < 3); l711 = (l711 + 1)) {
			fRec717[l711] = 0.0f;
			
		}
		for (int l712 = 0; (l712 < 3); l712 = (l712 + 1)) {
			fRec716[l712] = 0.0f;
			
		}
		for (int l713 = 0; (l713 < 3); l713 = (l713 + 1)) {
			fRec715[l713] = 0.0f;
			
		}
		for (int l714 = 0; (l714 < 3); l714 = (l714 + 1)) {
			fRec714[l714] = 0.0f;
			
		}
		for (int l715 = 0; (l715 < 3); l715 = (l715 + 1)) {
			fRec713[l715] = 0.0f;
			
		}
		for (int l716 = 0; (l716 < 3); l716 = (l716 + 1)) {
			fRec712[l716] = 0.0f;
			
		}
		for (int l717 = 0; (l717 < 2); l717 = (l717 + 1)) {
			fRec711[l717] = 0.0f;
			
		}
		for (int l718 = 0; (l718 < 3); l718 = (l718 + 1)) {
			fRec724[l718] = 0.0f;
			
		}
		for (int l719 = 0; (l719 < 3); l719 = (l719 + 1)) {
			fRec723[l719] = 0.0f;
			
		}
		for (int l720 = 0; (l720 < 3); l720 = (l720 + 1)) {
			fRec722[l720] = 0.0f;
			
		}
		for (int l721 = 0; (l721 < 3); l721 = (l721 + 1)) {
			fRec721[l721] = 0.0f;
			
		}
		for (int l722 = 0; (l722 < 3); l722 = (l722 + 1)) {
			fRec720[l722] = 0.0f;
			
		}
		for (int l723 = 0; (l723 < 3); l723 = (l723 + 1)) {
			fRec719[l723] = 0.0f;
			
		}
		for (int l724 = 0; (l724 < 2); l724 = (l724 + 1)) {
			fRec718[l724] = 0.0f;
			
		}
		for (int l725 = 0; (l725 < 3); l725 = (l725 + 1)) {
			fRec731[l725] = 0.0f;
			
		}
		for (int l726 = 0; (l726 < 3); l726 = (l726 + 1)) {
			fRec730[l726] = 0.0f;
			
		}
		for (int l727 = 0; (l727 < 3); l727 = (l727 + 1)) {
			fRec729[l727] = 0.0f;
			
		}
		for (int l728 = 0; (l728 < 3); l728 = (l728 + 1)) {
			fRec728[l728] = 0.0f;
			
		}
		for (int l729 = 0; (l729 < 3); l729 = (l729 + 1)) {
			fRec727[l729] = 0.0f;
			
		}
		for (int l730 = 0; (l730 < 3); l730 = (l730 + 1)) {
			fRec726[l730] = 0.0f;
			
		}
		for (int l731 = 0; (l731 < 2); l731 = (l731 + 1)) {
			fRec725[l731] = 0.0f;
			
		}
		for (int l732 = 0; (l732 < 3); l732 = (l732 + 1)) {
			fRec738[l732] = 0.0f;
			
		}
		for (int l733 = 0; (l733 < 3); l733 = (l733 + 1)) {
			fRec737[l733] = 0.0f;
			
		}
		for (int l734 = 0; (l734 < 3); l734 = (l734 + 1)) {
			fRec736[l734] = 0.0f;
			
		}
		for (int l735 = 0; (l735 < 3); l735 = (l735 + 1)) {
			fRec735[l735] = 0.0f;
			
		}
		for (int l736 = 0; (l736 < 3); l736 = (l736 + 1)) {
			fRec734[l736] = 0.0f;
			
		}
		for (int l737 = 0; (l737 < 3); l737 = (l737 + 1)) {
			fRec733[l737] = 0.0f;
			
		}
		for (int l738 = 0; (l738 < 2); l738 = (l738 + 1)) {
			fRec732[l738] = 0.0f;
			
		}
		for (int l739 = 0; (l739 < 3); l739 = (l739 + 1)) {
			fRec745[l739] = 0.0f;
			
		}
		for (int l740 = 0; (l740 < 3); l740 = (l740 + 1)) {
			fRec744[l740] = 0.0f;
			
		}
		for (int l741 = 0; (l741 < 3); l741 = (l741 + 1)) {
			fRec743[l741] = 0.0f;
			
		}
		for (int l742 = 0; (l742 < 3); l742 = (l742 + 1)) {
			fRec742[l742] = 0.0f;
			
		}
		for (int l743 = 0; (l743 < 3); l743 = (l743 + 1)) {
			fRec741[l743] = 0.0f;
			
		}
		for (int l744 = 0; (l744 < 3); l744 = (l744 + 1)) {
			fRec740[l744] = 0.0f;
			
		}
		for (int l745 = 0; (l745 < 2); l745 = (l745 + 1)) {
			fRec739[l745] = 0.0f;
			
		}
		for (int l746 = 0; (l746 < 3); l746 = (l746 + 1)) {
			fRec752[l746] = 0.0f;
			
		}
		for (int l747 = 0; (l747 < 3); l747 = (l747 + 1)) {
			fRec751[l747] = 0.0f;
			
		}
		for (int l748 = 0; (l748 < 3); l748 = (l748 + 1)) {
			fRec750[l748] = 0.0f;
			
		}
		for (int l749 = 0; (l749 < 3); l749 = (l749 + 1)) {
			fRec749[l749] = 0.0f;
			
		}
		for (int l750 = 0; (l750 < 3); l750 = (l750 + 1)) {
			fRec748[l750] = 0.0f;
			
		}
		for (int l751 = 0; (l751 < 3); l751 = (l751 + 1)) {
			fRec747[l751] = 0.0f;
			
		}
		for (int l752 = 0; (l752 < 2); l752 = (l752 + 1)) {
			fRec746[l752] = 0.0f;
			
		}
		for (int l753 = 0; (l753 < 3); l753 = (l753 + 1)) {
			fRec759[l753] = 0.0f;
			
		}
		for (int l754 = 0; (l754 < 3); l754 = (l754 + 1)) {
			fRec758[l754] = 0.0f;
			
		}
		for (int l755 = 0; (l755 < 3); l755 = (l755 + 1)) {
			fRec757[l755] = 0.0f;
			
		}
		for (int l756 = 0; (l756 < 3); l756 = (l756 + 1)) {
			fRec756[l756] = 0.0f;
			
		}
		for (int l757 = 0; (l757 < 3); l757 = (l757 + 1)) {
			fRec755[l757] = 0.0f;
			
		}
		for (int l758 = 0; (l758 < 3); l758 = (l758 + 1)) {
			fRec754[l758] = 0.0f;
			
		}
		for (int l759 = 0; (l759 < 2); l759 = (l759 + 1)) {
			fRec753[l759] = 0.0f;
			
		}
		for (int l760 = 0; (l760 < 3); l760 = (l760 + 1)) {
			fRec766[l760] = 0.0f;
			
		}
		for (int l761 = 0; (l761 < 3); l761 = (l761 + 1)) {
			fRec765[l761] = 0.0f;
			
		}
		for (int l762 = 0; (l762 < 3); l762 = (l762 + 1)) {
			fRec764[l762] = 0.0f;
			
		}
		for (int l763 = 0; (l763 < 3); l763 = (l763 + 1)) {
			fRec763[l763] = 0.0f;
			
		}
		for (int l764 = 0; (l764 < 3); l764 = (l764 + 1)) {
			fRec762[l764] = 0.0f;
			
		}
		for (int l765 = 0; (l765 < 3); l765 = (l765 + 1)) {
			fRec761[l765] = 0.0f;
			
		}
		for (int l766 = 0; (l766 < 2); l766 = (l766 + 1)) {
			fRec760[l766] = 0.0f;
			
		}
		for (int l767 = 0; (l767 < 3); l767 = (l767 + 1)) {
			fRec773[l767] = 0.0f;
			
		}
		for (int l768 = 0; (l768 < 3); l768 = (l768 + 1)) {
			fRec772[l768] = 0.0f;
			
		}
		for (int l769 = 0; (l769 < 3); l769 = (l769 + 1)) {
			fRec771[l769] = 0.0f;
			
		}
		for (int l770 = 0; (l770 < 3); l770 = (l770 + 1)) {
			fRec770[l770] = 0.0f;
			
		}
		for (int l771 = 0; (l771 < 3); l771 = (l771 + 1)) {
			fRec769[l771] = 0.0f;
			
		}
		for (int l772 = 0; (l772 < 3); l772 = (l772 + 1)) {
			fRec768[l772] = 0.0f;
			
		}
		for (int l773 = 0; (l773 < 2); l773 = (l773 + 1)) {
			fRec767[l773] = 0.0f;
			
		}
		for (int l774 = 0; (l774 < 3); l774 = (l774 + 1)) {
			fRec780[l774] = 0.0f;
			
		}
		for (int l775 = 0; (l775 < 3); l775 = (l775 + 1)) {
			fRec779[l775] = 0.0f;
			
		}
		for (int l776 = 0; (l776 < 3); l776 = (l776 + 1)) {
			fRec778[l776] = 0.0f;
			
		}
		for (int l777 = 0; (l777 < 3); l777 = (l777 + 1)) {
			fRec777[l777] = 0.0f;
			
		}
		for (int l778 = 0; (l778 < 3); l778 = (l778 + 1)) {
			fRec776[l778] = 0.0f;
			
		}
		for (int l779 = 0; (l779 < 3); l779 = (l779 + 1)) {
			fRec775[l779] = 0.0f;
			
		}
		for (int l780 = 0; (l780 < 2); l780 = (l780 + 1)) {
			fRec774[l780] = 0.0f;
			
		}
		for (int l781 = 0; (l781 < 3); l781 = (l781 + 1)) {
			fRec787[l781] = 0.0f;
			
		}
		for (int l782 = 0; (l782 < 3); l782 = (l782 + 1)) {
			fRec786[l782] = 0.0f;
			
		}
		for (int l783 = 0; (l783 < 3); l783 = (l783 + 1)) {
			fRec785[l783] = 0.0f;
			
		}
		for (int l784 = 0; (l784 < 3); l784 = (l784 + 1)) {
			fRec784[l784] = 0.0f;
			
		}
		for (int l785 = 0; (l785 < 3); l785 = (l785 + 1)) {
			fRec783[l785] = 0.0f;
			
		}
		for (int l786 = 0; (l786 < 3); l786 = (l786 + 1)) {
			fRec782[l786] = 0.0f;
			
		}
		for (int l787 = 0; (l787 < 2); l787 = (l787 + 1)) {
			fRec781[l787] = 0.0f;
			
		}
		for (int l788 = 0; (l788 < 3); l788 = (l788 + 1)) {
			fRec794[l788] = 0.0f;
			
		}
		for (int l789 = 0; (l789 < 3); l789 = (l789 + 1)) {
			fRec793[l789] = 0.0f;
			
		}
		for (int l790 = 0; (l790 < 3); l790 = (l790 + 1)) {
			fRec792[l790] = 0.0f;
			
		}
		for (int l791 = 0; (l791 < 3); l791 = (l791 + 1)) {
			fRec791[l791] = 0.0f;
			
		}
		for (int l792 = 0; (l792 < 3); l792 = (l792 + 1)) {
			fRec790[l792] = 0.0f;
			
		}
		for (int l793 = 0; (l793 < 3); l793 = (l793 + 1)) {
			fRec789[l793] = 0.0f;
			
		}
		for (int l794 = 0; (l794 < 2); l794 = (l794 + 1)) {
			fRec788[l794] = 0.0f;
			
		}
		for (int l795 = 0; (l795 < 3); l795 = (l795 + 1)) {
			fRec801[l795] = 0.0f;
			
		}
		for (int l796 = 0; (l796 < 3); l796 = (l796 + 1)) {
			fRec800[l796] = 0.0f;
			
		}
		for (int l797 = 0; (l797 < 3); l797 = (l797 + 1)) {
			fRec799[l797] = 0.0f;
			
		}
		for (int l798 = 0; (l798 < 3); l798 = (l798 + 1)) {
			fRec798[l798] = 0.0f;
			
		}
		for (int l799 = 0; (l799 < 3); l799 = (l799 + 1)) {
			fRec797[l799] = 0.0f;
			
		}
		for (int l800 = 0; (l800 < 3); l800 = (l800 + 1)) {
			fRec796[l800] = 0.0f;
			
		}
		for (int l801 = 0; (l801 < 2); l801 = (l801 + 1)) {
			fRec795[l801] = 0.0f;
			
		}
		for (int l802 = 0; (l802 < 3); l802 = (l802 + 1)) {
			fRec808[l802] = 0.0f;
			
		}
		for (int l803 = 0; (l803 < 3); l803 = (l803 + 1)) {
			fRec807[l803] = 0.0f;
			
		}
		for (int l804 = 0; (l804 < 3); l804 = (l804 + 1)) {
			fRec806[l804] = 0.0f;
			
		}
		for (int l805 = 0; (l805 < 3); l805 = (l805 + 1)) {
			fRec805[l805] = 0.0f;
			
		}
		for (int l806 = 0; (l806 < 3); l806 = (l806 + 1)) {
			fRec804[l806] = 0.0f;
			
		}
		for (int l807 = 0; (l807 < 3); l807 = (l807 + 1)) {
			fRec803[l807] = 0.0f;
			
		}
		for (int l808 = 0; (l808 < 2); l808 = (l808 + 1)) {
			fRec802[l808] = 0.0f;
			
		}
		for (int l809 = 0; (l809 < 3); l809 = (l809 + 1)) {
			fRec815[l809] = 0.0f;
			
		}
		for (int l810 = 0; (l810 < 3); l810 = (l810 + 1)) {
			fRec814[l810] = 0.0f;
			
		}
		for (int l811 = 0; (l811 < 3); l811 = (l811 + 1)) {
			fRec813[l811] = 0.0f;
			
		}
		for (int l812 = 0; (l812 < 3); l812 = (l812 + 1)) {
			fRec812[l812] = 0.0f;
			
		}
		for (int l813 = 0; (l813 < 3); l813 = (l813 + 1)) {
			fRec811[l813] = 0.0f;
			
		}
		for (int l814 = 0; (l814 < 3); l814 = (l814 + 1)) {
			fRec810[l814] = 0.0f;
			
		}
		for (int l815 = 0; (l815 < 2); l815 = (l815 + 1)) {
			fRec809[l815] = 0.0f;
			
		}
		for (int l816 = 0; (l816 < 3); l816 = (l816 + 1)) {
			fRec822[l816] = 0.0f;
			
		}
		for (int l817 = 0; (l817 < 3); l817 = (l817 + 1)) {
			fRec821[l817] = 0.0f;
			
		}
		for (int l818 = 0; (l818 < 3); l818 = (l818 + 1)) {
			fRec820[l818] = 0.0f;
			
		}
		for (int l819 = 0; (l819 < 3); l819 = (l819 + 1)) {
			fRec819[l819] = 0.0f;
			
		}
		for (int l820 = 0; (l820 < 3); l820 = (l820 + 1)) {
			fRec818[l820] = 0.0f;
			
		}
		for (int l821 = 0; (l821 < 3); l821 = (l821 + 1)) {
			fRec817[l821] = 0.0f;
			
		}
		for (int l822 = 0; (l822 < 2); l822 = (l822 + 1)) {
			fRec816[l822] = 0.0f;
			
		}
		for (int l823 = 0; (l823 < 3); l823 = (l823 + 1)) {
			fRec829[l823] = 0.0f;
			
		}
		for (int l824 = 0; (l824 < 3); l824 = (l824 + 1)) {
			fRec828[l824] = 0.0f;
			
		}
		for (int l825 = 0; (l825 < 3); l825 = (l825 + 1)) {
			fRec827[l825] = 0.0f;
			
		}
		for (int l826 = 0; (l826 < 3); l826 = (l826 + 1)) {
			fRec826[l826] = 0.0f;
			
		}
		for (int l827 = 0; (l827 < 3); l827 = (l827 + 1)) {
			fRec825[l827] = 0.0f;
			
		}
		for (int l828 = 0; (l828 < 3); l828 = (l828 + 1)) {
			fRec824[l828] = 0.0f;
			
		}
		for (int l829 = 0; (l829 < 2); l829 = (l829 + 1)) {
			fRec823[l829] = 0.0f;
			
		}
		for (int l830 = 0; (l830 < 3); l830 = (l830 + 1)) {
			fRec833[l830] = 0.0f;
			
		}
		for (int l831 = 0; (l831 < 3); l831 = (l831 + 1)) {
			fRec832[l831] = 0.0f;
			
		}
		for (int l832 = 0; (l832 < 3); l832 = (l832 + 1)) {
			fRec831[l832] = 0.0f;
			
		}
		for (int l833 = 0; (l833 < 2); l833 = (l833 + 1)) {
			fRec830[l833] = 0.0f;
			
		}
		
	}
	
	virtual void init(int sample_rate) {
		classInit(sample_rate);
		instanceInit(sample_rate);
	}
	virtual void instanceInit(int sample_rate) {
		instanceConstants(sample_rate);
		instanceResetUserInterface();
		instanceClear();
	}
	
	virtual mydsp* clone() {
		return new mydsp();
	}
	
	virtual int getSampleRate() {
		return fSampleRate;
		
	}
	
	static Array<PropertyComponent*> createTextEditors()
	{
		return { new TextPropertyComponent(Value(var("This is a single-line Text Property")), "Text 1", 200, false),
				 new TextPropertyComponent(Value(var("Another one")), "Text 2", 200, false),
				 new TextPropertyComponent(Value(var("Lorem ipsum dolor sit amet, cu mei labore admodum facilisi. Iriure iuvaret invenire ea vim, cum quod"
														 "si intellegat delicatissimi an. Cetero recteque ei eos, his an scripta fastidii placerat. Nec et anc"
														 "illae nominati corrumpit. Vis dictas audire accumsan ad, elit fabulas saperet mel eu.\n"
														 "\n"
														 "Dicam utroque ius ne, eum choro phaedrum eu. Ut mel omnes virtute appareat, semper quodsi labitur in"
														 " cum. Est aeque eripuit deleniti in, amet ferri recusabo ea nec. Cu persius maiorum corrumpit mei, i"
														 "n ridens perpetua mea, pri nobis tation inermis an. Vis alii autem cotidieque ut, ius harum salutatu"
														 "s ut. Mel eu purto veniam dissentias, malis doctus bonorum ne vel, mundi aperiam adversarium cu eum."
														 " Mei quando graeci te, dolore accusata mei te.")),
											"Multi-line text",
											1000, true) };
	}


	virtual void buildUserInterface(UI* ui_interface) {
		ui_interface->openVerticalBox("Key Detector");
		ui_interface->declare(0, "0", "");
		ui_interface->declare(0, "tooltip", "See Faust's filters.lib for documentation and references");
		ui_interface->openHorizontalBox("Beta plugin from Frymao");
		
		//ui_interface->declare(&fVbargraph119, "0", "");
		//ui_interface->declare(&fVbargraph119, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph119, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc4726a0", &fVbargraph119, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph118, "1", "");
		//ui_interface->declare(&fVbargraph118, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph118, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc45e730", &fVbargraph118, -50.0f, 10.0f);
		
		
		//ui_interface->declare(&fVbargraph108, "unit", "Num");
		//ui_interface->addVerticalBargraph("0xc2d81d0", &maxnum, 0.0f, 120.0f);
		ui_interface->declare(&max, "0", "");
		ui_interface->declare(&max, "tooltip", "Highest Level in dB");
		ui_interface->declare(&max, "unit", "dB");
		ui_interface->addVerticalBargraph("0xc2d81d0", &max, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph107, "12", "");

		
		
		
		
		
		
		//ui_interface->declare(&fVbargraph117, "2", "");
		//ui_interface->declare(&fVbargraph117, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph117, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc437980", &fVbargraph117, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph116, "3", "");
		//ui_interface->declare(&fVbargraph116, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph116, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc410bc0", &fVbargraph116, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph115, "4", "");
		//ui_interface->declare(&fVbargraph115, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph115, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc3e9e00", &fVbargraph115, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph114, "5", "");
		//ui_interface->declare(&fVbargraph114, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph114, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc3c3040", &fVbargraph114, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph113, "6", "");
		//ui_interface->declare(&fVbargraph113, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph113, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc39c290", &fVbargraph113, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph112, "7", "");
		//ui_interface->declare(&fVbargraph112, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph112, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc3754e0", &fVbargraph112, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph111, "8", "");
		//ui_interface->declare(&fVbargraph111, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph111, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc34e730", &fVbargraph111, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph110, "9", "");
		//ui_interface->declare(&fVbargraph110, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph110, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc327970", &fVbargraph110, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph19, "100", "");
		//ui_interface->declare(&fVbargraph19, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph19, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb4eea90", &fVbargraph19, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph18, "101", "");
		//ui_interface->declare(&fVbargraph18, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph18, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb4c7ce0", &fVbargraph18, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph17, "102", "");
		//ui_interface->declare(&fVbargraph17, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph17, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb4a0f20", &fVbargraph17, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph16, "103", "");
		//ui_interface->declare(&fVbargraph16, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph16, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb47a160", &fVbargraph16, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph15, "104", "");
		//ui_interface->declare(&fVbargraph15, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph15, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb4533b0", &fVbargraph15, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph14, "105", "");
		//ui_interface->declare(&fVbargraph14, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph14, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb42c600", &fVbargraph14, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph13, "106", "");
		//ui_interface->declare(&fVbargraph13, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph13, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb405850", &fVbargraph13, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph12, "107", "");
		//ui_interface->declare(&fVbargraph12, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph12, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb3dea90", &fVbargraph12, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph11, "108", "");
		//ui_interface->declare(&fVbargraph11, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph11, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb3b7cd0", &fVbargraph11, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph10, "109", "");
		//ui_interface->declare(&fVbargraph10, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph10, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb390f10", &fVbargraph10, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph109, "10", "");
		//ui_interface->declare(&fVbargraph109, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph109, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc300250", &fVbargraph109, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph9, "110", "");
		//ui_interface->declare(&fVbargraph9, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph9, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb36a160", &fVbargraph9, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph8, "111", "");
		//ui_interface->declare(&fVbargraph8, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph8, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb3433b0", &fVbargraph8, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph7, "112", "");
		//ui_interface->declare(&fVbargraph7, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph7, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb31c5f0", &fVbargraph7, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph6, "113", "");
		//ui_interface->declare(&fVbargraph6, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph6, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb2f5830", &fVbargraph6, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph5, "114", "");
		//ui_interface->declare(&fVbargraph5, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph5, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb2cea70", &fVbargraph5, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph4, "115", "");
		//ui_interface->declare(&fVbargraph4, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph4, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb2a7cc0", &fVbargraph4, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph3, "116", "");
		//ui_interface->declare(&fVbargraph3, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph3, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb280f10", &fVbargraph3, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph2, "117", "");
		//ui_interface->declare(&fVbargraph2, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph2, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb25a160", &fVbargraph2, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph1, "118", "");
		//ui_interface->declare(&fVbargraph1, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph1, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb2333a0", &fVbargraph1, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph0, "119", "");
		//ui_interface->declare(&fVbargraph0, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph0, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb20af40", &fVbargraph0, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph108, "11", "");
		//ui_interface->declare(&fVbargraph108, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph108, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc2d81d0", &fVbargraph108, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph107, "12", "");
		//ui_interface->declare(&fVbargraph107, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph107, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc2b0160", &fVbargraph107, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph106, "13", "");
		//ui_interface->declare(&fVbargraph106, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph106, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc2880f0", &fVbargraph106, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph105, "14", "");
		//ui_interface->declare(&fVbargraph105, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph105, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc260070", &fVbargraph105, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph104, "15", "");
		//ui_interface->declare(&fVbargraph104, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph104, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc237ff0", &fVbargraph104, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph103, "16", "");
		//ui_interface->declare(&fVbargraph103, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph103, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc20ff80", &fVbargraph103, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph102, "17", "");
		//ui_interface->declare(&fVbargraph102, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph102, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc1e7f10", &fVbargraph102, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph101, "18", "");
		//ui_interface->declare(&fVbargraph101, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph101, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc1bfe90", &fVbargraph101, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph100, "19", "");
		//ui_interface->declare(&fVbargraph100, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph100, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc197e10", &fVbargraph100, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph99, "20", "");
		//ui_interface->declare(&fVbargraph99, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph99, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc16fd90", &fVbargraph99, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph98, "21", "");
		//ui_interface->declare(&fVbargraph98, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph98, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc147d20", &fVbargraph98, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph97, "22", "");
		//ui_interface->declare(&fVbargraph97, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph97, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc11fcb0", &fVbargraph97, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph96, "23", "");
		//ui_interface->declare(&fVbargraph96, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph96, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc0f7c30", &fVbargraph96, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph95, "24", "");
		//ui_interface->declare(&fVbargraph95, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph95, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc0cfbb0", &fVbargraph95, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph94, "25", "");
		//ui_interface->declare(&fVbargraph94, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph94, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc0a7b40", &fVbargraph94, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph93, "26", "");
		//ui_interface->declare(&fVbargraph93, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph93, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc07fad0", &fVbargraph93, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph92, "27", "");
		//ui_interface->declare(&fVbargraph92, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph92, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc057a60", &fVbargraph92, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph91, "28", "");
		//ui_interface->declare(&fVbargraph91, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph91, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc02f9e0", &fVbargraph91, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph90, "29", "");
		//ui_interface->declare(&fVbargraph90, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph90, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xc007960", &fVbargraph90, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph89, "30", "");
		//ui_interface->declare(&fVbargraph89, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph89, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbfdf8f0", &fVbargraph89, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph88, "31", "");
		//ui_interface->declare(&fVbargraph88, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph88, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbfb7880", &fVbargraph88, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph87, "32", "");
		//ui_interface->declare(&fVbargraph87, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph87, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbf8f800", &fVbargraph87, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph86, "33", "");
		//ui_interface->declare(&fVbargraph86, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph86, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbf67780", &fVbargraph86, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph85, "34", "");
		//ui_interface->declare(&fVbargraph85, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph85, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbf3f700", &fVbargraph85, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph84, "35", "");
		//ui_interface->declare(&fVbargraph84, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph84, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbf17690", &fVbargraph84, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph83, "36", "");
		//ui_interface->declare(&fVbargraph83, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph83, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbeef620", &fVbargraph83, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph82, "37", "");
		//ui_interface->declare(&fVbargraph82, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph82, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbec75a0", &fVbargraph82, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph81, "38", "");
		//ui_interface->declare(&fVbargraph81, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph81, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbe9f520", &fVbargraph81, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph80, "39", "");
		//ui_interface->declare(&fVbargraph80, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph80, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbe774b0", &fVbargraph80, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph79, "40", "");
		//ui_interface->declare(&fVbargraph79, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph79, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbe4f440", &fVbargraph79, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph78, "41", "");
		//ui_interface->declare(&fVbargraph78, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph78, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbe273c0", &fVbargraph78, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph77, "42", "");
		//ui_interface->declare(&fVbargraph77, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph77, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbdff340", &fVbargraph77, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph76, "43", "");
		//ui_interface->declare(&fVbargraph76, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph76, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbdd72c0", &fVbargraph76, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph75, "44", "");
		//ui_interface->declare(&fVbargraph75, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph75, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbdaf250", &fVbargraph75, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph74, "45", "");
		//ui_interface->declare(&fVbargraph74, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph74, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbd871e0", &fVbargraph74, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph73, "46", "");
		//ui_interface->declare(&fVbargraph73, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph73, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbd5f160", &fVbargraph73, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph72, "47", "");
		//ui_interface->declare(&fVbargraph72, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph72, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbd370e0", &fVbargraph72, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph71, "48", "");
		//ui_interface->declare(&fVbargraph71, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph71, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbd0f070", &fVbargraph71, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph70, "49", "");
		//ui_interface->declare(&fVbargraph70, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph70, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbce7000", &fVbargraph70, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph69, "50", "");
		//ui_interface->declare(&fVbargraph69, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph69, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbcbef90", &fVbargraph69, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph68, "51", "");
		//ui_interface->declare(&fVbargraph68, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph68, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbc96f10", &fVbargraph68, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph67, "52", "");
		//ui_interface->declare(&fVbargraph67, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph67, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbc6ee90", &fVbargraph67, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph66, "53", "");
		//ui_interface->declare(&fVbargraph66, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph66, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbc46e20", &fVbargraph66, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph65, "54", "");
		//ui_interface->declare(&fVbargraph65, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph65, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbc1edb0", &fVbargraph65, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph64, "55", "");
		//ui_interface->declare(&fVbargraph64, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph64, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbbf6d30", &fVbargraph64, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph63, "56", "");
		//ui_interface->declare(&fVbargraph63, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph63, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbbcecb0", &fVbargraph63, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph62, "57", "");
		//ui_interface->declare(&fVbargraph62, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph62, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbba6c20", &fVbargraph62, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph61, "58", "");
		//ui_interface->declare(&fVbargraph61, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph61, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbb7ebb0", &fVbargraph61, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph60, "59", "");
		//ui_interface->declare(&fVbargraph60, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph60, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbb56b40", &fVbargraph60, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph59, "60", "");
		//ui_interface->declare(&fVbargraph59, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph59, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbb2eac0", &fVbargraph59, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph58, "61", "");
		//ui_interface->declare(&fVbargraph58, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph58, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbb06a40", &fVbargraph58, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph57, "62", "");
		//ui_interface->declare(&fVbargraph57, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph57, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbade9b0", &fVbargraph57, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph56, "63", "");
		//ui_interface->declare(&fVbargraph56, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph56, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xbab6940", &fVbargraph56, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph55, "64", "");
		//ui_interface->declare(&fVbargraph55, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph55, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xba8e8c0", &fVbargraph55, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph54, "65", "");
		//ui_interface->declare(&fVbargraph54, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph54, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xba66840", &fVbargraph54, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph53, "66", "");
		//ui_interface->declare(&fVbargraph53, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph53, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xba3e7c0", &fVbargraph53, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph52, "67", "");
		//ui_interface->declare(&fVbargraph52, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph52, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xba16750", &fVbargraph52, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph51, "68", "");
		//ui_interface->declare(&fVbargraph51, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph51, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb9ee6e0", &fVbargraph51, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph50, "69", "");
		//ui_interface->declare(&fVbargraph50, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph50, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb9c6660", &fVbargraph50, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph49, "70", "");
		//ui_interface->declare(&fVbargraph49, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph49, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb99e5e0", &fVbargraph49, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph48, "71", "");
		//ui_interface->declare(&fVbargraph48, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph48, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb976570", &fVbargraph48, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph47, "72", "");
		//ui_interface->declare(&fVbargraph47, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph47, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb94e500", &fVbargraph47, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph46, "73", "");
		//ui_interface->declare(&fVbargraph46, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph46, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb926480", &fVbargraph46, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph45, "74", "");
		//ui_interface->declare(&fVbargraph45, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph45, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb8fe400", &fVbargraph45, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph44, "75", "");
		//ui_interface->declare(&fVbargraph44, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph44, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb8d6370", &fVbargraph44, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph43, "76", "");
		//ui_interface->declare(&fVbargraph43, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph43, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb8ae300", &fVbargraph43, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph42, "77", "");
		//ui_interface->declare(&fVbargraph42, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph42, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb886290", &fVbargraph42, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph41, "78", "");
		//ui_interface->declare(&fVbargraph41, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph41, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb85e210", &fVbargraph41, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph40, "79", "");
		//ui_interface->declare(&fVbargraph40, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph40, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb836190", &fVbargraph40, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph39, "80", "");
		//ui_interface->declare(&fVbargraph39, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph39, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb80e120", &fVbargraph39, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph38, "81", "");
		//ui_interface->declare(&fVbargraph38, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph38, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb7e60b0", &fVbargraph38, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph37, "82", "");
		//ui_interface->declare(&fVbargraph37, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph37, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb7be040", &fVbargraph37, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph36, "83", "");
		//ui_interface->declare(&fVbargraph36, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph36, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb795fc0", &fVbargraph36, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph35, "84", "");
		//ui_interface->declare(&fVbargraph35, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph35, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb76df40", &fVbargraph35, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph34, "85", "");
		//ui_interface->declare(&fVbargraph34, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph34, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb745ed0", &fVbargraph34, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph33, "86", "");
		//ui_interface->declare(&fVbargraph33, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph33, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb71de60", &fVbargraph33, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph32, "87", "");
		//ui_interface->declare(&fVbargraph32, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph32, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb6f5de0", &fVbargraph32, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph31, "88", "");
		//ui_interface->declare(&fVbargraph31, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph31, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb6cdd60", &fVbargraph31, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph30, "89", "");
		//ui_interface->declare(&fVbargraph30, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph30, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb6a5ce0", &fVbargraph30, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph29, "90", "");
		//ui_interface->declare(&fVbargraph29, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph29, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb67dc70", &fVbargraph29, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph28, "91", "");
		//ui_interface->declare(&fVbargraph28, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph28, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb655c00", &fVbargraph28, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph27, "92", "");
		//ui_interface->declare(&fVbargraph27, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph27, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb62db80", &fVbargraph27, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph26, "93", "");
		//ui_interface->declare(&fVbargraph26, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph26, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb605b00", &fVbargraph26, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph25, "94", "");
		//ui_interface->declare(&fVbargraph25, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph25, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb5dda90", &fVbargraph25, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph24, "95", "");
		//ui_interface->declare(&fVbargraph24, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph24, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb5b5a20", &fVbargraph24, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph23, "96", "");
		//ui_interface->declare(&fVbargraph23, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph23, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb58d9b0", &fVbargraph23, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph22, "97", "");
		//ui_interface->declare(&fVbargraph22, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph22, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb565930", &fVbargraph22, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph21, "98", "");
		//ui_interface->declare(&fVbargraph21, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph21, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb53d8b0", &fVbargraph21, -50.0f, 10.0f);
		//ui_interface->declare(&fVbargraph20, "99", "");
		//ui_interface->declare(&fVbargraph20, "tooltip", "Spectral Band Level in dB");
		//ui_interface->declare(&fVbargraph20, "unit", "dB");
		//ui_interface->addVerticalBargraph("0xb515840", &fVbargraph20, -50.0f, 10.0f);
		ui_interface->closeBox();
		
		//ui_interface->declare(0, "1", "");
		//ui_interface->openHorizontalBox("SPECTRUM ANALYZER CONTROLS");
		//ui_interface->closeBox();


		ui_interface->declare(0, "2", "");
		ui_interface->openHorizontalBox("Volume");
		//ui_interface->declare(&fHslider1, "0", "");
		//ui_interface->declare(&fHslider1, "scale", "log");
		//ui_interface->declare(&fHslider1, "tooltip", "band-level averaging time in milliseconds");
		//ui_interface->declare(&fHslider1, "unit", "ms");
		//ui_interface->addHorizontalSlider("Level Averaging Time", &fHslider1, 100.0f, 100.0f, 1000.0f, 1.0f);
		//ui_interface->declare(&fHslider0, "1", "");
		//ui_interface->declare(&fHslider0, "tooltip", "Level offset in decibels");
		//ui_interface->declare(&fHslider0, "unit", "dB");
		//ui_interface->addHorizontalSlider("Level dB Offset", &fHslider0, -30.0f, -50.0f, -20.0f, 1.0f);
		ui_interface->closeBox();
		
		ui_interface->closeBox();
		
	}
	
	virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {
		FAUSTFLOAT* input0 = inputs[0];
		FAUSTFLOAT* output0 = outputs[0];
		//float fSlow0 = float(fHslider0);
		//float fSlow1 = std::exp((0.0f - (fConst1 / float(fHslider1))));


		float fSlow0 = b;
		float fSlow1 = std::exp((0.0f - (fConst1 / a)));

		


		float fSlow2 = (1.0f - fSlow1);
		for (int i = 0; (i < count); i = (i + 1)) {
			float fTemp0 = float(input0[i]);
			fRec3[0] = (fTemp0 - (fConst11 * ((fConst14 * fRec3[2]) + (fConst16 * fRec3[1]))));
			fRec2[0] = ((fConst11 * (((fConst13 * fRec3[0]) + (fConst17 * fRec3[1])) + (fConst13 * fRec3[2]))) - (fConst8 * ((fConst18 * fRec2[2]) + (fConst19 * fRec2[1]))));
			fRec1[0] = ((fConst8 * (((fConst10 * fRec2[0]) + (fConst20 * fRec2[1])) + (fConst10 * fRec2[2]))) - (fConst4 * ((fConst21 * fRec1[2]) + (fConst22 * fRec1[1]))));
			fRec0[0] = ((fSlow1 * fRec0[1]) + (fSlow2 * std::fabs((fConst4 * (((fConst7 * fRec1[0]) + (fConst23 * fRec1[1])) + (fConst7 * fRec1[2]))))));
			fVbargraph0 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec0[0])))));
			fRec10[0] = (fTemp0 - (fConst40 * ((fConst43 * fRec10[2]) + (fConst44 * fRec10[1]))));
			fRec9[0] = ((fConst40 * (((fConst42 * fRec10[0]) + (fConst45 * fRec10[1])) + (fConst42 * fRec10[2]))) - (fConst38 * ((fConst46 * fRec9[2]) + (fConst47 * fRec9[1]))));
			fRec8[0] = ((fConst38 * (((fConst39 * fRec9[0]) + (fConst48 * fRec9[1])) + (fConst39 * fRec9[2]))) - (fConst36 * ((fConst49 * fRec8[2]) + (fConst50 * fRec8[1]))));
			float fTemp1 = (fConst36 * (((fConst37 * fRec8[0]) + (fConst51 * fRec8[1])) + (fConst37 * fRec8[2])));
			fRec7[0] = (fTemp1 - (fConst33 * ((fConst52 * fRec7[2]) + (fConst54 * fRec7[1]))));
			fRec6[0] = ((fConst33 * (((fConst35 * fRec7[0]) + (fConst55 * fRec7[1])) + (fConst35 * fRec7[2]))) - (fConst30 * ((fConst56 * fRec6[2]) + (fConst57 * fRec6[1]))));
			fRec5[0] = ((fConst30 * (((fConst32 * fRec6[0]) + (fConst58 * fRec6[1])) + (fConst32 * fRec6[2]))) - (fConst26 * ((fConst59 * fRec5[2]) + (fConst60 * fRec5[1]))));
			fRec4[0] = ((fSlow1 * fRec4[1]) + (fSlow2 * std::fabs((fConst26 * (((fConst29 * fRec5[0]) + (fConst61 * fRec5[1])) + (fConst29 * fRec5[2]))))));
			fVbargraph1 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec4[0])))));
			fRec17[0] = (fTemp1 - (fConst78 * ((fConst81 * fRec17[2]) + (fConst82 * fRec17[1]))));
			fRec16[0] = ((fConst78 * (((fConst80 * fRec17[0]) + (fConst83 * fRec17[1])) + (fConst80 * fRec17[2]))) - (fConst76 * ((fConst84 * fRec16[2]) + (fConst85 * fRec16[1]))));
			fRec15[0] = ((fConst76 * (((fConst77 * fRec16[0]) + (fConst86 * fRec16[1])) + (fConst77 * fRec16[2]))) - (fConst74 * ((fConst87 * fRec15[2]) + (fConst88 * fRec15[1]))));
			float fTemp2 = (fConst74 * (((fConst75 * fRec15[0]) + (fConst89 * fRec15[1])) + (fConst75 * fRec15[2])));
			fRec14[0] = (fTemp2 - (fConst71 * ((fConst90 * fRec14[2]) + (fConst92 * fRec14[1]))));
			fRec13[0] = ((fConst71 * (((fConst73 * fRec14[0]) + (fConst93 * fRec14[1])) + (fConst73 * fRec14[2]))) - (fConst68 * ((fConst94 * fRec13[2]) + (fConst95 * fRec13[1]))));
			fRec12[0] = ((fConst68 * (((fConst70 * fRec13[0]) + (fConst96 * fRec13[1])) + (fConst70 * fRec13[2]))) - (fConst64 * ((fConst97 * fRec12[2]) + (fConst98 * fRec12[1]))));
			fRec11[0] = ((fSlow1 * fRec11[1]) + (fSlow2 * std::fabs((fConst64 * (((fConst67 * fRec12[0]) + (fConst99 * fRec12[1])) + (fConst67 * fRec12[2]))))));
			fVbargraph2 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec11[0])))));
			fRec24[0] = (fTemp2 - (fConst116 * ((fConst119 * fRec24[2]) + (fConst120 * fRec24[1]))));
			fRec23[0] = ((fConst116 * (((fConst118 * fRec24[0]) + (fConst121 * fRec24[1])) + (fConst118 * fRec24[2]))) - (fConst114 * ((fConst122 * fRec23[2]) + (fConst123 * fRec23[1]))));
			fRec22[0] = ((fConst114 * (((fConst115 * fRec23[0]) + (fConst124 * fRec23[1])) + (fConst115 * fRec23[2]))) - (fConst112 * ((fConst125 * fRec22[2]) + (fConst126 * fRec22[1]))));
			float fTemp3 = (fConst112 * (((fConst113 * fRec22[0]) + (fConst127 * fRec22[1])) + (fConst113 * fRec22[2])));
			fRec21[0] = (fTemp3 - (fConst109 * ((fConst128 * fRec21[2]) + (fConst130 * fRec21[1]))));
			fRec20[0] = ((fConst109 * (((fConst111 * fRec21[0]) + (fConst131 * fRec21[1])) + (fConst111 * fRec21[2]))) - (fConst106 * ((fConst132 * fRec20[2]) + (fConst133 * fRec20[1]))));
			fRec19[0] = ((fConst106 * (((fConst108 * fRec20[0]) + (fConst134 * fRec20[1])) + (fConst108 * fRec20[2]))) - (fConst102 * ((fConst135 * fRec19[2]) + (fConst136 * fRec19[1]))));
			fRec18[0] = ((fSlow1 * fRec18[1]) + (fSlow2 * std::fabs((fConst102 * (((fConst105 * fRec19[0]) + (fConst137 * fRec19[1])) + (fConst105 * fRec19[2]))))));
			fVbargraph3 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec18[0])))));
			fRec31[0] = (fTemp3 - (fConst154 * ((fConst157 * fRec31[2]) + (fConst158 * fRec31[1]))));
			fRec30[0] = ((fConst154 * (((fConst156 * fRec31[0]) + (fConst159 * fRec31[1])) + (fConst156 * fRec31[2]))) - (fConst152 * ((fConst160 * fRec30[2]) + (fConst161 * fRec30[1]))));
			fRec29[0] = ((fConst152 * (((fConst153 * fRec30[0]) + (fConst162 * fRec30[1])) + (fConst153 * fRec30[2]))) - (fConst150 * ((fConst163 * fRec29[2]) + (fConst164 * fRec29[1]))));
			float fTemp4 = (fConst150 * (((fConst151 * fRec29[0]) + (fConst165 * fRec29[1])) + (fConst151 * fRec29[2])));
			fRec28[0] = (fTemp4 - (fConst147 * ((fConst166 * fRec28[2]) + (fConst168 * fRec28[1]))));
			fRec27[0] = ((fConst147 * (((fConst149 * fRec28[0]) + (fConst169 * fRec28[1])) + (fConst149 * fRec28[2]))) - (fConst144 * ((fConst170 * fRec27[2]) + (fConst171 * fRec27[1]))));
			fRec26[0] = ((fConst144 * (((fConst146 * fRec27[0]) + (fConst172 * fRec27[1])) + (fConst146 * fRec27[2]))) - (fConst140 * ((fConst173 * fRec26[2]) + (fConst174 * fRec26[1]))));
			fRec25[0] = ((fSlow1 * fRec25[1]) + (fSlow2 * std::fabs((fConst140 * (((fConst143 * fRec26[0]) + (fConst175 * fRec26[1])) + (fConst143 * fRec26[2]))))));
			fVbargraph4 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec25[0])))));
			fRec38[0] = (fTemp4 - (fConst192 * ((fConst195 * fRec38[2]) + (fConst196 * fRec38[1]))));
			fRec37[0] = ((fConst192 * (((fConst194 * fRec38[0]) + (fConst197 * fRec38[1])) + (fConst194 * fRec38[2]))) - (fConst190 * ((fConst198 * fRec37[2]) + (fConst199 * fRec37[1]))));
			fRec36[0] = ((fConst190 * (((fConst191 * fRec37[0]) + (fConst200 * fRec37[1])) + (fConst191 * fRec37[2]))) - (fConst188 * ((fConst201 * fRec36[2]) + (fConst202 * fRec36[1]))));
			float fTemp5 = (fConst188 * (((fConst189 * fRec36[0]) + (fConst203 * fRec36[1])) + (fConst189 * fRec36[2])));
			fRec35[0] = (fTemp5 - (fConst185 * ((fConst204 * fRec35[2]) + (fConst206 * fRec35[1]))));
			fRec34[0] = ((fConst185 * (((fConst187 * fRec35[0]) + (fConst207 * fRec35[1])) + (fConst187 * fRec35[2]))) - (fConst182 * ((fConst208 * fRec34[2]) + (fConst209 * fRec34[1]))));
			fRec33[0] = ((fConst182 * (((fConst184 * fRec34[0]) + (fConst210 * fRec34[1])) + (fConst184 * fRec34[2]))) - (fConst178 * ((fConst211 * fRec33[2]) + (fConst212 * fRec33[1]))));
			fRec32[0] = ((fSlow1 * fRec32[1]) + (fSlow2 * std::fabs((fConst178 * (((fConst181 * fRec33[0]) + (fConst213 * fRec33[1])) + (fConst181 * fRec33[2]))))));
			fVbargraph5 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec32[0])))));
			fRec45[0] = (fTemp5 - (fConst230 * ((fConst233 * fRec45[2]) + (fConst234 * fRec45[1]))));
			fRec44[0] = ((fConst230 * (((fConst232 * fRec45[0]) + (fConst235 * fRec45[1])) + (fConst232 * fRec45[2]))) - (fConst228 * ((fConst236 * fRec44[2]) + (fConst237 * fRec44[1]))));
			fRec43[0] = ((fConst228 * (((fConst229 * fRec44[0]) + (fConst238 * fRec44[1])) + (fConst229 * fRec44[2]))) - (fConst226 * ((fConst239 * fRec43[2]) + (fConst240 * fRec43[1]))));
			float fTemp6 = (fConst226 * (((fConst227 * fRec43[0]) + (fConst241 * fRec43[1])) + (fConst227 * fRec43[2])));
			fRec42[0] = (fTemp6 - (fConst223 * ((fConst242 * fRec42[2]) + (fConst244 * fRec42[1]))));
			fRec41[0] = ((fConst223 * (((fConst225 * fRec42[0]) + (fConst245 * fRec42[1])) + (fConst225 * fRec42[2]))) - (fConst220 * ((fConst246 * fRec41[2]) + (fConst247 * fRec41[1]))));
			fRec40[0] = ((fConst220 * (((fConst222 * fRec41[0]) + (fConst248 * fRec41[1])) + (fConst222 * fRec41[2]))) - (fConst216 * ((fConst249 * fRec40[2]) + (fConst250 * fRec40[1]))));
			fRec39[0] = ((fSlow1 * fRec39[1]) + (fSlow2 * std::fabs((fConst216 * (((fConst219 * fRec40[0]) + (fConst251 * fRec40[1])) + (fConst219 * fRec40[2]))))));
			fVbargraph6 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec39[0])))));
			fRec52[0] = (fTemp6 - (fConst268 * ((fConst271 * fRec52[2]) + (fConst272 * fRec52[1]))));
			fRec51[0] = ((fConst268 * (((fConst270 * fRec52[0]) + (fConst273 * fRec52[1])) + (fConst270 * fRec52[2]))) - (fConst266 * ((fConst274 * fRec51[2]) + (fConst275 * fRec51[1]))));
			fRec50[0] = ((fConst266 * (((fConst267 * fRec51[0]) + (fConst276 * fRec51[1])) + (fConst267 * fRec51[2]))) - (fConst264 * ((fConst277 * fRec50[2]) + (fConst278 * fRec50[1]))));
			float fTemp7 = (fConst264 * (((fConst265 * fRec50[0]) + (fConst279 * fRec50[1])) + (fConst265 * fRec50[2])));
			fRec49[0] = (fTemp7 - (fConst261 * ((fConst280 * fRec49[2]) + (fConst282 * fRec49[1]))));
			fRec48[0] = ((fConst261 * (((fConst263 * fRec49[0]) + (fConst283 * fRec49[1])) + (fConst263 * fRec49[2]))) - (fConst258 * ((fConst284 * fRec48[2]) + (fConst285 * fRec48[1]))));
			fRec47[0] = ((fConst258 * (((fConst260 * fRec48[0]) + (fConst286 * fRec48[1])) + (fConst260 * fRec48[2]))) - (fConst254 * ((fConst287 * fRec47[2]) + (fConst288 * fRec47[1]))));
			fRec46[0] = ((fSlow1 * fRec46[1]) + (fSlow2 * std::fabs((fConst254 * (((fConst257 * fRec47[0]) + (fConst289 * fRec47[1])) + (fConst257 * fRec47[2]))))));
			fVbargraph7 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec46[0])))));
			fRec59[0] = (fTemp7 - (fConst306 * ((fConst309 * fRec59[2]) + (fConst310 * fRec59[1]))));
			fRec58[0] = ((fConst306 * (((fConst308 * fRec59[0]) + (fConst311 * fRec59[1])) + (fConst308 * fRec59[2]))) - (fConst304 * ((fConst312 * fRec58[2]) + (fConst313 * fRec58[1]))));
			fRec57[0] = ((fConst304 * (((fConst305 * fRec58[0]) + (fConst314 * fRec58[1])) + (fConst305 * fRec58[2]))) - (fConst302 * ((fConst315 * fRec57[2]) + (fConst316 * fRec57[1]))));
			float fTemp8 = (fConst302 * (((fConst303 * fRec57[0]) + (fConst317 * fRec57[1])) + (fConst303 * fRec57[2])));
			fRec56[0] = (fTemp8 - (fConst299 * ((fConst318 * fRec56[2]) + (fConst320 * fRec56[1]))));
			fRec55[0] = ((fConst299 * (((fConst301 * fRec56[0]) + (fConst321 * fRec56[1])) + (fConst301 * fRec56[2]))) - (fConst296 * ((fConst322 * fRec55[2]) + (fConst323 * fRec55[1]))));
			fRec54[0] = ((fConst296 * (((fConst298 * fRec55[0]) + (fConst324 * fRec55[1])) + (fConst298 * fRec55[2]))) - (fConst292 * ((fConst325 * fRec54[2]) + (fConst326 * fRec54[1]))));
			fRec53[0] = ((fSlow1 * fRec53[1]) + (fSlow2 * std::fabs((fConst292 * (((fConst295 * fRec54[0]) + (fConst327 * fRec54[1])) + (fConst295 * fRec54[2]))))));
			fVbargraph8 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec53[0])))));
			fRec66[0] = (fTemp8 - (fConst344 * ((fConst347 * fRec66[2]) + (fConst348 * fRec66[1]))));
			fRec65[0] = ((fConst344 * (((fConst346 * fRec66[0]) + (fConst349 * fRec66[1])) + (fConst346 * fRec66[2]))) - (fConst342 * ((fConst350 * fRec65[2]) + (fConst351 * fRec65[1]))));
			fRec64[0] = ((fConst342 * (((fConst343 * fRec65[0]) + (fConst352 * fRec65[1])) + (fConst343 * fRec65[2]))) - (fConst340 * ((fConst353 * fRec64[2]) + (fConst354 * fRec64[1]))));
			float fTemp9 = (fConst340 * (((fConst341 * fRec64[0]) + (fConst355 * fRec64[1])) + (fConst341 * fRec64[2])));
			fRec63[0] = (fTemp9 - (fConst337 * ((fConst356 * fRec63[2]) + (fConst358 * fRec63[1]))));
			fRec62[0] = ((fConst337 * (((fConst339 * fRec63[0]) + (fConst359 * fRec63[1])) + (fConst339 * fRec63[2]))) - (fConst334 * ((fConst360 * fRec62[2]) + (fConst361 * fRec62[1]))));
			fRec61[0] = ((fConst334 * (((fConst336 * fRec62[0]) + (fConst362 * fRec62[1])) + (fConst336 * fRec62[2]))) - (fConst330 * ((fConst363 * fRec61[2]) + (fConst364 * fRec61[1]))));
			fRec60[0] = ((fSlow1 * fRec60[1]) + (fSlow2 * std::fabs((fConst330 * (((fConst333 * fRec61[0]) + (fConst365 * fRec61[1])) + (fConst333 * fRec61[2]))))));
			fVbargraph9 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec60[0])))));
			fRec73[0] = (fTemp9 - (fConst382 * ((fConst385 * fRec73[2]) + (fConst386 * fRec73[1]))));
			fRec72[0] = ((fConst382 * (((fConst384 * fRec73[0]) + (fConst387 * fRec73[1])) + (fConst384 * fRec73[2]))) - (fConst380 * ((fConst388 * fRec72[2]) + (fConst389 * fRec72[1]))));
			fRec71[0] = ((fConst380 * (((fConst381 * fRec72[0]) + (fConst390 * fRec72[1])) + (fConst381 * fRec72[2]))) - (fConst378 * ((fConst391 * fRec71[2]) + (fConst392 * fRec71[1]))));
			float fTemp10 = (fConst378 * (((fConst379 * fRec71[0]) + (fConst393 * fRec71[1])) + (fConst379 * fRec71[2])));
			fRec70[0] = (fTemp10 - (fConst375 * ((fConst394 * fRec70[2]) + (fConst396 * fRec70[1]))));
			fRec69[0] = ((fConst375 * (((fConst377 * fRec70[0]) + (fConst397 * fRec70[1])) + (fConst377 * fRec70[2]))) - (fConst372 * ((fConst398 * fRec69[2]) + (fConst399 * fRec69[1]))));
			fRec68[0] = ((fConst372 * (((fConst374 * fRec69[0]) + (fConst400 * fRec69[1])) + (fConst374 * fRec69[2]))) - (fConst368 * ((fConst401 * fRec68[2]) + (fConst402 * fRec68[1]))));
			fRec67[0] = ((fSlow1 * fRec67[1]) + (fSlow2 * std::fabs((fConst368 * (((fConst371 * fRec68[0]) + (fConst403 * fRec68[1])) + (fConst371 * fRec68[2]))))));
			fVbargraph10 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec67[0])))));
			fRec80[0] = (fTemp10 - (fConst420 * ((fConst423 * fRec80[2]) + (fConst424 * fRec80[1]))));
			fRec79[0] = ((fConst420 * (((fConst422 * fRec80[0]) + (fConst425 * fRec80[1])) + (fConst422 * fRec80[2]))) - (fConst418 * ((fConst426 * fRec79[2]) + (fConst427 * fRec79[1]))));
			fRec78[0] = ((fConst418 * (((fConst419 * fRec79[0]) + (fConst428 * fRec79[1])) + (fConst419 * fRec79[2]))) - (fConst416 * ((fConst429 * fRec78[2]) + (fConst430 * fRec78[1]))));
			float fTemp11 = (fConst416 * (((fConst417 * fRec78[0]) + (fConst431 * fRec78[1])) + (fConst417 * fRec78[2])));
			fRec77[0] = (fTemp11 - (fConst413 * ((fConst432 * fRec77[2]) + (fConst434 * fRec77[1]))));
			fRec76[0] = ((fConst413 * (((fConst415 * fRec77[0]) + (fConst435 * fRec77[1])) + (fConst415 * fRec77[2]))) - (fConst410 * ((fConst436 * fRec76[2]) + (fConst437 * fRec76[1]))));
			fRec75[0] = ((fConst410 * (((fConst412 * fRec76[0]) + (fConst438 * fRec76[1])) + (fConst412 * fRec76[2]))) - (fConst406 * ((fConst439 * fRec75[2]) + (fConst440 * fRec75[1]))));
			fRec74[0] = ((fSlow1 * fRec74[1]) + (fSlow2 * std::fabs((fConst406 * (((fConst409 * fRec75[0]) + (fConst441 * fRec75[1])) + (fConst409 * fRec75[2]))))));
			fVbargraph11 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec74[0])))));
			fRec87[0] = (fTemp11 - (fConst458 * ((fConst461 * fRec87[2]) + (fConst462 * fRec87[1]))));
			fRec86[0] = ((fConst458 * (((fConst460 * fRec87[0]) + (fConst463 * fRec87[1])) + (fConst460 * fRec87[2]))) - (fConst456 * ((fConst464 * fRec86[2]) + (fConst465 * fRec86[1]))));
			fRec85[0] = ((fConst456 * (((fConst457 * fRec86[0]) + (fConst466 * fRec86[1])) + (fConst457 * fRec86[2]))) - (fConst454 * ((fConst467 * fRec85[2]) + (fConst468 * fRec85[1]))));
			float fTemp12 = (fConst454 * (((fConst455 * fRec85[0]) + (fConst469 * fRec85[1])) + (fConst455 * fRec85[2])));
			fRec84[0] = (fTemp12 - (fConst451 * ((fConst470 * fRec84[2]) + (fConst472 * fRec84[1]))));
			fRec83[0] = ((fConst451 * (((fConst453 * fRec84[0]) + (fConst473 * fRec84[1])) + (fConst453 * fRec84[2]))) - (fConst448 * ((fConst474 * fRec83[2]) + (fConst475 * fRec83[1]))));
			fRec82[0] = ((fConst448 * (((fConst450 * fRec83[0]) + (fConst476 * fRec83[1])) + (fConst450 * fRec83[2]))) - (fConst444 * ((fConst477 * fRec82[2]) + (fConst478 * fRec82[1]))));
			fRec81[0] = ((fSlow1 * fRec81[1]) + (fSlow2 * std::fabs((fConst444 * (((fConst447 * fRec82[0]) + (fConst479 * fRec82[1])) + (fConst447 * fRec82[2]))))));
			fVbargraph12 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec81[0])))));
			fRec94[0] = (fTemp12 - (fConst496 * ((fConst499 * fRec94[2]) + (fConst500 * fRec94[1]))));
			fRec93[0] = ((fConst496 * (((fConst498 * fRec94[0]) + (fConst501 * fRec94[1])) + (fConst498 * fRec94[2]))) - (fConst494 * ((fConst502 * fRec93[2]) + (fConst503 * fRec93[1]))));
			fRec92[0] = ((fConst494 * (((fConst495 * fRec93[0]) + (fConst504 * fRec93[1])) + (fConst495 * fRec93[2]))) - (fConst492 * ((fConst505 * fRec92[2]) + (fConst506 * fRec92[1]))));
			float fTemp13 = (fConst492 * (((fConst493 * fRec92[0]) + (fConst507 * fRec92[1])) + (fConst493 * fRec92[2])));
			fRec91[0] = (fTemp13 - (fConst489 * ((fConst508 * fRec91[2]) + (fConst510 * fRec91[1]))));
			fRec90[0] = ((fConst489 * (((fConst491 * fRec91[0]) + (fConst511 * fRec91[1])) + (fConst491 * fRec91[2]))) - (fConst486 * ((fConst512 * fRec90[2]) + (fConst513 * fRec90[1]))));
			fRec89[0] = ((fConst486 * (((fConst488 * fRec90[0]) + (fConst514 * fRec90[1])) + (fConst488 * fRec90[2]))) - (fConst482 * ((fConst515 * fRec89[2]) + (fConst516 * fRec89[1]))));
			fRec88[0] = ((fSlow1 * fRec88[1]) + (fSlow2 * std::fabs((fConst482 * (((fConst485 * fRec89[0]) + (fConst517 * fRec89[1])) + (fConst485 * fRec89[2]))))));
			fVbargraph13 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec88[0])))));
			fRec101[0] = (fTemp13 - (fConst534 * ((fConst537 * fRec101[2]) + (fConst538 * fRec101[1]))));
			fRec100[0] = ((fConst534 * (((fConst536 * fRec101[0]) + (fConst539 * fRec101[1])) + (fConst536 * fRec101[2]))) - (fConst532 * ((fConst540 * fRec100[2]) + (fConst541 * fRec100[1]))));
			fRec99[0] = ((fConst532 * (((fConst533 * fRec100[0]) + (fConst542 * fRec100[1])) + (fConst533 * fRec100[2]))) - (fConst530 * ((fConst543 * fRec99[2]) + (fConst544 * fRec99[1]))));
			float fTemp14 = (fConst530 * (((fConst531 * fRec99[0]) + (fConst545 * fRec99[1])) + (fConst531 * fRec99[2])));
			fRec98[0] = (fTemp14 - (fConst527 * ((fConst546 * fRec98[2]) + (fConst548 * fRec98[1]))));
			fRec97[0] = ((fConst527 * (((fConst529 * fRec98[0]) + (fConst549 * fRec98[1])) + (fConst529 * fRec98[2]))) - (fConst524 * ((fConst550 * fRec97[2]) + (fConst551 * fRec97[1]))));
			fRec96[0] = ((fConst524 * (((fConst526 * fRec97[0]) + (fConst552 * fRec97[1])) + (fConst526 * fRec97[2]))) - (fConst520 * ((fConst553 * fRec96[2]) + (fConst554 * fRec96[1]))));
			fRec95[0] = ((fSlow1 * fRec95[1]) + (fSlow2 * std::fabs((fConst520 * (((fConst523 * fRec96[0]) + (fConst555 * fRec96[1])) + (fConst523 * fRec96[2]))))));
			fVbargraph14 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec95[0])))));
			fRec108[0] = (fTemp14 - (fConst572 * ((fConst575 * fRec108[2]) + (fConst576 * fRec108[1]))));
			fRec107[0] = ((fConst572 * (((fConst574 * fRec108[0]) + (fConst577 * fRec108[1])) + (fConst574 * fRec108[2]))) - (fConst570 * ((fConst578 * fRec107[2]) + (fConst579 * fRec107[1]))));
			fRec106[0] = ((fConst570 * (((fConst571 * fRec107[0]) + (fConst580 * fRec107[1])) + (fConst571 * fRec107[2]))) - (fConst568 * ((fConst581 * fRec106[2]) + (fConst582 * fRec106[1]))));
			float fTemp15 = (fConst568 * (((fConst569 * fRec106[0]) + (fConst583 * fRec106[1])) + (fConst569 * fRec106[2])));
			fRec105[0] = (fTemp15 - (fConst565 * ((fConst584 * fRec105[2]) + (fConst586 * fRec105[1]))));
			fRec104[0] = ((fConst565 * (((fConst567 * fRec105[0]) + (fConst587 * fRec105[1])) + (fConst567 * fRec105[2]))) - (fConst562 * ((fConst588 * fRec104[2]) + (fConst589 * fRec104[1]))));
			fRec103[0] = ((fConst562 * (((fConst564 * fRec104[0]) + (fConst590 * fRec104[1])) + (fConst564 * fRec104[2]))) - (fConst558 * ((fConst591 * fRec103[2]) + (fConst592 * fRec103[1]))));
			fRec102[0] = ((fSlow1 * fRec102[1]) + (fSlow2 * std::fabs((fConst558 * (((fConst561 * fRec103[0]) + (fConst593 * fRec103[1])) + (fConst561 * fRec103[2]))))));
			fVbargraph15 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec102[0])))));
			fRec115[0] = (fTemp15 - (fConst610 * ((fConst613 * fRec115[2]) + (fConst614 * fRec115[1]))));
			fRec114[0] = ((fConst610 * (((fConst612 * fRec115[0]) + (fConst615 * fRec115[1])) + (fConst612 * fRec115[2]))) - (fConst608 * ((fConst616 * fRec114[2]) + (fConst617 * fRec114[1]))));
			fRec113[0] = ((fConst608 * (((fConst609 * fRec114[0]) + (fConst618 * fRec114[1])) + (fConst609 * fRec114[2]))) - (fConst606 * ((fConst619 * fRec113[2]) + (fConst620 * fRec113[1]))));
			float fTemp16 = (fConst606 * (((fConst607 * fRec113[0]) + (fConst621 * fRec113[1])) + (fConst607 * fRec113[2])));
			fRec112[0] = (fTemp16 - (fConst603 * ((fConst622 * fRec112[2]) + (fConst624 * fRec112[1]))));
			fRec111[0] = ((fConst603 * (((fConst605 * fRec112[0]) + (fConst625 * fRec112[1])) + (fConst605 * fRec112[2]))) - (fConst600 * ((fConst626 * fRec111[2]) + (fConst627 * fRec111[1]))));
			fRec110[0] = ((fConst600 * (((fConst602 * fRec111[0]) + (fConst628 * fRec111[1])) + (fConst602 * fRec111[2]))) - (fConst596 * ((fConst629 * fRec110[2]) + (fConst630 * fRec110[1]))));
			fRec109[0] = ((fSlow1 * fRec109[1]) + (fSlow2 * std::fabs((fConst596 * (((fConst599 * fRec110[0]) + (fConst631 * fRec110[1])) + (fConst599 * fRec110[2]))))));
			fVbargraph16 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec109[0])))));
			fRec122[0] = (fTemp16 - (fConst648 * ((fConst651 * fRec122[2]) + (fConst652 * fRec122[1]))));
			fRec121[0] = ((fConst648 * (((fConst650 * fRec122[0]) + (fConst653 * fRec122[1])) + (fConst650 * fRec122[2]))) - (fConst646 * ((fConst654 * fRec121[2]) + (fConst655 * fRec121[1]))));
			fRec120[0] = ((fConst646 * (((fConst647 * fRec121[0]) + (fConst656 * fRec121[1])) + (fConst647 * fRec121[2]))) - (fConst644 * ((fConst657 * fRec120[2]) + (fConst658 * fRec120[1]))));
			float fTemp17 = (fConst644 * (((fConst645 * fRec120[0]) + (fConst659 * fRec120[1])) + (fConst645 * fRec120[2])));
			fRec119[0] = (fTemp17 - (fConst641 * ((fConst660 * fRec119[2]) + (fConst662 * fRec119[1]))));
			fRec118[0] = ((fConst641 * (((fConst643 * fRec119[0]) + (fConst663 * fRec119[1])) + (fConst643 * fRec119[2]))) - (fConst638 * ((fConst664 * fRec118[2]) + (fConst665 * fRec118[1]))));
			fRec117[0] = ((fConst638 * (((fConst640 * fRec118[0]) + (fConst666 * fRec118[1])) + (fConst640 * fRec118[2]))) - (fConst634 * ((fConst667 * fRec117[2]) + (fConst668 * fRec117[1]))));
			fRec116[0] = ((fSlow1 * fRec116[1]) + (fSlow2 * std::fabs((fConst634 * (((fConst637 * fRec117[0]) + (fConst669 * fRec117[1])) + (fConst637 * fRec117[2]))))));
			fVbargraph17 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec116[0])))));
			fRec129[0] = (fTemp17 - (fConst686 * ((fConst689 * fRec129[2]) + (fConst690 * fRec129[1]))));
			fRec128[0] = ((fConst686 * (((fConst688 * fRec129[0]) + (fConst691 * fRec129[1])) + (fConst688 * fRec129[2]))) - (fConst684 * ((fConst692 * fRec128[2]) + (fConst693 * fRec128[1]))));
			fRec127[0] = ((fConst684 * (((fConst685 * fRec128[0]) + (fConst694 * fRec128[1])) + (fConst685 * fRec128[2]))) - (fConst682 * ((fConst695 * fRec127[2]) + (fConst696 * fRec127[1]))));
			float fTemp18 = (fConst682 * (((fConst683 * fRec127[0]) + (fConst697 * fRec127[1])) + (fConst683 * fRec127[2])));
			fRec126[0] = (fTemp18 - (fConst679 * ((fConst698 * fRec126[2]) + (fConst700 * fRec126[1]))));
			fRec125[0] = ((fConst679 * (((fConst681 * fRec126[0]) + (fConst701 * fRec126[1])) + (fConst681 * fRec126[2]))) - (fConst676 * ((fConst702 * fRec125[2]) + (fConst703 * fRec125[1]))));
			fRec124[0] = ((fConst676 * (((fConst678 * fRec125[0]) + (fConst704 * fRec125[1])) + (fConst678 * fRec125[2]))) - (fConst672 * ((fConst705 * fRec124[2]) + (fConst706 * fRec124[1]))));
			fRec123[0] = ((fSlow1 * fRec123[1]) + (fSlow2 * std::fabs((fConst672 * (((fConst675 * fRec124[0]) + (fConst707 * fRec124[1])) + (fConst675 * fRec124[2]))))));
			fVbargraph18 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec123[0])))));
			fRec136[0] = (fTemp18 - (fConst724 * ((fConst727 * fRec136[2]) + (fConst728 * fRec136[1]))));
			fRec135[0] = ((fConst724 * (((fConst726 * fRec136[0]) + (fConst729 * fRec136[1])) + (fConst726 * fRec136[2]))) - (fConst722 * ((fConst730 * fRec135[2]) + (fConst731 * fRec135[1]))));
			fRec134[0] = ((fConst722 * (((fConst723 * fRec135[0]) + (fConst732 * fRec135[1])) + (fConst723 * fRec135[2]))) - (fConst720 * ((fConst733 * fRec134[2]) + (fConst734 * fRec134[1]))));
			float fTemp19 = (fConst720 * (((fConst721 * fRec134[0]) + (fConst735 * fRec134[1])) + (fConst721 * fRec134[2])));
			fRec133[0] = (fTemp19 - (fConst717 * ((fConst736 * fRec133[2]) + (fConst738 * fRec133[1]))));
			fRec132[0] = ((fConst717 * (((fConst719 * fRec133[0]) + (fConst739 * fRec133[1])) + (fConst719 * fRec133[2]))) - (fConst714 * ((fConst740 * fRec132[2]) + (fConst741 * fRec132[1]))));
			fRec131[0] = ((fConst714 * (((fConst716 * fRec132[0]) + (fConst742 * fRec132[1])) + (fConst716 * fRec132[2]))) - (fConst710 * ((fConst743 * fRec131[2]) + (fConst744 * fRec131[1]))));
			fRec130[0] = ((fSlow1 * fRec130[1]) + (fSlow2 * std::fabs((fConst710 * (((fConst713 * fRec131[0]) + (fConst745 * fRec131[1])) + (fConst713 * fRec131[2]))))));
			fVbargraph19 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec130[0])))));
			fRec143[0] = (fTemp19 - (fConst762 * ((fConst765 * fRec143[2]) + (fConst766 * fRec143[1]))));
			fRec142[0] = ((fConst762 * (((fConst764 * fRec143[0]) + (fConst767 * fRec143[1])) + (fConst764 * fRec143[2]))) - (fConst760 * ((fConst768 * fRec142[2]) + (fConst769 * fRec142[1]))));
			fRec141[0] = ((fConst760 * (((fConst761 * fRec142[0]) + (fConst770 * fRec142[1])) + (fConst761 * fRec142[2]))) - (fConst758 * ((fConst771 * fRec141[2]) + (fConst772 * fRec141[1]))));
			float fTemp20 = (fConst758 * (((fConst759 * fRec141[0]) + (fConst773 * fRec141[1])) + (fConst759 * fRec141[2])));
			fRec140[0] = (fTemp20 - (fConst755 * ((fConst774 * fRec140[2]) + (fConst776 * fRec140[1]))));
			fRec139[0] = ((fConst755 * (((fConst757 * fRec140[0]) + (fConst777 * fRec140[1])) + (fConst757 * fRec140[2]))) - (fConst752 * ((fConst778 * fRec139[2]) + (fConst779 * fRec139[1]))));
			fRec138[0] = ((fConst752 * (((fConst754 * fRec139[0]) + (fConst780 * fRec139[1])) + (fConst754 * fRec139[2]))) - (fConst748 * ((fConst781 * fRec138[2]) + (fConst782 * fRec138[1]))));
			fRec137[0] = ((fSlow1 * fRec137[1]) + (fSlow2 * std::fabs((fConst748 * (((fConst751 * fRec138[0]) + (fConst783 * fRec138[1])) + (fConst751 * fRec138[2]))))));
			fVbargraph20 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec137[0])))));
			fRec150[0] = (fTemp20 - (fConst800 * ((fConst803 * fRec150[2]) + (fConst804 * fRec150[1]))));
			fRec149[0] = ((fConst800 * (((fConst802 * fRec150[0]) + (fConst805 * fRec150[1])) + (fConst802 * fRec150[2]))) - (fConst798 * ((fConst806 * fRec149[2]) + (fConst807 * fRec149[1]))));
			fRec148[0] = ((fConst798 * (((fConst799 * fRec149[0]) + (fConst808 * fRec149[1])) + (fConst799 * fRec149[2]))) - (fConst796 * ((fConst809 * fRec148[2]) + (fConst810 * fRec148[1]))));
			float fTemp21 = (fConst796 * (((fConst797 * fRec148[0]) + (fConst811 * fRec148[1])) + (fConst797 * fRec148[2])));
			fRec147[0] = (fTemp21 - (fConst793 * ((fConst812 * fRec147[2]) + (fConst814 * fRec147[1]))));
			fRec146[0] = ((fConst793 * (((fConst795 * fRec147[0]) + (fConst815 * fRec147[1])) + (fConst795 * fRec147[2]))) - (fConst790 * ((fConst816 * fRec146[2]) + (fConst817 * fRec146[1]))));
			fRec145[0] = ((fConst790 * (((fConst792 * fRec146[0]) + (fConst818 * fRec146[1])) + (fConst792 * fRec146[2]))) - (fConst786 * ((fConst819 * fRec145[2]) + (fConst820 * fRec145[1]))));
			fRec144[0] = ((fSlow1 * fRec144[1]) + (fSlow2 * std::fabs((fConst786 * (((fConst789 * fRec145[0]) + (fConst821 * fRec145[1])) + (fConst789 * fRec145[2]))))));
			fVbargraph21 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec144[0])))));
			fRec157[0] = (fTemp21 - (fConst838 * ((fConst841 * fRec157[2]) + (fConst842 * fRec157[1]))));
			fRec156[0] = ((fConst838 * (((fConst840 * fRec157[0]) + (fConst843 * fRec157[1])) + (fConst840 * fRec157[2]))) - (fConst836 * ((fConst844 * fRec156[2]) + (fConst845 * fRec156[1]))));
			fRec155[0] = ((fConst836 * (((fConst837 * fRec156[0]) + (fConst846 * fRec156[1])) + (fConst837 * fRec156[2]))) - (fConst834 * ((fConst847 * fRec155[2]) + (fConst848 * fRec155[1]))));
			float fTemp22 = (fConst834 * (((fConst835 * fRec155[0]) + (fConst849 * fRec155[1])) + (fConst835 * fRec155[2])));
			fRec154[0] = (fTemp22 - (fConst831 * ((fConst850 * fRec154[2]) + (fConst852 * fRec154[1]))));
			fRec153[0] = ((fConst831 * (((fConst833 * fRec154[0]) + (fConst853 * fRec154[1])) + (fConst833 * fRec154[2]))) - (fConst828 * ((fConst854 * fRec153[2]) + (fConst855 * fRec153[1]))));
			fRec152[0] = ((fConst828 * (((fConst830 * fRec153[0]) + (fConst856 * fRec153[1])) + (fConst830 * fRec153[2]))) - (fConst824 * ((fConst857 * fRec152[2]) + (fConst858 * fRec152[1]))));
			fRec151[0] = ((fSlow1 * fRec151[1]) + (fSlow2 * std::fabs((fConst824 * (((fConst827 * fRec152[0]) + (fConst859 * fRec152[1])) + (fConst827 * fRec152[2]))))));
			fVbargraph22 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec151[0])))));
			fRec164[0] = (fTemp22 - (fConst876 * ((fConst879 * fRec164[2]) + (fConst880 * fRec164[1]))));
			fRec163[0] = ((fConst876 * (((fConst878 * fRec164[0]) + (fConst881 * fRec164[1])) + (fConst878 * fRec164[2]))) - (fConst874 * ((fConst882 * fRec163[2]) + (fConst883 * fRec163[1]))));
			fRec162[0] = ((fConst874 * (((fConst875 * fRec163[0]) + (fConst884 * fRec163[1])) + (fConst875 * fRec163[2]))) - (fConst872 * ((fConst885 * fRec162[2]) + (fConst886 * fRec162[1]))));
			float fTemp23 = (fConst872 * (((fConst873 * fRec162[0]) + (fConst887 * fRec162[1])) + (fConst873 * fRec162[2])));
			fRec161[0] = (fTemp23 - (fConst869 * ((fConst888 * fRec161[2]) + (fConst890 * fRec161[1]))));
			fRec160[0] = ((fConst869 * (((fConst871 * fRec161[0]) + (fConst891 * fRec161[1])) + (fConst871 * fRec161[2]))) - (fConst866 * ((fConst892 * fRec160[2]) + (fConst893 * fRec160[1]))));
			fRec159[0] = ((fConst866 * (((fConst868 * fRec160[0]) + (fConst894 * fRec160[1])) + (fConst868 * fRec160[2]))) - (fConst862 * ((fConst895 * fRec159[2]) + (fConst896 * fRec159[1]))));
			fRec158[0] = ((fSlow1 * fRec158[1]) + (fSlow2 * std::fabs((fConst862 * (((fConst865 * fRec159[0]) + (fConst897 * fRec159[1])) + (fConst865 * fRec159[2]))))));
			fVbargraph23 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec158[0])))));
			fRec171[0] = (fTemp23 - (fConst914 * ((fConst917 * fRec171[2]) + (fConst918 * fRec171[1]))));
			fRec170[0] = ((fConst914 * (((fConst916 * fRec171[0]) + (fConst919 * fRec171[1])) + (fConst916 * fRec171[2]))) - (fConst912 * ((fConst920 * fRec170[2]) + (fConst921 * fRec170[1]))));
			fRec169[0] = ((fConst912 * (((fConst913 * fRec170[0]) + (fConst922 * fRec170[1])) + (fConst913 * fRec170[2]))) - (fConst910 * ((fConst923 * fRec169[2]) + (fConst924 * fRec169[1]))));
			float fTemp24 = (fConst910 * (((fConst911 * fRec169[0]) + (fConst925 * fRec169[1])) + (fConst911 * fRec169[2])));
			fRec168[0] = (fTemp24 - (fConst907 * ((fConst926 * fRec168[2]) + (fConst928 * fRec168[1]))));
			fRec167[0] = ((fConst907 * (((fConst909 * fRec168[0]) + (fConst929 * fRec168[1])) + (fConst909 * fRec168[2]))) - (fConst904 * ((fConst930 * fRec167[2]) + (fConst931 * fRec167[1]))));
			fRec166[0] = ((fConst904 * (((fConst906 * fRec167[0]) + (fConst932 * fRec167[1])) + (fConst906 * fRec167[2]))) - (fConst900 * ((fConst933 * fRec166[2]) + (fConst934 * fRec166[1]))));
			fRec165[0] = ((fSlow1 * fRec165[1]) + (fSlow2 * std::fabs((fConst900 * (((fConst903 * fRec166[0]) + (fConst935 * fRec166[1])) + (fConst903 * fRec166[2]))))));
			fVbargraph24 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec165[0])))));
			fRec178[0] = (fTemp24 - (fConst952 * ((fConst955 * fRec178[2]) + (fConst956 * fRec178[1]))));
			fRec177[0] = ((fConst952 * (((fConst954 * fRec178[0]) + (fConst957 * fRec178[1])) + (fConst954 * fRec178[2]))) - (fConst950 * ((fConst958 * fRec177[2]) + (fConst959 * fRec177[1]))));
			fRec176[0] = ((fConst950 * (((fConst951 * fRec177[0]) + (fConst960 * fRec177[1])) + (fConst951 * fRec177[2]))) - (fConst948 * ((fConst961 * fRec176[2]) + (fConst962 * fRec176[1]))));
			float fTemp25 = (fConst948 * (((fConst949 * fRec176[0]) + (fConst963 * fRec176[1])) + (fConst949 * fRec176[2])));
			fRec175[0] = (fTemp25 - (fConst945 * ((fConst964 * fRec175[2]) + (fConst966 * fRec175[1]))));
			fRec174[0] = ((fConst945 * (((fConst947 * fRec175[0]) + (fConst967 * fRec175[1])) + (fConst947 * fRec175[2]))) - (fConst942 * ((fConst968 * fRec174[2]) + (fConst969 * fRec174[1]))));
			fRec173[0] = ((fConst942 * (((fConst944 * fRec174[0]) + (fConst970 * fRec174[1])) + (fConst944 * fRec174[2]))) - (fConst938 * ((fConst971 * fRec173[2]) + (fConst972 * fRec173[1]))));
			fRec172[0] = ((fSlow1 * fRec172[1]) + (fSlow2 * std::fabs((fConst938 * (((fConst941 * fRec173[0]) + (fConst973 * fRec173[1])) + (fConst941 * fRec173[2]))))));
			fVbargraph25 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec172[0])))));
			fRec185[0] = (fTemp25 - (fConst990 * ((fConst993 * fRec185[2]) + (fConst994 * fRec185[1]))));
			fRec184[0] = ((fConst990 * (((fConst992 * fRec185[0]) + (fConst995 * fRec185[1])) + (fConst992 * fRec185[2]))) - (fConst988 * ((fConst996 * fRec184[2]) + (fConst997 * fRec184[1]))));
			fRec183[0] = ((fConst988 * (((fConst989 * fRec184[0]) + (fConst998 * fRec184[1])) + (fConst989 * fRec184[2]))) - (fConst986 * ((fConst999 * fRec183[2]) + (fConst1000 * fRec183[1]))));
			float fTemp26 = (fConst986 * (((fConst987 * fRec183[0]) + (fConst1001 * fRec183[1])) + (fConst987 * fRec183[2])));
			fRec182[0] = (fTemp26 - (fConst983 * ((fConst1002 * fRec182[2]) + (fConst1004 * fRec182[1]))));
			fRec181[0] = ((fConst983 * (((fConst985 * fRec182[0]) + (fConst1005 * fRec182[1])) + (fConst985 * fRec182[2]))) - (fConst980 * ((fConst1006 * fRec181[2]) + (fConst1007 * fRec181[1]))));
			fRec180[0] = ((fConst980 * (((fConst982 * fRec181[0]) + (fConst1008 * fRec181[1])) + (fConst982 * fRec181[2]))) - (fConst976 * ((fConst1009 * fRec180[2]) + (fConst1010 * fRec180[1]))));
			fRec179[0] = ((fSlow1 * fRec179[1]) + (fSlow2 * std::fabs((fConst976 * (((fConst979 * fRec180[0]) + (fConst1011 * fRec180[1])) + (fConst979 * fRec180[2]))))));
			fVbargraph26 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec179[0])))));
			fRec192[0] = (fTemp26 - (fConst1028 * ((fConst1031 * fRec192[2]) + (fConst1032 * fRec192[1]))));
			fRec191[0] = ((fConst1028 * (((fConst1030 * fRec192[0]) + (fConst1033 * fRec192[1])) + (fConst1030 * fRec192[2]))) - (fConst1026 * ((fConst1034 * fRec191[2]) + (fConst1035 * fRec191[1]))));
			fRec190[0] = ((fConst1026 * (((fConst1027 * fRec191[0]) + (fConst1036 * fRec191[1])) + (fConst1027 * fRec191[2]))) - (fConst1024 * ((fConst1037 * fRec190[2]) + (fConst1038 * fRec190[1]))));
			float fTemp27 = (fConst1024 * (((fConst1025 * fRec190[0]) + (fConst1039 * fRec190[1])) + (fConst1025 * fRec190[2])));
			fRec189[0] = (fTemp27 - (fConst1021 * ((fConst1040 * fRec189[2]) + (fConst1042 * fRec189[1]))));
			fRec188[0] = ((fConst1021 * (((fConst1023 * fRec189[0]) + (fConst1043 * fRec189[1])) + (fConst1023 * fRec189[2]))) - (fConst1018 * ((fConst1044 * fRec188[2]) + (fConst1045 * fRec188[1]))));
			fRec187[0] = ((fConst1018 * (((fConst1020 * fRec188[0]) + (fConst1046 * fRec188[1])) + (fConst1020 * fRec188[2]))) - (fConst1014 * ((fConst1047 * fRec187[2]) + (fConst1048 * fRec187[1]))));
			fRec186[0] = ((fSlow1 * fRec186[1]) + (fSlow2 * std::fabs((fConst1014 * (((fConst1017 * fRec187[0]) + (fConst1049 * fRec187[1])) + (fConst1017 * fRec187[2]))))));
			fVbargraph27 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec186[0])))));
			fRec199[0] = (fTemp27 - (fConst1066 * ((fConst1069 * fRec199[2]) + (fConst1070 * fRec199[1]))));
			fRec198[0] = ((fConst1066 * (((fConst1068 * fRec199[0]) + (fConst1071 * fRec199[1])) + (fConst1068 * fRec199[2]))) - (fConst1064 * ((fConst1072 * fRec198[2]) + (fConst1073 * fRec198[1]))));
			fRec197[0] = ((fConst1064 * (((fConst1065 * fRec198[0]) + (fConst1074 * fRec198[1])) + (fConst1065 * fRec198[2]))) - (fConst1062 * ((fConst1075 * fRec197[2]) + (fConst1076 * fRec197[1]))));
			float fTemp28 = (fConst1062 * (((fConst1063 * fRec197[0]) + (fConst1077 * fRec197[1])) + (fConst1063 * fRec197[2])));
			fRec196[0] = (fTemp28 - (fConst1059 * ((fConst1078 * fRec196[2]) + (fConst1080 * fRec196[1]))));
			fRec195[0] = ((fConst1059 * (((fConst1061 * fRec196[0]) + (fConst1081 * fRec196[1])) + (fConst1061 * fRec196[2]))) - (fConst1056 * ((fConst1082 * fRec195[2]) + (fConst1083 * fRec195[1]))));
			fRec194[0] = ((fConst1056 * (((fConst1058 * fRec195[0]) + (fConst1084 * fRec195[1])) + (fConst1058 * fRec195[2]))) - (fConst1052 * ((fConst1085 * fRec194[2]) + (fConst1086 * fRec194[1]))));
			fRec193[0] = ((fSlow1 * fRec193[1]) + (fSlow2 * std::fabs((fConst1052 * (((fConst1055 * fRec194[0]) + (fConst1087 * fRec194[1])) + (fConst1055 * fRec194[2]))))));
			fVbargraph28 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec193[0])))));
			fRec206[0] = (fTemp28 - (fConst1104 * ((fConst1107 * fRec206[2]) + (fConst1108 * fRec206[1]))));
			fRec205[0] = ((fConst1104 * (((fConst1106 * fRec206[0]) + (fConst1109 * fRec206[1])) + (fConst1106 * fRec206[2]))) - (fConst1102 * ((fConst1110 * fRec205[2]) + (fConst1111 * fRec205[1]))));
			fRec204[0] = ((fConst1102 * (((fConst1103 * fRec205[0]) + (fConst1112 * fRec205[1])) + (fConst1103 * fRec205[2]))) - (fConst1100 * ((fConst1113 * fRec204[2]) + (fConst1114 * fRec204[1]))));
			float fTemp29 = (fConst1100 * (((fConst1101 * fRec204[0]) + (fConst1115 * fRec204[1])) + (fConst1101 * fRec204[2])));
			fRec203[0] = (fTemp29 - (fConst1097 * ((fConst1116 * fRec203[2]) + (fConst1118 * fRec203[1]))));
			fRec202[0] = ((fConst1097 * (((fConst1099 * fRec203[0]) + (fConst1119 * fRec203[1])) + (fConst1099 * fRec203[2]))) - (fConst1094 * ((fConst1120 * fRec202[2]) + (fConst1121 * fRec202[1]))));
			fRec201[0] = ((fConst1094 * (((fConst1096 * fRec202[0]) + (fConst1122 * fRec202[1])) + (fConst1096 * fRec202[2]))) - (fConst1090 * ((fConst1123 * fRec201[2]) + (fConst1124 * fRec201[1]))));
			fRec200[0] = ((fSlow1 * fRec200[1]) + (fSlow2 * std::fabs((fConst1090 * (((fConst1093 * fRec201[0]) + (fConst1125 * fRec201[1])) + (fConst1093 * fRec201[2]))))));
			fVbargraph29 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec200[0])))));
			fRec213[0] = (fTemp29 - (fConst1142 * ((fConst1145 * fRec213[2]) + (fConst1146 * fRec213[1]))));
			fRec212[0] = ((fConst1142 * (((fConst1144 * fRec213[0]) + (fConst1147 * fRec213[1])) + (fConst1144 * fRec213[2]))) - (fConst1140 * ((fConst1148 * fRec212[2]) + (fConst1149 * fRec212[1]))));
			fRec211[0] = ((fConst1140 * (((fConst1141 * fRec212[0]) + (fConst1150 * fRec212[1])) + (fConst1141 * fRec212[2]))) - (fConst1138 * ((fConst1151 * fRec211[2]) + (fConst1152 * fRec211[1]))));
			float fTemp30 = (fConst1138 * (((fConst1139 * fRec211[0]) + (fConst1153 * fRec211[1])) + (fConst1139 * fRec211[2])));
			fRec210[0] = (fTemp30 - (fConst1135 * ((fConst1154 * fRec210[2]) + (fConst1156 * fRec210[1]))));
			fRec209[0] = ((fConst1135 * (((fConst1137 * fRec210[0]) + (fConst1157 * fRec210[1])) + (fConst1137 * fRec210[2]))) - (fConst1132 * ((fConst1158 * fRec209[2]) + (fConst1159 * fRec209[1]))));
			fRec208[0] = ((fConst1132 * (((fConst1134 * fRec209[0]) + (fConst1160 * fRec209[1])) + (fConst1134 * fRec209[2]))) - (fConst1128 * ((fConst1161 * fRec208[2]) + (fConst1162 * fRec208[1]))));
			fRec207[0] = ((fSlow1 * fRec207[1]) + (fSlow2 * std::fabs((fConst1128 * (((fConst1131 * fRec208[0]) + (fConst1163 * fRec208[1])) + (fConst1131 * fRec208[2]))))));
			fVbargraph30 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec207[0])))));
			fRec220[0] = (fTemp30 - (fConst1180 * ((fConst1183 * fRec220[2]) + (fConst1184 * fRec220[1]))));
			fRec219[0] = ((fConst1180 * (((fConst1182 * fRec220[0]) + (fConst1185 * fRec220[1])) + (fConst1182 * fRec220[2]))) - (fConst1178 * ((fConst1186 * fRec219[2]) + (fConst1187 * fRec219[1]))));
			fRec218[0] = ((fConst1178 * (((fConst1179 * fRec219[0]) + (fConst1188 * fRec219[1])) + (fConst1179 * fRec219[2]))) - (fConst1176 * ((fConst1189 * fRec218[2]) + (fConst1190 * fRec218[1]))));
			float fTemp31 = (fConst1176 * (((fConst1177 * fRec218[0]) + (fConst1191 * fRec218[1])) + (fConst1177 * fRec218[2])));
			fRec217[0] = (fTemp31 - (fConst1173 * ((fConst1192 * fRec217[2]) + (fConst1194 * fRec217[1]))));
			fRec216[0] = ((fConst1173 * (((fConst1175 * fRec217[0]) + (fConst1195 * fRec217[1])) + (fConst1175 * fRec217[2]))) - (fConst1170 * ((fConst1196 * fRec216[2]) + (fConst1197 * fRec216[1]))));
			fRec215[0] = ((fConst1170 * (((fConst1172 * fRec216[0]) + (fConst1198 * fRec216[1])) + (fConst1172 * fRec216[2]))) - (fConst1166 * ((fConst1199 * fRec215[2]) + (fConst1200 * fRec215[1]))));
			fRec214[0] = ((fSlow1 * fRec214[1]) + (fSlow2 * std::fabs((fConst1166 * (((fConst1169 * fRec215[0]) + (fConst1201 * fRec215[1])) + (fConst1169 * fRec215[2]))))));
			fVbargraph31 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec214[0])))));
			fRec227[0] = (fTemp31 - (fConst1218 * ((fConst1221 * fRec227[2]) + (fConst1222 * fRec227[1]))));
			fRec226[0] = ((fConst1218 * (((fConst1220 * fRec227[0]) + (fConst1223 * fRec227[1])) + (fConst1220 * fRec227[2]))) - (fConst1216 * ((fConst1224 * fRec226[2]) + (fConst1225 * fRec226[1]))));
			fRec225[0] = ((fConst1216 * (((fConst1217 * fRec226[0]) + (fConst1226 * fRec226[1])) + (fConst1217 * fRec226[2]))) - (fConst1214 * ((fConst1227 * fRec225[2]) + (fConst1228 * fRec225[1]))));
			float fTemp32 = (fConst1214 * (((fConst1215 * fRec225[0]) + (fConst1229 * fRec225[1])) + (fConst1215 * fRec225[2])));
			fRec224[0] = (fTemp32 - (fConst1211 * ((fConst1230 * fRec224[2]) + (fConst1232 * fRec224[1]))));
			fRec223[0] = ((fConst1211 * (((fConst1213 * fRec224[0]) + (fConst1233 * fRec224[1])) + (fConst1213 * fRec224[2]))) - (fConst1208 * ((fConst1234 * fRec223[2]) + (fConst1235 * fRec223[1]))));
			fRec222[0] = ((fConst1208 * (((fConst1210 * fRec223[0]) + (fConst1236 * fRec223[1])) + (fConst1210 * fRec223[2]))) - (fConst1204 * ((fConst1237 * fRec222[2]) + (fConst1238 * fRec222[1]))));
			fRec221[0] = ((fSlow1 * fRec221[1]) + (fSlow2 * std::fabs((fConst1204 * (((fConst1207 * fRec222[0]) + (fConst1239 * fRec222[1])) + (fConst1207 * fRec222[2]))))));
			fVbargraph32 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec221[0])))));
			fRec234[0] = (fTemp32 - (fConst1256 * ((fConst1259 * fRec234[2]) + (fConst1260 * fRec234[1]))));
			fRec233[0] = ((fConst1256 * (((fConst1258 * fRec234[0]) + (fConst1261 * fRec234[1])) + (fConst1258 * fRec234[2]))) - (fConst1254 * ((fConst1262 * fRec233[2]) + (fConst1263 * fRec233[1]))));
			fRec232[0] = ((fConst1254 * (((fConst1255 * fRec233[0]) + (fConst1264 * fRec233[1])) + (fConst1255 * fRec233[2]))) - (fConst1252 * ((fConst1265 * fRec232[2]) + (fConst1266 * fRec232[1]))));
			float fTemp33 = (fConst1252 * (((fConst1253 * fRec232[0]) + (fConst1267 * fRec232[1])) + (fConst1253 * fRec232[2])));
			fRec231[0] = (fTemp33 - (fConst1249 * ((fConst1268 * fRec231[2]) + (fConst1270 * fRec231[1]))));
			fRec230[0] = ((fConst1249 * (((fConst1251 * fRec231[0]) + (fConst1271 * fRec231[1])) + (fConst1251 * fRec231[2]))) - (fConst1246 * ((fConst1272 * fRec230[2]) + (fConst1273 * fRec230[1]))));
			fRec229[0] = ((fConst1246 * (((fConst1248 * fRec230[0]) + (fConst1274 * fRec230[1])) + (fConst1248 * fRec230[2]))) - (fConst1242 * ((fConst1275 * fRec229[2]) + (fConst1276 * fRec229[1]))));
			fRec228[0] = ((fSlow1 * fRec228[1]) + (fSlow2 * std::fabs((fConst1242 * (((fConst1245 * fRec229[0]) + (fConst1277 * fRec229[1])) + (fConst1245 * fRec229[2]))))));
			fVbargraph33 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec228[0])))));
			fRec241[0] = (fTemp33 - (fConst1294 * ((fConst1297 * fRec241[2]) + (fConst1298 * fRec241[1]))));
			fRec240[0] = ((fConst1294 * (((fConst1296 * fRec241[0]) + (fConst1299 * fRec241[1])) + (fConst1296 * fRec241[2]))) - (fConst1292 * ((fConst1300 * fRec240[2]) + (fConst1301 * fRec240[1]))));
			fRec239[0] = ((fConst1292 * (((fConst1293 * fRec240[0]) + (fConst1302 * fRec240[1])) + (fConst1293 * fRec240[2]))) - (fConst1290 * ((fConst1303 * fRec239[2]) + (fConst1304 * fRec239[1]))));
			float fTemp34 = (fConst1290 * (((fConst1291 * fRec239[0]) + (fConst1305 * fRec239[1])) + (fConst1291 * fRec239[2])));
			fRec238[0] = (fTemp34 - (fConst1287 * ((fConst1306 * fRec238[2]) + (fConst1308 * fRec238[1]))));
			fRec237[0] = ((fConst1287 * (((fConst1289 * fRec238[0]) + (fConst1309 * fRec238[1])) + (fConst1289 * fRec238[2]))) - (fConst1284 * ((fConst1310 * fRec237[2]) + (fConst1311 * fRec237[1]))));
			fRec236[0] = ((fConst1284 * (((fConst1286 * fRec237[0]) + (fConst1312 * fRec237[1])) + (fConst1286 * fRec237[2]))) - (fConst1280 * ((fConst1313 * fRec236[2]) + (fConst1314 * fRec236[1]))));
			fRec235[0] = ((fSlow1 * fRec235[1]) + (fSlow2 * std::fabs((fConst1280 * (((fConst1283 * fRec236[0]) + (fConst1315 * fRec236[1])) + (fConst1283 * fRec236[2]))))));
			fVbargraph34 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec235[0])))));
			fRec248[0] = (fTemp34 - (fConst1332 * ((fConst1335 * fRec248[2]) + (fConst1336 * fRec248[1]))));
			fRec247[0] = ((fConst1332 * (((fConst1334 * fRec248[0]) + (fConst1337 * fRec248[1])) + (fConst1334 * fRec248[2]))) - (fConst1330 * ((fConst1338 * fRec247[2]) + (fConst1339 * fRec247[1]))));
			fRec246[0] = ((fConst1330 * (((fConst1331 * fRec247[0]) + (fConst1340 * fRec247[1])) + (fConst1331 * fRec247[2]))) - (fConst1328 * ((fConst1341 * fRec246[2]) + (fConst1342 * fRec246[1]))));
			float fTemp35 = (fConst1328 * (((fConst1329 * fRec246[0]) + (fConst1343 * fRec246[1])) + (fConst1329 * fRec246[2])));
			fRec245[0] = (fTemp35 - (fConst1325 * ((fConst1344 * fRec245[2]) + (fConst1346 * fRec245[1]))));
			fRec244[0] = ((fConst1325 * (((fConst1327 * fRec245[0]) + (fConst1347 * fRec245[1])) + (fConst1327 * fRec245[2]))) - (fConst1322 * ((fConst1348 * fRec244[2]) + (fConst1349 * fRec244[1]))));
			fRec243[0] = ((fConst1322 * (((fConst1324 * fRec244[0]) + (fConst1350 * fRec244[1])) + (fConst1324 * fRec244[2]))) - (fConst1318 * ((fConst1351 * fRec243[2]) + (fConst1352 * fRec243[1]))));
			fRec242[0] = ((fSlow1 * fRec242[1]) + (fSlow2 * std::fabs((fConst1318 * (((fConst1321 * fRec243[0]) + (fConst1353 * fRec243[1])) + (fConst1321 * fRec243[2]))))));
			fVbargraph35 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec242[0])))));
			fRec255[0] = (fTemp35 - (fConst1370 * ((fConst1373 * fRec255[2]) + (fConst1374 * fRec255[1]))));
			fRec254[0] = ((fConst1370 * (((fConst1372 * fRec255[0]) + (fConst1375 * fRec255[1])) + (fConst1372 * fRec255[2]))) - (fConst1368 * ((fConst1376 * fRec254[2]) + (fConst1377 * fRec254[1]))));
			fRec253[0] = ((fConst1368 * (((fConst1369 * fRec254[0]) + (fConst1378 * fRec254[1])) + (fConst1369 * fRec254[2]))) - (fConst1366 * ((fConst1379 * fRec253[2]) + (fConst1380 * fRec253[1]))));
			float fTemp36 = (fConst1366 * (((fConst1367 * fRec253[0]) + (fConst1381 * fRec253[1])) + (fConst1367 * fRec253[2])));
			fRec252[0] = (fTemp36 - (fConst1363 * ((fConst1382 * fRec252[2]) + (fConst1384 * fRec252[1]))));
			fRec251[0] = ((fConst1363 * (((fConst1365 * fRec252[0]) + (fConst1385 * fRec252[1])) + (fConst1365 * fRec252[2]))) - (fConst1360 * ((fConst1386 * fRec251[2]) + (fConst1387 * fRec251[1]))));
			fRec250[0] = ((fConst1360 * (((fConst1362 * fRec251[0]) + (fConst1388 * fRec251[1])) + (fConst1362 * fRec251[2]))) - (fConst1356 * ((fConst1389 * fRec250[2]) + (fConst1390 * fRec250[1]))));
			fRec249[0] = ((fSlow1 * fRec249[1]) + (fSlow2 * std::fabs((fConst1356 * (((fConst1359 * fRec250[0]) + (fConst1391 * fRec250[1])) + (fConst1359 * fRec250[2]))))));
			fVbargraph36 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec249[0])))));
			fRec262[0] = (fTemp36 - (fConst1408 * ((fConst1411 * fRec262[2]) + (fConst1412 * fRec262[1]))));
			fRec261[0] = ((fConst1408 * (((fConst1410 * fRec262[0]) + (fConst1413 * fRec262[1])) + (fConst1410 * fRec262[2]))) - (fConst1406 * ((fConst1414 * fRec261[2]) + (fConst1415 * fRec261[1]))));
			fRec260[0] = ((fConst1406 * (((fConst1407 * fRec261[0]) + (fConst1416 * fRec261[1])) + (fConst1407 * fRec261[2]))) - (fConst1404 * ((fConst1417 * fRec260[2]) + (fConst1418 * fRec260[1]))));
			float fTemp37 = (fConst1404 * (((fConst1405 * fRec260[0]) + (fConst1419 * fRec260[1])) + (fConst1405 * fRec260[2])));
			fRec259[0] = (fTemp37 - (fConst1401 * ((fConst1420 * fRec259[2]) + (fConst1422 * fRec259[1]))));
			fRec258[0] = ((fConst1401 * (((fConst1403 * fRec259[0]) + (fConst1423 * fRec259[1])) + (fConst1403 * fRec259[2]))) - (fConst1398 * ((fConst1424 * fRec258[2]) + (fConst1425 * fRec258[1]))));
			fRec257[0] = ((fConst1398 * (((fConst1400 * fRec258[0]) + (fConst1426 * fRec258[1])) + (fConst1400 * fRec258[2]))) - (fConst1394 * ((fConst1427 * fRec257[2]) + (fConst1428 * fRec257[1]))));
			fRec256[0] = ((fSlow1 * fRec256[1]) + (fSlow2 * std::fabs((fConst1394 * (((fConst1397 * fRec257[0]) + (fConst1429 * fRec257[1])) + (fConst1397 * fRec257[2]))))));
			fVbargraph37 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec256[0])))));
			fRec269[0] = (fTemp37 - (fConst1446 * ((fConst1449 * fRec269[2]) + (fConst1450 * fRec269[1]))));
			fRec268[0] = ((fConst1446 * (((fConst1448 * fRec269[0]) + (fConst1451 * fRec269[1])) + (fConst1448 * fRec269[2]))) - (fConst1444 * ((fConst1452 * fRec268[2]) + (fConst1453 * fRec268[1]))));
			fRec267[0] = ((fConst1444 * (((fConst1445 * fRec268[0]) + (fConst1454 * fRec268[1])) + (fConst1445 * fRec268[2]))) - (fConst1442 * ((fConst1455 * fRec267[2]) + (fConst1456 * fRec267[1]))));
			float fTemp38 = (fConst1442 * (((fConst1443 * fRec267[0]) + (fConst1457 * fRec267[1])) + (fConst1443 * fRec267[2])));
			fRec266[0] = (fTemp38 - (fConst1439 * ((fConst1458 * fRec266[2]) + (fConst1460 * fRec266[1]))));
			fRec265[0] = ((fConst1439 * (((fConst1441 * fRec266[0]) + (fConst1461 * fRec266[1])) + (fConst1441 * fRec266[2]))) - (fConst1436 * ((fConst1462 * fRec265[2]) + (fConst1463 * fRec265[1]))));
			fRec264[0] = ((fConst1436 * (((fConst1438 * fRec265[0]) + (fConst1464 * fRec265[1])) + (fConst1438 * fRec265[2]))) - (fConst1432 * ((fConst1465 * fRec264[2]) + (fConst1466 * fRec264[1]))));
			fRec263[0] = ((fSlow1 * fRec263[1]) + (fSlow2 * std::fabs((fConst1432 * (((fConst1435 * fRec264[0]) + (fConst1467 * fRec264[1])) + (fConst1435 * fRec264[2]))))));
			fVbargraph38 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec263[0])))));
			fRec276[0] = (fTemp38 - (fConst1484 * ((fConst1487 * fRec276[2]) + (fConst1488 * fRec276[1]))));
			fRec275[0] = ((fConst1484 * (((fConst1486 * fRec276[0]) + (fConst1489 * fRec276[1])) + (fConst1486 * fRec276[2]))) - (fConst1482 * ((fConst1490 * fRec275[2]) + (fConst1491 * fRec275[1]))));
			fRec274[0] = ((fConst1482 * (((fConst1483 * fRec275[0]) + (fConst1492 * fRec275[1])) + (fConst1483 * fRec275[2]))) - (fConst1480 * ((fConst1493 * fRec274[2]) + (fConst1494 * fRec274[1]))));
			float fTemp39 = (fConst1480 * (((fConst1481 * fRec274[0]) + (fConst1495 * fRec274[1])) + (fConst1481 * fRec274[2])));
			fRec273[0] = (fTemp39 - (fConst1477 * ((fConst1496 * fRec273[2]) + (fConst1498 * fRec273[1]))));
			fRec272[0] = ((fConst1477 * (((fConst1479 * fRec273[0]) + (fConst1499 * fRec273[1])) + (fConst1479 * fRec273[2]))) - (fConst1474 * ((fConst1500 * fRec272[2]) + (fConst1501 * fRec272[1]))));
			fRec271[0] = ((fConst1474 * (((fConst1476 * fRec272[0]) + (fConst1502 * fRec272[1])) + (fConst1476 * fRec272[2]))) - (fConst1470 * ((fConst1503 * fRec271[2]) + (fConst1504 * fRec271[1]))));
			fRec270[0] = ((fSlow1 * fRec270[1]) + (fSlow2 * std::fabs((fConst1470 * (((fConst1473 * fRec271[0]) + (fConst1505 * fRec271[1])) + (fConst1473 * fRec271[2]))))));
			fVbargraph39 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec270[0])))));
			fRec283[0] = (fTemp39 - (fConst1522 * ((fConst1525 * fRec283[2]) + (fConst1526 * fRec283[1]))));
			fRec282[0] = ((fConst1522 * (((fConst1524 * fRec283[0]) + (fConst1527 * fRec283[1])) + (fConst1524 * fRec283[2]))) - (fConst1520 * ((fConst1528 * fRec282[2]) + (fConst1529 * fRec282[1]))));
			fRec281[0] = ((fConst1520 * (((fConst1521 * fRec282[0]) + (fConst1530 * fRec282[1])) + (fConst1521 * fRec282[2]))) - (fConst1518 * ((fConst1531 * fRec281[2]) + (fConst1532 * fRec281[1]))));
			float fTemp40 = (fConst1518 * (((fConst1519 * fRec281[0]) + (fConst1533 * fRec281[1])) + (fConst1519 * fRec281[2])));
			fRec280[0] = (fTemp40 - (fConst1515 * ((fConst1534 * fRec280[2]) + (fConst1536 * fRec280[1]))));
			fRec279[0] = ((fConst1515 * (((fConst1517 * fRec280[0]) + (fConst1537 * fRec280[1])) + (fConst1517 * fRec280[2]))) - (fConst1512 * ((fConst1538 * fRec279[2]) + (fConst1539 * fRec279[1]))));
			fRec278[0] = ((fConst1512 * (((fConst1514 * fRec279[0]) + (fConst1540 * fRec279[1])) + (fConst1514 * fRec279[2]))) - (fConst1508 * ((fConst1541 * fRec278[2]) + (fConst1542 * fRec278[1]))));
			fRec277[0] = ((fSlow1 * fRec277[1]) + (fSlow2 * std::fabs((fConst1508 * (((fConst1511 * fRec278[0]) + (fConst1543 * fRec278[1])) + (fConst1511 * fRec278[2]))))));
			fVbargraph40 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec277[0])))));
			fRec290[0] = (fTemp40 - (fConst1560 * ((fConst1563 * fRec290[2]) + (fConst1564 * fRec290[1]))));
			fRec289[0] = ((fConst1560 * (((fConst1562 * fRec290[0]) + (fConst1565 * fRec290[1])) + (fConst1562 * fRec290[2]))) - (fConst1558 * ((fConst1566 * fRec289[2]) + (fConst1567 * fRec289[1]))));
			fRec288[0] = ((fConst1558 * (((fConst1559 * fRec289[0]) + (fConst1568 * fRec289[1])) + (fConst1559 * fRec289[2]))) - (fConst1556 * ((fConst1569 * fRec288[2]) + (fConst1570 * fRec288[1]))));
			float fTemp41 = (fConst1556 * (((fConst1557 * fRec288[0]) + (fConst1571 * fRec288[1])) + (fConst1557 * fRec288[2])));
			fRec287[0] = (fTemp41 - (fConst1553 * ((fConst1572 * fRec287[2]) + (fConst1574 * fRec287[1]))));
			fRec286[0] = ((fConst1553 * (((fConst1555 * fRec287[0]) + (fConst1575 * fRec287[1])) + (fConst1555 * fRec287[2]))) - (fConst1550 * ((fConst1576 * fRec286[2]) + (fConst1577 * fRec286[1]))));
			fRec285[0] = ((fConst1550 * (((fConst1552 * fRec286[0]) + (fConst1578 * fRec286[1])) + (fConst1552 * fRec286[2]))) - (fConst1546 * ((fConst1579 * fRec285[2]) + (fConst1580 * fRec285[1]))));
			fRec284[0] = ((fSlow1 * fRec284[1]) + (fSlow2 * std::fabs((fConst1546 * (((fConst1549 * fRec285[0]) + (fConst1581 * fRec285[1])) + (fConst1549 * fRec285[2]))))));
			fVbargraph41 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec284[0])))));
			fRec297[0] = (fTemp41 - (fConst1598 * ((fConst1601 * fRec297[2]) + (fConst1602 * fRec297[1]))));
			fRec296[0] = ((fConst1598 * (((fConst1600 * fRec297[0]) + (fConst1603 * fRec297[1])) + (fConst1600 * fRec297[2]))) - (fConst1596 * ((fConst1604 * fRec296[2]) + (fConst1605 * fRec296[1]))));
			fRec295[0] = ((fConst1596 * (((fConst1597 * fRec296[0]) + (fConst1606 * fRec296[1])) + (fConst1597 * fRec296[2]))) - (fConst1594 * ((fConst1607 * fRec295[2]) + (fConst1608 * fRec295[1]))));
			float fTemp42 = (fConst1594 * (((fConst1595 * fRec295[0]) + (fConst1609 * fRec295[1])) + (fConst1595 * fRec295[2])));
			fRec294[0] = (fTemp42 - (fConst1591 * ((fConst1610 * fRec294[2]) + (fConst1612 * fRec294[1]))));
			fRec293[0] = ((fConst1591 * (((fConst1593 * fRec294[0]) + (fConst1613 * fRec294[1])) + (fConst1593 * fRec294[2]))) - (fConst1588 * ((fConst1614 * fRec293[2]) + (fConst1615 * fRec293[1]))));
			fRec292[0] = ((fConst1588 * (((fConst1590 * fRec293[0]) + (fConst1616 * fRec293[1])) + (fConst1590 * fRec293[2]))) - (fConst1584 * ((fConst1617 * fRec292[2]) + (fConst1618 * fRec292[1]))));
			fRec291[0] = ((fSlow1 * fRec291[1]) + (fSlow2 * std::fabs((fConst1584 * (((fConst1587 * fRec292[0]) + (fConst1619 * fRec292[1])) + (fConst1587 * fRec292[2]))))));
			fVbargraph42 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec291[0])))));
			fRec304[0] = (fTemp42 - (fConst1636 * ((fConst1639 * fRec304[2]) + (fConst1640 * fRec304[1]))));
			fRec303[0] = ((fConst1636 * (((fConst1638 * fRec304[0]) + (fConst1641 * fRec304[1])) + (fConst1638 * fRec304[2]))) - (fConst1634 * ((fConst1642 * fRec303[2]) + (fConst1643 * fRec303[1]))));
			fRec302[0] = ((fConst1634 * (((fConst1635 * fRec303[0]) + (fConst1644 * fRec303[1])) + (fConst1635 * fRec303[2]))) - (fConst1632 * ((fConst1645 * fRec302[2]) + (fConst1646 * fRec302[1]))));
			float fTemp43 = (fConst1632 * (((fConst1633 * fRec302[0]) + (fConst1647 * fRec302[1])) + (fConst1633 * fRec302[2])));
			fRec301[0] = (fTemp43 - (fConst1629 * ((fConst1648 * fRec301[2]) + (fConst1650 * fRec301[1]))));
			fRec300[0] = ((fConst1629 * (((fConst1631 * fRec301[0]) + (fConst1651 * fRec301[1])) + (fConst1631 * fRec301[2]))) - (fConst1626 * ((fConst1652 * fRec300[2]) + (fConst1653 * fRec300[1]))));
			fRec299[0] = ((fConst1626 * (((fConst1628 * fRec300[0]) + (fConst1654 * fRec300[1])) + (fConst1628 * fRec300[2]))) - (fConst1622 * ((fConst1655 * fRec299[2]) + (fConst1656 * fRec299[1]))));
			fRec298[0] = ((fSlow1 * fRec298[1]) + (fSlow2 * std::fabs((fConst1622 * (((fConst1625 * fRec299[0]) + (fConst1657 * fRec299[1])) + (fConst1625 * fRec299[2]))))));
			fVbargraph43 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec298[0])))));
			fRec311[0] = (fTemp43 - (fConst1674 * ((fConst1677 * fRec311[2]) + (fConst1678 * fRec311[1]))));
			fRec310[0] = ((fConst1674 * (((fConst1676 * fRec311[0]) + (fConst1679 * fRec311[1])) + (fConst1676 * fRec311[2]))) - (fConst1672 * ((fConst1680 * fRec310[2]) + (fConst1681 * fRec310[1]))));
			fRec309[0] = ((fConst1672 * (((fConst1673 * fRec310[0]) + (fConst1682 * fRec310[1])) + (fConst1673 * fRec310[2]))) - (fConst1670 * ((fConst1683 * fRec309[2]) + (fConst1684 * fRec309[1]))));
			float fTemp44 = (fConst1670 * (((fConst1671 * fRec309[0]) + (fConst1685 * fRec309[1])) + (fConst1671 * fRec309[2])));
			fRec308[0] = (fTemp44 - (fConst1667 * ((fConst1686 * fRec308[2]) + (fConst1688 * fRec308[1]))));
			fRec307[0] = ((fConst1667 * (((fConst1669 * fRec308[0]) + (fConst1689 * fRec308[1])) + (fConst1669 * fRec308[2]))) - (fConst1664 * ((fConst1690 * fRec307[2]) + (fConst1691 * fRec307[1]))));
			fRec306[0] = ((fConst1664 * (((fConst1666 * fRec307[0]) + (fConst1692 * fRec307[1])) + (fConst1666 * fRec307[2]))) - (fConst1660 * ((fConst1693 * fRec306[2]) + (fConst1694 * fRec306[1]))));
			fRec305[0] = ((fSlow1 * fRec305[1]) + (fSlow2 * std::fabs((fConst1660 * (((fConst1663 * fRec306[0]) + (fConst1695 * fRec306[1])) + (fConst1663 * fRec306[2]))))));
			fVbargraph44 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec305[0])))));
			fRec318[0] = (fTemp44 - (fConst1712 * ((fConst1715 * fRec318[2]) + (fConst1716 * fRec318[1]))));
			fRec317[0] = ((fConst1712 * (((fConst1714 * fRec318[0]) + (fConst1717 * fRec318[1])) + (fConst1714 * fRec318[2]))) - (fConst1710 * ((fConst1718 * fRec317[2]) + (fConst1719 * fRec317[1]))));
			fRec316[0] = ((fConst1710 * (((fConst1711 * fRec317[0]) + (fConst1720 * fRec317[1])) + (fConst1711 * fRec317[2]))) - (fConst1708 * ((fConst1721 * fRec316[2]) + (fConst1722 * fRec316[1]))));
			float fTemp45 = (fConst1708 * (((fConst1709 * fRec316[0]) + (fConst1723 * fRec316[1])) + (fConst1709 * fRec316[2])));
			fRec315[0] = (fTemp45 - (fConst1705 * ((fConst1724 * fRec315[2]) + (fConst1726 * fRec315[1]))));
			fRec314[0] = ((fConst1705 * (((fConst1707 * fRec315[0]) + (fConst1727 * fRec315[1])) + (fConst1707 * fRec315[2]))) - (fConst1702 * ((fConst1728 * fRec314[2]) + (fConst1729 * fRec314[1]))));
			fRec313[0] = ((fConst1702 * (((fConst1704 * fRec314[0]) + (fConst1730 * fRec314[1])) + (fConst1704 * fRec314[2]))) - (fConst1698 * ((fConst1731 * fRec313[2]) + (fConst1732 * fRec313[1]))));
			fRec312[0] = ((fSlow1 * fRec312[1]) + (fSlow2 * std::fabs((fConst1698 * (((fConst1701 * fRec313[0]) + (fConst1733 * fRec313[1])) + (fConst1701 * fRec313[2]))))));
			fVbargraph45 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec312[0])))));
			fRec325[0] = (fTemp45 - (fConst1750 * ((fConst1753 * fRec325[2]) + (fConst1754 * fRec325[1]))));
			fRec324[0] = ((fConst1750 * (((fConst1752 * fRec325[0]) + (fConst1755 * fRec325[1])) + (fConst1752 * fRec325[2]))) - (fConst1748 * ((fConst1756 * fRec324[2]) + (fConst1757 * fRec324[1]))));
			fRec323[0] = ((fConst1748 * (((fConst1749 * fRec324[0]) + (fConst1758 * fRec324[1])) + (fConst1749 * fRec324[2]))) - (fConst1746 * ((fConst1759 * fRec323[2]) + (fConst1760 * fRec323[1]))));
			float fTemp46 = (fConst1746 * (((fConst1747 * fRec323[0]) + (fConst1761 * fRec323[1])) + (fConst1747 * fRec323[2])));
			fRec322[0] = (fTemp46 - (fConst1743 * ((fConst1762 * fRec322[2]) + (fConst1764 * fRec322[1]))));
			fRec321[0] = ((fConst1743 * (((fConst1745 * fRec322[0]) + (fConst1765 * fRec322[1])) + (fConst1745 * fRec322[2]))) - (fConst1740 * ((fConst1766 * fRec321[2]) + (fConst1767 * fRec321[1]))));
			fRec320[0] = ((fConst1740 * (((fConst1742 * fRec321[0]) + (fConst1768 * fRec321[1])) + (fConst1742 * fRec321[2]))) - (fConst1736 * ((fConst1769 * fRec320[2]) + (fConst1770 * fRec320[1]))));
			fRec319[0] = ((fSlow1 * fRec319[1]) + (fSlow2 * std::fabs((fConst1736 * (((fConst1739 * fRec320[0]) + (fConst1771 * fRec320[1])) + (fConst1739 * fRec320[2]))))));
			fVbargraph46 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec319[0])))));
			fRec332[0] = (fTemp46 - (fConst1788 * ((fConst1791 * fRec332[2]) + (fConst1792 * fRec332[1]))));
			fRec331[0] = ((fConst1788 * (((fConst1790 * fRec332[0]) + (fConst1793 * fRec332[1])) + (fConst1790 * fRec332[2]))) - (fConst1786 * ((fConst1794 * fRec331[2]) + (fConst1795 * fRec331[1]))));
			fRec330[0] = ((fConst1786 * (((fConst1787 * fRec331[0]) + (fConst1796 * fRec331[1])) + (fConst1787 * fRec331[2]))) - (fConst1784 * ((fConst1797 * fRec330[2]) + (fConst1798 * fRec330[1]))));
			float fTemp47 = (fConst1784 * (((fConst1785 * fRec330[0]) + (fConst1799 * fRec330[1])) + (fConst1785 * fRec330[2])));
			fRec329[0] = (fTemp47 - (fConst1781 * ((fConst1800 * fRec329[2]) + (fConst1802 * fRec329[1]))));
			fRec328[0] = ((fConst1781 * (((fConst1783 * fRec329[0]) + (fConst1803 * fRec329[1])) + (fConst1783 * fRec329[2]))) - (fConst1778 * ((fConst1804 * fRec328[2]) + (fConst1805 * fRec328[1]))));
			fRec327[0] = ((fConst1778 * (((fConst1780 * fRec328[0]) + (fConst1806 * fRec328[1])) + (fConst1780 * fRec328[2]))) - (fConst1774 * ((fConst1807 * fRec327[2]) + (fConst1808 * fRec327[1]))));
			fRec326[0] = ((fSlow1 * fRec326[1]) + (fSlow2 * std::fabs((fConst1774 * (((fConst1777 * fRec327[0]) + (fConst1809 * fRec327[1])) + (fConst1777 * fRec327[2]))))));
			fVbargraph47 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec326[0])))));
			fRec339[0] = (fTemp47 - (fConst1826 * ((fConst1829 * fRec339[2]) + (fConst1830 * fRec339[1]))));
			fRec338[0] = ((fConst1826 * (((fConst1828 * fRec339[0]) + (fConst1831 * fRec339[1])) + (fConst1828 * fRec339[2]))) - (fConst1824 * ((fConst1832 * fRec338[2]) + (fConst1833 * fRec338[1]))));
			fRec337[0] = ((fConst1824 * (((fConst1825 * fRec338[0]) + (fConst1834 * fRec338[1])) + (fConst1825 * fRec338[2]))) - (fConst1822 * ((fConst1835 * fRec337[2]) + (fConst1836 * fRec337[1]))));
			float fTemp48 = (fConst1822 * (((fConst1823 * fRec337[0]) + (fConst1837 * fRec337[1])) + (fConst1823 * fRec337[2])));
			fRec336[0] = (fTemp48 - (fConst1819 * ((fConst1838 * fRec336[2]) + (fConst1840 * fRec336[1]))));
			fRec335[0] = ((fConst1819 * (((fConst1821 * fRec336[0]) + (fConst1841 * fRec336[1])) + (fConst1821 * fRec336[2]))) - (fConst1816 * ((fConst1842 * fRec335[2]) + (fConst1843 * fRec335[1]))));
			fRec334[0] = ((fConst1816 * (((fConst1818 * fRec335[0]) + (fConst1844 * fRec335[1])) + (fConst1818 * fRec335[2]))) - (fConst1812 * ((fConst1845 * fRec334[2]) + (fConst1846 * fRec334[1]))));
			fRec333[0] = ((fSlow1 * fRec333[1]) + (fSlow2 * std::fabs((fConst1812 * (((fConst1815 * fRec334[0]) + (fConst1847 * fRec334[1])) + (fConst1815 * fRec334[2]))))));
			fVbargraph48 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec333[0])))));
			fRec346[0] = (fTemp48 - (fConst1864 * ((fConst1867 * fRec346[2]) + (fConst1868 * fRec346[1]))));
			fRec345[0] = ((fConst1864 * (((fConst1866 * fRec346[0]) + (fConst1869 * fRec346[1])) + (fConst1866 * fRec346[2]))) - (fConst1862 * ((fConst1870 * fRec345[2]) + (fConst1871 * fRec345[1]))));
			fRec344[0] = ((fConst1862 * (((fConst1863 * fRec345[0]) + (fConst1872 * fRec345[1])) + (fConst1863 * fRec345[2]))) - (fConst1860 * ((fConst1873 * fRec344[2]) + (fConst1874 * fRec344[1]))));
			float fTemp49 = (fConst1860 * (((fConst1861 * fRec344[0]) + (fConst1875 * fRec344[1])) + (fConst1861 * fRec344[2])));
			fRec343[0] = (fTemp49 - (fConst1857 * ((fConst1876 * fRec343[2]) + (fConst1878 * fRec343[1]))));
			fRec342[0] = ((fConst1857 * (((fConst1859 * fRec343[0]) + (fConst1879 * fRec343[1])) + (fConst1859 * fRec343[2]))) - (fConst1854 * ((fConst1880 * fRec342[2]) + (fConst1881 * fRec342[1]))));
			fRec341[0] = ((fConst1854 * (((fConst1856 * fRec342[0]) + (fConst1882 * fRec342[1])) + (fConst1856 * fRec342[2]))) - (fConst1850 * ((fConst1883 * fRec341[2]) + (fConst1884 * fRec341[1]))));
			fRec340[0] = ((fSlow1 * fRec340[1]) + (fSlow2 * std::fabs((fConst1850 * (((fConst1853 * fRec341[0]) + (fConst1885 * fRec341[1])) + (fConst1853 * fRec341[2]))))));
			fVbargraph49 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec340[0])))));
			fRec353[0] = (fTemp49 - (fConst1902 * ((fConst1905 * fRec353[2]) + (fConst1906 * fRec353[1]))));
			fRec352[0] = ((fConst1902 * (((fConst1904 * fRec353[0]) + (fConst1907 * fRec353[1])) + (fConst1904 * fRec353[2]))) - (fConst1900 * ((fConst1908 * fRec352[2]) + (fConst1909 * fRec352[1]))));
			fRec351[0] = ((fConst1900 * (((fConst1901 * fRec352[0]) + (fConst1910 * fRec352[1])) + (fConst1901 * fRec352[2]))) - (fConst1898 * ((fConst1911 * fRec351[2]) + (fConst1912 * fRec351[1]))));
			float fTemp50 = (fConst1898 * (((fConst1899 * fRec351[0]) + (fConst1913 * fRec351[1])) + (fConst1899 * fRec351[2])));
			fRec350[0] = (fTemp50 - (fConst1895 * ((fConst1914 * fRec350[2]) + (fConst1916 * fRec350[1]))));
			fRec349[0] = ((fConst1895 * (((fConst1897 * fRec350[0]) + (fConst1917 * fRec350[1])) + (fConst1897 * fRec350[2]))) - (fConst1892 * ((fConst1918 * fRec349[2]) + (fConst1919 * fRec349[1]))));
			fRec348[0] = ((fConst1892 * (((fConst1894 * fRec349[0]) + (fConst1920 * fRec349[1])) + (fConst1894 * fRec349[2]))) - (fConst1888 * ((fConst1921 * fRec348[2]) + (fConst1922 * fRec348[1]))));
			fRec347[0] = ((fSlow1 * fRec347[1]) + (fSlow2 * std::fabs((fConst1888 * (((fConst1891 * fRec348[0]) + (fConst1923 * fRec348[1])) + (fConst1891 * fRec348[2]))))));
			fVbargraph50 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec347[0])))));
			fRec360[0] = (fTemp50 - (fConst1940 * ((fConst1943 * fRec360[2]) + (fConst1944 * fRec360[1]))));
			fRec359[0] = ((fConst1940 * (((fConst1942 * fRec360[0]) + (fConst1945 * fRec360[1])) + (fConst1942 * fRec360[2]))) - (fConst1938 * ((fConst1946 * fRec359[2]) + (fConst1947 * fRec359[1]))));
			fRec358[0] = ((fConst1938 * (((fConst1939 * fRec359[0]) + (fConst1948 * fRec359[1])) + (fConst1939 * fRec359[2]))) - (fConst1936 * ((fConst1949 * fRec358[2]) + (fConst1950 * fRec358[1]))));
			float fTemp51 = (fConst1936 * (((fConst1937 * fRec358[0]) + (fConst1951 * fRec358[1])) + (fConst1937 * fRec358[2])));
			fRec357[0] = (fTemp51 - (fConst1933 * ((fConst1952 * fRec357[2]) + (fConst1954 * fRec357[1]))));
			fRec356[0] = ((fConst1933 * (((fConst1935 * fRec357[0]) + (fConst1955 * fRec357[1])) + (fConst1935 * fRec357[2]))) - (fConst1930 * ((fConst1956 * fRec356[2]) + (fConst1957 * fRec356[1]))));
			fRec355[0] = ((fConst1930 * (((fConst1932 * fRec356[0]) + (fConst1958 * fRec356[1])) + (fConst1932 * fRec356[2]))) - (fConst1926 * ((fConst1959 * fRec355[2]) + (fConst1960 * fRec355[1]))));
			fRec354[0] = ((fSlow1 * fRec354[1]) + (fSlow2 * std::fabs((fConst1926 * (((fConst1929 * fRec355[0]) + (fConst1961 * fRec355[1])) + (fConst1929 * fRec355[2]))))));
			fVbargraph51 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec354[0])))));
			fRec367[0] = (fTemp51 - (fConst1978 * ((fConst1981 * fRec367[2]) + (fConst1982 * fRec367[1]))));
			fRec366[0] = ((fConst1978 * (((fConst1980 * fRec367[0]) + (fConst1983 * fRec367[1])) + (fConst1980 * fRec367[2]))) - (fConst1976 * ((fConst1984 * fRec366[2]) + (fConst1985 * fRec366[1]))));
			fRec365[0] = ((fConst1976 * (((fConst1977 * fRec366[0]) + (fConst1986 * fRec366[1])) + (fConst1977 * fRec366[2]))) - (fConst1974 * ((fConst1987 * fRec365[2]) + (fConst1988 * fRec365[1]))));
			float fTemp52 = (fConst1974 * (((fConst1975 * fRec365[0]) + (fConst1989 * fRec365[1])) + (fConst1975 * fRec365[2])));
			fRec364[0] = (fTemp52 - (fConst1971 * ((fConst1990 * fRec364[2]) + (fConst1992 * fRec364[1]))));
			fRec363[0] = ((fConst1971 * (((fConst1973 * fRec364[0]) + (fConst1993 * fRec364[1])) + (fConst1973 * fRec364[2]))) - (fConst1968 * ((fConst1994 * fRec363[2]) + (fConst1995 * fRec363[1]))));
			fRec362[0] = ((fConst1968 * (((fConst1970 * fRec363[0]) + (fConst1996 * fRec363[1])) + (fConst1970 * fRec363[2]))) - (fConst1964 * ((fConst1997 * fRec362[2]) + (fConst1998 * fRec362[1]))));
			fRec361[0] = ((fSlow1 * fRec361[1]) + (fSlow2 * std::fabs((fConst1964 * (((fConst1967 * fRec362[0]) + (fConst1999 * fRec362[1])) + (fConst1967 * fRec362[2]))))));
			fVbargraph52 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec361[0])))));
			fRec374[0] = (fTemp52 - (fConst2016 * ((fConst2019 * fRec374[2]) + (fConst2020 * fRec374[1]))));
			fRec373[0] = ((fConst2016 * (((fConst2018 * fRec374[0]) + (fConst2021 * fRec374[1])) + (fConst2018 * fRec374[2]))) - (fConst2014 * ((fConst2022 * fRec373[2]) + (fConst2023 * fRec373[1]))));
			fRec372[0] = ((fConst2014 * (((fConst2015 * fRec373[0]) + (fConst2024 * fRec373[1])) + (fConst2015 * fRec373[2]))) - (fConst2012 * ((fConst2025 * fRec372[2]) + (fConst2026 * fRec372[1]))));
			float fTemp53 = (fConst2012 * (((fConst2013 * fRec372[0]) + (fConst2027 * fRec372[1])) + (fConst2013 * fRec372[2])));
			fRec371[0] = (fTemp53 - (fConst2009 * ((fConst2028 * fRec371[2]) + (fConst2030 * fRec371[1]))));
			fRec370[0] = ((fConst2009 * (((fConst2011 * fRec371[0]) + (fConst2031 * fRec371[1])) + (fConst2011 * fRec371[2]))) - (fConst2006 * ((fConst2032 * fRec370[2]) + (fConst2033 * fRec370[1]))));
			fRec369[0] = ((fConst2006 * (((fConst2008 * fRec370[0]) + (fConst2034 * fRec370[1])) + (fConst2008 * fRec370[2]))) - (fConst2002 * ((fConst2035 * fRec369[2]) + (fConst2036 * fRec369[1]))));
			fRec368[0] = ((fSlow1 * fRec368[1]) + (fSlow2 * std::fabs((fConst2002 * (((fConst2005 * fRec369[0]) + (fConst2037 * fRec369[1])) + (fConst2005 * fRec369[2]))))));
			fVbargraph53 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec368[0])))));
			fRec381[0] = (fTemp53 - (fConst2054 * ((fConst2057 * fRec381[2]) + (fConst2058 * fRec381[1]))));
			fRec380[0] = ((fConst2054 * (((fConst2056 * fRec381[0]) + (fConst2059 * fRec381[1])) + (fConst2056 * fRec381[2]))) - (fConst2052 * ((fConst2060 * fRec380[2]) + (fConst2061 * fRec380[1]))));
			fRec379[0] = ((fConst2052 * (((fConst2053 * fRec380[0]) + (fConst2062 * fRec380[1])) + (fConst2053 * fRec380[2]))) - (fConst2050 * ((fConst2063 * fRec379[2]) + (fConst2064 * fRec379[1]))));
			float fTemp54 = (fConst2050 * (((fConst2051 * fRec379[0]) + (fConst2065 * fRec379[1])) + (fConst2051 * fRec379[2])));
			fRec378[0] = (fTemp54 - (fConst2047 * ((fConst2066 * fRec378[2]) + (fConst2068 * fRec378[1]))));
			fRec377[0] = ((fConst2047 * (((fConst2049 * fRec378[0]) + (fConst2069 * fRec378[1])) + (fConst2049 * fRec378[2]))) - (fConst2044 * ((fConst2070 * fRec377[2]) + (fConst2071 * fRec377[1]))));
			fRec376[0] = ((fConst2044 * (((fConst2046 * fRec377[0]) + (fConst2072 * fRec377[1])) + (fConst2046 * fRec377[2]))) - (fConst2040 * ((fConst2073 * fRec376[2]) + (fConst2074 * fRec376[1]))));
			fRec375[0] = ((fSlow1 * fRec375[1]) + (fSlow2 * std::fabs((fConst2040 * (((fConst2043 * fRec376[0]) + (fConst2075 * fRec376[1])) + (fConst2043 * fRec376[2]))))));
			fVbargraph54 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec375[0])))));
			fRec388[0] = (fTemp54 - (fConst2092 * ((fConst2095 * fRec388[2]) + (fConst2096 * fRec388[1]))));
			fRec387[0] = ((fConst2092 * (((fConst2094 * fRec388[0]) + (fConst2097 * fRec388[1])) + (fConst2094 * fRec388[2]))) - (fConst2090 * ((fConst2098 * fRec387[2]) + (fConst2099 * fRec387[1]))));
			fRec386[0] = ((fConst2090 * (((fConst2091 * fRec387[0]) + (fConst2100 * fRec387[1])) + (fConst2091 * fRec387[2]))) - (fConst2088 * ((fConst2101 * fRec386[2]) + (fConst2102 * fRec386[1]))));
			float fTemp55 = (fConst2088 * (((fConst2089 * fRec386[0]) + (fConst2103 * fRec386[1])) + (fConst2089 * fRec386[2])));
			fRec385[0] = (fTemp55 - (fConst2085 * ((fConst2104 * fRec385[2]) + (fConst2106 * fRec385[1]))));
			fRec384[0] = ((fConst2085 * (((fConst2087 * fRec385[0]) + (fConst2107 * fRec385[1])) + (fConst2087 * fRec385[2]))) - (fConst2082 * ((fConst2108 * fRec384[2]) + (fConst2109 * fRec384[1]))));
			fRec383[0] = ((fConst2082 * (((fConst2084 * fRec384[0]) + (fConst2110 * fRec384[1])) + (fConst2084 * fRec384[2]))) - (fConst2078 * ((fConst2111 * fRec383[2]) + (fConst2112 * fRec383[1]))));
			fRec382[0] = ((fSlow1 * fRec382[1]) + (fSlow2 * std::fabs((fConst2078 * (((fConst2081 * fRec383[0]) + (fConst2113 * fRec383[1])) + (fConst2081 * fRec383[2]))))));
			fVbargraph55 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec382[0])))));
			fRec395[0] = (fTemp55 - (fConst2130 * ((fConst2133 * fRec395[2]) + (fConst2134 * fRec395[1]))));
			fRec394[0] = ((fConst2130 * (((fConst2132 * fRec395[0]) + (fConst2135 * fRec395[1])) + (fConst2132 * fRec395[2]))) - (fConst2128 * ((fConst2136 * fRec394[2]) + (fConst2137 * fRec394[1]))));
			fRec393[0] = ((fConst2128 * (((fConst2129 * fRec394[0]) + (fConst2138 * fRec394[1])) + (fConst2129 * fRec394[2]))) - (fConst2126 * ((fConst2139 * fRec393[2]) + (fConst2140 * fRec393[1]))));
			float fTemp56 = (fConst2126 * (((fConst2127 * fRec393[0]) + (fConst2141 * fRec393[1])) + (fConst2127 * fRec393[2])));
			fRec392[0] = (fTemp56 - (fConst2123 * ((fConst2142 * fRec392[2]) + (fConst2144 * fRec392[1]))));
			fRec391[0] = ((fConst2123 * (((fConst2125 * fRec392[0]) + (fConst2145 * fRec392[1])) + (fConst2125 * fRec392[2]))) - (fConst2120 * ((fConst2146 * fRec391[2]) + (fConst2147 * fRec391[1]))));
			fRec390[0] = ((fConst2120 * (((fConst2122 * fRec391[0]) + (fConst2148 * fRec391[1])) + (fConst2122 * fRec391[2]))) - (fConst2116 * ((fConst2149 * fRec390[2]) + (fConst2150 * fRec390[1]))));
			fRec389[0] = ((fSlow1 * fRec389[1]) + (fSlow2 * std::fabs((fConst2116 * (((fConst2119 * fRec390[0]) + (fConst2151 * fRec390[1])) + (fConst2119 * fRec390[2]))))));
			fVbargraph56 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec389[0])))));
			fRec402[0] = (fTemp56 - (fConst2168 * ((fConst2171 * fRec402[2]) + (fConst2172 * fRec402[1]))));
			fRec401[0] = ((fConst2168 * (((fConst2170 * fRec402[0]) + (fConst2173 * fRec402[1])) + (fConst2170 * fRec402[2]))) - (fConst2166 * ((fConst2174 * fRec401[2]) + (fConst2175 * fRec401[1]))));
			fRec400[0] = ((fConst2166 * (((fConst2167 * fRec401[0]) + (fConst2176 * fRec401[1])) + (fConst2167 * fRec401[2]))) - (fConst2164 * ((fConst2177 * fRec400[2]) + (fConst2178 * fRec400[1]))));
			float fTemp57 = (fConst2164 * (((fConst2165 * fRec400[0]) + (fConst2179 * fRec400[1])) + (fConst2165 * fRec400[2])));
			fRec399[0] = (fTemp57 - (fConst2161 * ((fConst2180 * fRec399[2]) + (fConst2182 * fRec399[1]))));
			fRec398[0] = ((fConst2161 * (((fConst2163 * fRec399[0]) + (fConst2183 * fRec399[1])) + (fConst2163 * fRec399[2]))) - (fConst2158 * ((fConst2184 * fRec398[2]) + (fConst2185 * fRec398[1]))));
			fRec397[0] = ((fConst2158 * (((fConst2160 * fRec398[0]) + (fConst2186 * fRec398[1])) + (fConst2160 * fRec398[2]))) - (fConst2154 * ((fConst2187 * fRec397[2]) + (fConst2188 * fRec397[1]))));
			fRec396[0] = ((fSlow1 * fRec396[1]) + (fSlow2 * std::fabs((fConst2154 * (((fConst2157 * fRec397[0]) + (fConst2189 * fRec397[1])) + (fConst2157 * fRec397[2]))))));
			fVbargraph57 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec396[0])))));
			fRec409[0] = (fTemp57 - (fConst2206 * ((fConst2209 * fRec409[2]) + (fConst2210 * fRec409[1]))));
			fRec408[0] = ((fConst2206 * (((fConst2208 * fRec409[0]) + (fConst2211 * fRec409[1])) + (fConst2208 * fRec409[2]))) - (fConst2204 * ((fConst2212 * fRec408[2]) + (fConst2213 * fRec408[1]))));
			fRec407[0] = ((fConst2204 * (((fConst2205 * fRec408[0]) + (fConst2214 * fRec408[1])) + (fConst2205 * fRec408[2]))) - (fConst2202 * ((fConst2215 * fRec407[2]) + (fConst2216 * fRec407[1]))));
			float fTemp58 = (fConst2202 * (((fConst2203 * fRec407[0]) + (fConst2217 * fRec407[1])) + (fConst2203 * fRec407[2])));
			fRec406[0] = (fTemp58 - (fConst2199 * ((fConst2218 * fRec406[2]) + (fConst2220 * fRec406[1]))));
			fRec405[0] = ((fConst2199 * (((fConst2201 * fRec406[0]) + (fConst2221 * fRec406[1])) + (fConst2201 * fRec406[2]))) - (fConst2196 * ((fConst2222 * fRec405[2]) + (fConst2223 * fRec405[1]))));
			fRec404[0] = ((fConst2196 * (((fConst2198 * fRec405[0]) + (fConst2224 * fRec405[1])) + (fConst2198 * fRec405[2]))) - (fConst2192 * ((fConst2225 * fRec404[2]) + (fConst2226 * fRec404[1]))));
			fRec403[0] = ((fSlow1 * fRec403[1]) + (fSlow2 * std::fabs((fConst2192 * (((fConst2195 * fRec404[0]) + (fConst2227 * fRec404[1])) + (fConst2195 * fRec404[2]))))));
			fVbargraph58 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec403[0])))));
			fRec416[0] = (fTemp58 - (fConst2244 * ((fConst2247 * fRec416[2]) + (fConst2248 * fRec416[1]))));
			fRec415[0] = ((fConst2244 * (((fConst2246 * fRec416[0]) + (fConst2249 * fRec416[1])) + (fConst2246 * fRec416[2]))) - (fConst2242 * ((fConst2250 * fRec415[2]) + (fConst2251 * fRec415[1]))));
			fRec414[0] = ((fConst2242 * (((fConst2243 * fRec415[0]) + (fConst2252 * fRec415[1])) + (fConst2243 * fRec415[2]))) - (fConst2240 * ((fConst2253 * fRec414[2]) + (fConst2254 * fRec414[1]))));
			float fTemp59 = (fConst2240 * (((fConst2241 * fRec414[0]) + (fConst2255 * fRec414[1])) + (fConst2241 * fRec414[2])));
			fRec413[0] = (fTemp59 - (fConst2237 * ((fConst2256 * fRec413[2]) + (fConst2258 * fRec413[1]))));
			fRec412[0] = ((fConst2237 * (((fConst2239 * fRec413[0]) + (fConst2259 * fRec413[1])) + (fConst2239 * fRec413[2]))) - (fConst2234 * ((fConst2260 * fRec412[2]) + (fConst2261 * fRec412[1]))));
			fRec411[0] = ((fConst2234 * (((fConst2236 * fRec412[0]) + (fConst2262 * fRec412[1])) + (fConst2236 * fRec412[2]))) - (fConst2230 * ((fConst2263 * fRec411[2]) + (fConst2264 * fRec411[1]))));
			fRec410[0] = ((fSlow1 * fRec410[1]) + (fSlow2 * std::fabs((fConst2230 * (((fConst2233 * fRec411[0]) + (fConst2265 * fRec411[1])) + (fConst2233 * fRec411[2]))))));
			fVbargraph59 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec410[0])))));
			fRec423[0] = (fTemp59 - (fConst2282 * ((fConst2285 * fRec423[2]) + (fConst2286 * fRec423[1]))));
			fRec422[0] = ((fConst2282 * (((fConst2284 * fRec423[0]) + (fConst2287 * fRec423[1])) + (fConst2284 * fRec423[2]))) - (fConst2280 * ((fConst2288 * fRec422[2]) + (fConst2289 * fRec422[1]))));
			fRec421[0] = ((fConst2280 * (((fConst2281 * fRec422[0]) + (fConst2290 * fRec422[1])) + (fConst2281 * fRec422[2]))) - (fConst2278 * ((fConst2291 * fRec421[2]) + (fConst2292 * fRec421[1]))));
			float fTemp60 = (fConst2278 * (((fConst2279 * fRec421[0]) + (fConst2293 * fRec421[1])) + (fConst2279 * fRec421[2])));
			fRec420[0] = (fTemp60 - (fConst2275 * ((fConst2294 * fRec420[2]) + (fConst2296 * fRec420[1]))));
			fRec419[0] = ((fConst2275 * (((fConst2277 * fRec420[0]) + (fConst2297 * fRec420[1])) + (fConst2277 * fRec420[2]))) - (fConst2272 * ((fConst2298 * fRec419[2]) + (fConst2299 * fRec419[1]))));
			fRec418[0] = ((fConst2272 * (((fConst2274 * fRec419[0]) + (fConst2300 * fRec419[1])) + (fConst2274 * fRec419[2]))) - (fConst2268 * ((fConst2301 * fRec418[2]) + (fConst2302 * fRec418[1]))));
			fRec417[0] = ((fSlow1 * fRec417[1]) + (fSlow2 * std::fabs((fConst2268 * (((fConst2271 * fRec418[0]) + (fConst2303 * fRec418[1])) + (fConst2271 * fRec418[2]))))));
			fVbargraph60 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec417[0])))));
			fRec430[0] = (fTemp60 - (fConst2320 * ((fConst2323 * fRec430[2]) + (fConst2324 * fRec430[1]))));
			fRec429[0] = ((fConst2320 * (((fConst2322 * fRec430[0]) + (fConst2325 * fRec430[1])) + (fConst2322 * fRec430[2]))) - (fConst2318 * ((fConst2326 * fRec429[2]) + (fConst2327 * fRec429[1]))));
			fRec428[0] = ((fConst2318 * (((fConst2319 * fRec429[0]) + (fConst2328 * fRec429[1])) + (fConst2319 * fRec429[2]))) - (fConst2316 * ((fConst2329 * fRec428[2]) + (fConst2330 * fRec428[1]))));
			float fTemp61 = (fConst2316 * (((fConst2317 * fRec428[0]) + (fConst2331 * fRec428[1])) + (fConst2317 * fRec428[2])));
			fRec427[0] = (fTemp61 - (fConst2313 * ((fConst2332 * fRec427[2]) + (fConst2334 * fRec427[1]))));
			fRec426[0] = ((fConst2313 * (((fConst2315 * fRec427[0]) + (fConst2335 * fRec427[1])) + (fConst2315 * fRec427[2]))) - (fConst2310 * ((fConst2336 * fRec426[2]) + (fConst2337 * fRec426[1]))));
			fRec425[0] = ((fConst2310 * (((fConst2312 * fRec426[0]) + (fConst2338 * fRec426[1])) + (fConst2312 * fRec426[2]))) - (fConst2306 * ((fConst2339 * fRec425[2]) + (fConst2340 * fRec425[1]))));
			fRec424[0] = ((fSlow1 * fRec424[1]) + (fSlow2 * std::fabs((fConst2306 * (((fConst2309 * fRec425[0]) + (fConst2341 * fRec425[1])) + (fConst2309 * fRec425[2]))))));
			fVbargraph61 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec424[0])))));
			fRec437[0] = (fTemp61 - (fConst2358 * ((fConst2361 * fRec437[2]) + (fConst2362 * fRec437[1]))));
			fRec436[0] = ((fConst2358 * (((fConst2360 * fRec437[0]) + (fConst2363 * fRec437[1])) + (fConst2360 * fRec437[2]))) - (fConst2356 * ((fConst2364 * fRec436[2]) + (fConst2365 * fRec436[1]))));
			fRec435[0] = ((fConst2356 * (((fConst2357 * fRec436[0]) + (fConst2366 * fRec436[1])) + (fConst2357 * fRec436[2]))) - (fConst2354 * ((fConst2367 * fRec435[2]) + (fConst2368 * fRec435[1]))));
			float fTemp62 = (fConst2354 * (((fConst2355 * fRec435[0]) + (fConst2369 * fRec435[1])) + (fConst2355 * fRec435[2])));
			fRec434[0] = (fTemp62 - (fConst2351 * ((fConst2370 * fRec434[2]) + (fConst2372 * fRec434[1]))));
			fRec433[0] = ((fConst2351 * (((fConst2353 * fRec434[0]) + (fConst2373 * fRec434[1])) + (fConst2353 * fRec434[2]))) - (fConst2348 * ((fConst2374 * fRec433[2]) + (fConst2375 * fRec433[1]))));
			fRec432[0] = ((fConst2348 * (((fConst2350 * fRec433[0]) + (fConst2376 * fRec433[1])) + (fConst2350 * fRec433[2]))) - (fConst2344 * ((fConst2377 * fRec432[2]) + (fConst2378 * fRec432[1]))));
			fRec431[0] = ((fSlow1 * fRec431[1]) + (fSlow2 * std::fabs((fConst2344 * (((fConst2347 * fRec432[0]) + (fConst2379 * fRec432[1])) + (fConst2347 * fRec432[2]))))));
			fVbargraph62 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec431[0])))));
			fRec444[0] = (fTemp62 - (fConst2396 * ((fConst2399 * fRec444[2]) + (fConst2400 * fRec444[1]))));
			fRec443[0] = ((fConst2396 * (((fConst2398 * fRec444[0]) + (fConst2401 * fRec444[1])) + (fConst2398 * fRec444[2]))) - (fConst2394 * ((fConst2402 * fRec443[2]) + (fConst2403 * fRec443[1]))));
			fRec442[0] = ((fConst2394 * (((fConst2395 * fRec443[0]) + (fConst2404 * fRec443[1])) + (fConst2395 * fRec443[2]))) - (fConst2392 * ((fConst2405 * fRec442[2]) + (fConst2406 * fRec442[1]))));
			float fTemp63 = (fConst2392 * (((fConst2393 * fRec442[0]) + (fConst2407 * fRec442[1])) + (fConst2393 * fRec442[2])));
			fRec441[0] = (fTemp63 - (fConst2389 * ((fConst2408 * fRec441[2]) + (fConst2410 * fRec441[1]))));
			fRec440[0] = ((fConst2389 * (((fConst2391 * fRec441[0]) + (fConst2411 * fRec441[1])) + (fConst2391 * fRec441[2]))) - (fConst2386 * ((fConst2412 * fRec440[2]) + (fConst2413 * fRec440[1]))));
			fRec439[0] = ((fConst2386 * (((fConst2388 * fRec440[0]) + (fConst2414 * fRec440[1])) + (fConst2388 * fRec440[2]))) - (fConst2382 * ((fConst2415 * fRec439[2]) + (fConst2416 * fRec439[1]))));
			fRec438[0] = ((fSlow1 * fRec438[1]) + (fSlow2 * std::fabs((fConst2382 * (((fConst2385 * fRec439[0]) + (fConst2417 * fRec439[1])) + (fConst2385 * fRec439[2]))))));
			fVbargraph63 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec438[0])))));
			fRec451[0] = (fTemp63 - (fConst2434 * ((fConst2437 * fRec451[2]) + (fConst2438 * fRec451[1]))));
			fRec450[0] = ((fConst2434 * (((fConst2436 * fRec451[0]) + (fConst2439 * fRec451[1])) + (fConst2436 * fRec451[2]))) - (fConst2432 * ((fConst2440 * fRec450[2]) + (fConst2441 * fRec450[1]))));
			fRec449[0] = ((fConst2432 * (((fConst2433 * fRec450[0]) + (fConst2442 * fRec450[1])) + (fConst2433 * fRec450[2]))) - (fConst2430 * ((fConst2443 * fRec449[2]) + (fConst2444 * fRec449[1]))));
			float fTemp64 = (fConst2430 * (((fConst2431 * fRec449[0]) + (fConst2445 * fRec449[1])) + (fConst2431 * fRec449[2])));
			fRec448[0] = (fTemp64 - (fConst2427 * ((fConst2446 * fRec448[2]) + (fConst2448 * fRec448[1]))));
			fRec447[0] = ((fConst2427 * (((fConst2429 * fRec448[0]) + (fConst2449 * fRec448[1])) + (fConst2429 * fRec448[2]))) - (fConst2424 * ((fConst2450 * fRec447[2]) + (fConst2451 * fRec447[1]))));
			fRec446[0] = ((fConst2424 * (((fConst2426 * fRec447[0]) + (fConst2452 * fRec447[1])) + (fConst2426 * fRec447[2]))) - (fConst2420 * ((fConst2453 * fRec446[2]) + (fConst2454 * fRec446[1]))));
			fRec445[0] = ((fSlow1 * fRec445[1]) + (fSlow2 * std::fabs((fConst2420 * (((fConst2423 * fRec446[0]) + (fConst2455 * fRec446[1])) + (fConst2423 * fRec446[2]))))));
			fVbargraph64 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec445[0])))));
			fRec458[0] = (fTemp64 - (fConst2472 * ((fConst2475 * fRec458[2]) + (fConst2476 * fRec458[1]))));
			fRec457[0] = ((fConst2472 * (((fConst2474 * fRec458[0]) + (fConst2477 * fRec458[1])) + (fConst2474 * fRec458[2]))) - (fConst2470 * ((fConst2478 * fRec457[2]) + (fConst2479 * fRec457[1]))));
			fRec456[0] = ((fConst2470 * (((fConst2471 * fRec457[0]) + (fConst2480 * fRec457[1])) + (fConst2471 * fRec457[2]))) - (fConst2468 * ((fConst2481 * fRec456[2]) + (fConst2482 * fRec456[1]))));
			float fTemp65 = (fConst2468 * (((fConst2469 * fRec456[0]) + (fConst2483 * fRec456[1])) + (fConst2469 * fRec456[2])));
			fRec455[0] = (fTemp65 - (fConst2465 * ((fConst2484 * fRec455[2]) + (fConst2486 * fRec455[1]))));
			fRec454[0] = ((fConst2465 * (((fConst2467 * fRec455[0]) + (fConst2487 * fRec455[1])) + (fConst2467 * fRec455[2]))) - (fConst2462 * ((fConst2488 * fRec454[2]) + (fConst2489 * fRec454[1]))));
			fRec453[0] = ((fConst2462 * (((fConst2464 * fRec454[0]) + (fConst2490 * fRec454[1])) + (fConst2464 * fRec454[2]))) - (fConst2458 * ((fConst2491 * fRec453[2]) + (fConst2492 * fRec453[1]))));
			fRec452[0] = ((fSlow1 * fRec452[1]) + (fSlow2 * std::fabs((fConst2458 * (((fConst2461 * fRec453[0]) + (fConst2493 * fRec453[1])) + (fConst2461 * fRec453[2]))))));
			fVbargraph65 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec452[0])))));
			fRec465[0] = (fTemp65 - (fConst2510 * ((fConst2513 * fRec465[2]) + (fConst2514 * fRec465[1]))));
			fRec464[0] = ((fConst2510 * (((fConst2512 * fRec465[0]) + (fConst2515 * fRec465[1])) + (fConst2512 * fRec465[2]))) - (fConst2508 * ((fConst2516 * fRec464[2]) + (fConst2517 * fRec464[1]))));
			fRec463[0] = ((fConst2508 * (((fConst2509 * fRec464[0]) + (fConst2518 * fRec464[1])) + (fConst2509 * fRec464[2]))) - (fConst2506 * ((fConst2519 * fRec463[2]) + (fConst2520 * fRec463[1]))));
			float fTemp66 = (fConst2506 * (((fConst2507 * fRec463[0]) + (fConst2521 * fRec463[1])) + (fConst2507 * fRec463[2])));
			fRec462[0] = (fTemp66 - (fConst2503 * ((fConst2522 * fRec462[2]) + (fConst2524 * fRec462[1]))));
			fRec461[0] = ((fConst2503 * (((fConst2505 * fRec462[0]) + (fConst2525 * fRec462[1])) + (fConst2505 * fRec462[2]))) - (fConst2500 * ((fConst2526 * fRec461[2]) + (fConst2527 * fRec461[1]))));
			fRec460[0] = ((fConst2500 * (((fConst2502 * fRec461[0]) + (fConst2528 * fRec461[1])) + (fConst2502 * fRec461[2]))) - (fConst2496 * ((fConst2529 * fRec460[2]) + (fConst2530 * fRec460[1]))));
			fRec459[0] = ((fSlow1 * fRec459[1]) + (fSlow2 * std::fabs((fConst2496 * (((fConst2499 * fRec460[0]) + (fConst2531 * fRec460[1])) + (fConst2499 * fRec460[2]))))));
			fVbargraph66 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec459[0])))));
			fRec472[0] = (fTemp66 - (fConst2548 * ((fConst2551 * fRec472[2]) + (fConst2552 * fRec472[1]))));
			fRec471[0] = ((fConst2548 * (((fConst2550 * fRec472[0]) + (fConst2553 * fRec472[1])) + (fConst2550 * fRec472[2]))) - (fConst2546 * ((fConst2554 * fRec471[2]) + (fConst2555 * fRec471[1]))));
			fRec470[0] = ((fConst2546 * (((fConst2547 * fRec471[0]) + (fConst2556 * fRec471[1])) + (fConst2547 * fRec471[2]))) - (fConst2544 * ((fConst2557 * fRec470[2]) + (fConst2558 * fRec470[1]))));
			float fTemp67 = (fConst2544 * (((fConst2545 * fRec470[0]) + (fConst2559 * fRec470[1])) + (fConst2545 * fRec470[2])));
			fRec469[0] = (fTemp67 - (fConst2541 * ((fConst2560 * fRec469[2]) + (fConst2562 * fRec469[1]))));
			fRec468[0] = ((fConst2541 * (((fConst2543 * fRec469[0]) + (fConst2563 * fRec469[1])) + (fConst2543 * fRec469[2]))) - (fConst2538 * ((fConst2564 * fRec468[2]) + (fConst2565 * fRec468[1]))));
			fRec467[0] = ((fConst2538 * (((fConst2540 * fRec468[0]) + (fConst2566 * fRec468[1])) + (fConst2540 * fRec468[2]))) - (fConst2534 * ((fConst2567 * fRec467[2]) + (fConst2568 * fRec467[1]))));
			fRec466[0] = ((fSlow1 * fRec466[1]) + (fSlow2 * std::fabs((fConst2534 * (((fConst2537 * fRec467[0]) + (fConst2569 * fRec467[1])) + (fConst2537 * fRec467[2]))))));
			fVbargraph67 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec466[0])))));
			fRec479[0] = (fTemp67 - (fConst2586 * ((fConst2589 * fRec479[2]) + (fConst2590 * fRec479[1]))));
			fRec478[0] = ((fConst2586 * (((fConst2588 * fRec479[0]) + (fConst2591 * fRec479[1])) + (fConst2588 * fRec479[2]))) - (fConst2584 * ((fConst2592 * fRec478[2]) + (fConst2593 * fRec478[1]))));
			fRec477[0] = ((fConst2584 * (((fConst2585 * fRec478[0]) + (fConst2594 * fRec478[1])) + (fConst2585 * fRec478[2]))) - (fConst2582 * ((fConst2595 * fRec477[2]) + (fConst2596 * fRec477[1]))));
			float fTemp68 = (fConst2582 * (((fConst2583 * fRec477[0]) + (fConst2597 * fRec477[1])) + (fConst2583 * fRec477[2])));
			fRec476[0] = (fTemp68 - (fConst2579 * ((fConst2598 * fRec476[2]) + (fConst2600 * fRec476[1]))));
			fRec475[0] = ((fConst2579 * (((fConst2581 * fRec476[0]) + (fConst2601 * fRec476[1])) + (fConst2581 * fRec476[2]))) - (fConst2576 * ((fConst2602 * fRec475[2]) + (fConst2603 * fRec475[1]))));
			fRec474[0] = ((fConst2576 * (((fConst2578 * fRec475[0]) + (fConst2604 * fRec475[1])) + (fConst2578 * fRec475[2]))) - (fConst2572 * ((fConst2605 * fRec474[2]) + (fConst2606 * fRec474[1]))));
			fRec473[0] = ((fSlow1 * fRec473[1]) + (fSlow2 * std::fabs((fConst2572 * (((fConst2575 * fRec474[0]) + (fConst2607 * fRec474[1])) + (fConst2575 * fRec474[2]))))));
			fVbargraph68 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec473[0])))));
			fRec486[0] = (fTemp68 - (fConst2624 * ((fConst2627 * fRec486[2]) + (fConst2628 * fRec486[1]))));
			fRec485[0] = ((fConst2624 * (((fConst2626 * fRec486[0]) + (fConst2629 * fRec486[1])) + (fConst2626 * fRec486[2]))) - (fConst2622 * ((fConst2630 * fRec485[2]) + (fConst2631 * fRec485[1]))));
			fRec484[0] = ((fConst2622 * (((fConst2623 * fRec485[0]) + (fConst2632 * fRec485[1])) + (fConst2623 * fRec485[2]))) - (fConst2620 * ((fConst2633 * fRec484[2]) + (fConst2634 * fRec484[1]))));
			float fTemp69 = (fConst2620 * (((fConst2621 * fRec484[0]) + (fConst2635 * fRec484[1])) + (fConst2621 * fRec484[2])));
			fRec483[0] = (fTemp69 - (fConst2617 * ((fConst2636 * fRec483[2]) + (fConst2638 * fRec483[1]))));
			fRec482[0] = ((fConst2617 * (((fConst2619 * fRec483[0]) + (fConst2639 * fRec483[1])) + (fConst2619 * fRec483[2]))) - (fConst2614 * ((fConst2640 * fRec482[2]) + (fConst2641 * fRec482[1]))));
			fRec481[0] = ((fConst2614 * (((fConst2616 * fRec482[0]) + (fConst2642 * fRec482[1])) + (fConst2616 * fRec482[2]))) - (fConst2610 * ((fConst2643 * fRec481[2]) + (fConst2644 * fRec481[1]))));
			fRec480[0] = ((fSlow1 * fRec480[1]) + (fSlow2 * std::fabs((fConst2610 * (((fConst2613 * fRec481[0]) + (fConst2645 * fRec481[1])) + (fConst2613 * fRec481[2]))))));
			fVbargraph69 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec480[0])))));
			fRec493[0] = (fTemp69 - (fConst2662 * ((fConst2665 * fRec493[2]) + (fConst2666 * fRec493[1]))));
			fRec492[0] = ((fConst2662 * (((fConst2664 * fRec493[0]) + (fConst2667 * fRec493[1])) + (fConst2664 * fRec493[2]))) - (fConst2660 * ((fConst2668 * fRec492[2]) + (fConst2669 * fRec492[1]))));
			fRec491[0] = ((fConst2660 * (((fConst2661 * fRec492[0]) + (fConst2670 * fRec492[1])) + (fConst2661 * fRec492[2]))) - (fConst2658 * ((fConst2671 * fRec491[2]) + (fConst2672 * fRec491[1]))));
			float fTemp70 = (fConst2658 * (((fConst2659 * fRec491[0]) + (fConst2673 * fRec491[1])) + (fConst2659 * fRec491[2])));
			fRec490[0] = (fTemp70 - (fConst2655 * ((fConst2674 * fRec490[2]) + (fConst2676 * fRec490[1]))));
			fRec489[0] = ((fConst2655 * (((fConst2657 * fRec490[0]) + (fConst2677 * fRec490[1])) + (fConst2657 * fRec490[2]))) - (fConst2652 * ((fConst2678 * fRec489[2]) + (fConst2679 * fRec489[1]))));
			fRec488[0] = ((fConst2652 * (((fConst2654 * fRec489[0]) + (fConst2680 * fRec489[1])) + (fConst2654 * fRec489[2]))) - (fConst2648 * ((fConst2681 * fRec488[2]) + (fConst2682 * fRec488[1]))));
			fRec487[0] = ((fSlow1 * fRec487[1]) + (fSlow2 * std::fabs((fConst2648 * (((fConst2651 * fRec488[0]) + (fConst2683 * fRec488[1])) + (fConst2651 * fRec488[2]))))));
			fVbargraph70 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec487[0])))));
			fRec500[0] = (fTemp70 - (fConst2700 * ((fConst2703 * fRec500[2]) + (fConst2704 * fRec500[1]))));
			fRec499[0] = ((fConst2700 * (((fConst2702 * fRec500[0]) + (fConst2705 * fRec500[1])) + (fConst2702 * fRec500[2]))) - (fConst2698 * ((fConst2706 * fRec499[2]) + (fConst2707 * fRec499[1]))));
			fRec498[0] = ((fConst2698 * (((fConst2699 * fRec499[0]) + (fConst2708 * fRec499[1])) + (fConst2699 * fRec499[2]))) - (fConst2696 * ((fConst2709 * fRec498[2]) + (fConst2710 * fRec498[1]))));
			float fTemp71 = (fConst2696 * (((fConst2697 * fRec498[0]) + (fConst2711 * fRec498[1])) + (fConst2697 * fRec498[2])));
			fRec497[0] = (fTemp71 - (fConst2693 * ((fConst2712 * fRec497[2]) + (fConst2714 * fRec497[1]))));
			fRec496[0] = ((fConst2693 * (((fConst2695 * fRec497[0]) + (fConst2715 * fRec497[1])) + (fConst2695 * fRec497[2]))) - (fConst2690 * ((fConst2716 * fRec496[2]) + (fConst2717 * fRec496[1]))));
			fRec495[0] = ((fConst2690 * (((fConst2692 * fRec496[0]) + (fConst2718 * fRec496[1])) + (fConst2692 * fRec496[2]))) - (fConst2686 * ((fConst2719 * fRec495[2]) + (fConst2720 * fRec495[1]))));
			fRec494[0] = ((fSlow1 * fRec494[1]) + (fSlow2 * std::fabs((fConst2686 * (((fConst2689 * fRec495[0]) + (fConst2721 * fRec495[1])) + (fConst2689 * fRec495[2]))))));
			fVbargraph71 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec494[0])))));
			fRec507[0] = (fTemp71 - (fConst2738 * ((fConst2741 * fRec507[2]) + (fConst2742 * fRec507[1]))));
			fRec506[0] = ((fConst2738 * (((fConst2740 * fRec507[0]) + (fConst2743 * fRec507[1])) + (fConst2740 * fRec507[2]))) - (fConst2736 * ((fConst2744 * fRec506[2]) + (fConst2745 * fRec506[1]))));
			fRec505[0] = ((fConst2736 * (((fConst2737 * fRec506[0]) + (fConst2746 * fRec506[1])) + (fConst2737 * fRec506[2]))) - (fConst2734 * ((fConst2747 * fRec505[2]) + (fConst2748 * fRec505[1]))));
			float fTemp72 = (fConst2734 * (((fConst2735 * fRec505[0]) + (fConst2749 * fRec505[1])) + (fConst2735 * fRec505[2])));
			fRec504[0] = (fTemp72 - (fConst2731 * ((fConst2750 * fRec504[2]) + (fConst2752 * fRec504[1]))));
			fRec503[0] = ((fConst2731 * (((fConst2733 * fRec504[0]) + (fConst2753 * fRec504[1])) + (fConst2733 * fRec504[2]))) - (fConst2728 * ((fConst2754 * fRec503[2]) + (fConst2755 * fRec503[1]))));
			fRec502[0] = ((fConst2728 * (((fConst2730 * fRec503[0]) + (fConst2756 * fRec503[1])) + (fConst2730 * fRec503[2]))) - (fConst2724 * ((fConst2757 * fRec502[2]) + (fConst2758 * fRec502[1]))));
			fRec501[0] = ((fSlow1 * fRec501[1]) + (fSlow2 * std::fabs((fConst2724 * (((fConst2727 * fRec502[0]) + (fConst2759 * fRec502[1])) + (fConst2727 * fRec502[2]))))));
			fVbargraph72 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec501[0])))));
			fRec514[0] = (fTemp72 - (fConst2776 * ((fConst2779 * fRec514[2]) + (fConst2780 * fRec514[1]))));
			fRec513[0] = ((fConst2776 * (((fConst2778 * fRec514[0]) + (fConst2781 * fRec514[1])) + (fConst2778 * fRec514[2]))) - (fConst2774 * ((fConst2782 * fRec513[2]) + (fConst2783 * fRec513[1]))));
			fRec512[0] = ((fConst2774 * (((fConst2775 * fRec513[0]) + (fConst2784 * fRec513[1])) + (fConst2775 * fRec513[2]))) - (fConst2772 * ((fConst2785 * fRec512[2]) + (fConst2786 * fRec512[1]))));
			float fTemp73 = (fConst2772 * (((fConst2773 * fRec512[0]) + (fConst2787 * fRec512[1])) + (fConst2773 * fRec512[2])));
			fRec511[0] = (fTemp73 - (fConst2769 * ((fConst2788 * fRec511[2]) + (fConst2790 * fRec511[1]))));
			fRec510[0] = ((fConst2769 * (((fConst2771 * fRec511[0]) + (fConst2791 * fRec511[1])) + (fConst2771 * fRec511[2]))) - (fConst2766 * ((fConst2792 * fRec510[2]) + (fConst2793 * fRec510[1]))));
			fRec509[0] = ((fConst2766 * (((fConst2768 * fRec510[0]) + (fConst2794 * fRec510[1])) + (fConst2768 * fRec510[2]))) - (fConst2762 * ((fConst2795 * fRec509[2]) + (fConst2796 * fRec509[1]))));
			fRec508[0] = ((fSlow1 * fRec508[1]) + (fSlow2 * std::fabs((fConst2762 * (((fConst2765 * fRec509[0]) + (fConst2797 * fRec509[1])) + (fConst2765 * fRec509[2]))))));
			fVbargraph73 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec508[0])))));
			fRec521[0] = (fTemp73 - (fConst2814 * ((fConst2817 * fRec521[2]) + (fConst2818 * fRec521[1]))));
			fRec520[0] = ((fConst2814 * (((fConst2816 * fRec521[0]) + (fConst2819 * fRec521[1])) + (fConst2816 * fRec521[2]))) - (fConst2812 * ((fConst2820 * fRec520[2]) + (fConst2821 * fRec520[1]))));
			fRec519[0] = ((fConst2812 * (((fConst2813 * fRec520[0]) + (fConst2822 * fRec520[1])) + (fConst2813 * fRec520[2]))) - (fConst2810 * ((fConst2823 * fRec519[2]) + (fConst2824 * fRec519[1]))));
			float fTemp74 = (fConst2810 * (((fConst2811 * fRec519[0]) + (fConst2825 * fRec519[1])) + (fConst2811 * fRec519[2])));
			fRec518[0] = (fTemp74 - (fConst2807 * ((fConst2826 * fRec518[2]) + (fConst2828 * fRec518[1]))));
			fRec517[0] = ((fConst2807 * (((fConst2809 * fRec518[0]) + (fConst2829 * fRec518[1])) + (fConst2809 * fRec518[2]))) - (fConst2804 * ((fConst2830 * fRec517[2]) + (fConst2831 * fRec517[1]))));
			fRec516[0] = ((fConst2804 * (((fConst2806 * fRec517[0]) + (fConst2832 * fRec517[1])) + (fConst2806 * fRec517[2]))) - (fConst2800 * ((fConst2833 * fRec516[2]) + (fConst2834 * fRec516[1]))));
			fRec515[0] = ((fSlow1 * fRec515[1]) + (fSlow2 * std::fabs((fConst2800 * (((fConst2803 * fRec516[0]) + (fConst2835 * fRec516[1])) + (fConst2803 * fRec516[2]))))));
			fVbargraph74 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec515[0])))));
			fRec528[0] = (fTemp74 - (fConst2852 * ((fConst2855 * fRec528[2]) + (fConst2856 * fRec528[1]))));
			fRec527[0] = ((fConst2852 * (((fConst2854 * fRec528[0]) + (fConst2857 * fRec528[1])) + (fConst2854 * fRec528[2]))) - (fConst2850 * ((fConst2858 * fRec527[2]) + (fConst2859 * fRec527[1]))));
			fRec526[0] = ((fConst2850 * (((fConst2851 * fRec527[0]) + (fConst2860 * fRec527[1])) + (fConst2851 * fRec527[2]))) - (fConst2848 * ((fConst2861 * fRec526[2]) + (fConst2862 * fRec526[1]))));
			float fTemp75 = (fConst2848 * (((fConst2849 * fRec526[0]) + (fConst2863 * fRec526[1])) + (fConst2849 * fRec526[2])));
			fRec525[0] = (fTemp75 - (fConst2845 * ((fConst2864 * fRec525[2]) + (fConst2866 * fRec525[1]))));
			fRec524[0] = ((fConst2845 * (((fConst2847 * fRec525[0]) + (fConst2867 * fRec525[1])) + (fConst2847 * fRec525[2]))) - (fConst2842 * ((fConst2868 * fRec524[2]) + (fConst2869 * fRec524[1]))));
			fRec523[0] = ((fConst2842 * (((fConst2844 * fRec524[0]) + (fConst2870 * fRec524[1])) + (fConst2844 * fRec524[2]))) - (fConst2838 * ((fConst2871 * fRec523[2]) + (fConst2872 * fRec523[1]))));
			fRec522[0] = ((fSlow1 * fRec522[1]) + (fSlow2 * std::fabs((fConst2838 * (((fConst2841 * fRec523[0]) + (fConst2873 * fRec523[1])) + (fConst2841 * fRec523[2]))))));
			fVbargraph75 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec522[0])))));
			fRec535[0] = (fTemp75 - (fConst2890 * ((fConst2893 * fRec535[2]) + (fConst2894 * fRec535[1]))));
			fRec534[0] = ((fConst2890 * (((fConst2892 * fRec535[0]) + (fConst2895 * fRec535[1])) + (fConst2892 * fRec535[2]))) - (fConst2888 * ((fConst2896 * fRec534[2]) + (fConst2897 * fRec534[1]))));
			fRec533[0] = ((fConst2888 * (((fConst2889 * fRec534[0]) + (fConst2898 * fRec534[1])) + (fConst2889 * fRec534[2]))) - (fConst2886 * ((fConst2899 * fRec533[2]) + (fConst2900 * fRec533[1]))));
			float fTemp76 = (fConst2886 * (((fConst2887 * fRec533[0]) + (fConst2901 * fRec533[1])) + (fConst2887 * fRec533[2])));
			fRec532[0] = (fTemp76 - (fConst2883 * ((fConst2902 * fRec532[2]) + (fConst2904 * fRec532[1]))));
			fRec531[0] = ((fConst2883 * (((fConst2885 * fRec532[0]) + (fConst2905 * fRec532[1])) + (fConst2885 * fRec532[2]))) - (fConst2880 * ((fConst2906 * fRec531[2]) + (fConst2907 * fRec531[1]))));
			fRec530[0] = ((fConst2880 * (((fConst2882 * fRec531[0]) + (fConst2908 * fRec531[1])) + (fConst2882 * fRec531[2]))) - (fConst2876 * ((fConst2909 * fRec530[2]) + (fConst2910 * fRec530[1]))));
			fRec529[0] = ((fSlow1 * fRec529[1]) + (fSlow2 * std::fabs((fConst2876 * (((fConst2879 * fRec530[0]) + (fConst2911 * fRec530[1])) + (fConst2879 * fRec530[2]))))));
			fVbargraph76 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec529[0])))));
			fRec542[0] = (fTemp76 - (fConst2928 * ((fConst2931 * fRec542[2]) + (fConst2932 * fRec542[1]))));
			fRec541[0] = ((fConst2928 * (((fConst2930 * fRec542[0]) + (fConst2933 * fRec542[1])) + (fConst2930 * fRec542[2]))) - (fConst2926 * ((fConst2934 * fRec541[2]) + (fConst2935 * fRec541[1]))));
			fRec540[0] = ((fConst2926 * (((fConst2927 * fRec541[0]) + (fConst2936 * fRec541[1])) + (fConst2927 * fRec541[2]))) - (fConst2924 * ((fConst2937 * fRec540[2]) + (fConst2938 * fRec540[1]))));
			float fTemp77 = (fConst2924 * (((fConst2925 * fRec540[0]) + (fConst2939 * fRec540[1])) + (fConst2925 * fRec540[2])));
			fRec539[0] = (fTemp77 - (fConst2921 * ((fConst2940 * fRec539[2]) + (fConst2942 * fRec539[1]))));
			fRec538[0] = ((fConst2921 * (((fConst2923 * fRec539[0]) + (fConst2943 * fRec539[1])) + (fConst2923 * fRec539[2]))) - (fConst2918 * ((fConst2944 * fRec538[2]) + (fConst2945 * fRec538[1]))));
			fRec537[0] = ((fConst2918 * (((fConst2920 * fRec538[0]) + (fConst2946 * fRec538[1])) + (fConst2920 * fRec538[2]))) - (fConst2914 * ((fConst2947 * fRec537[2]) + (fConst2948 * fRec537[1]))));
			fRec536[0] = ((fSlow1 * fRec536[1]) + (fSlow2 * std::fabs((fConst2914 * (((fConst2917 * fRec537[0]) + (fConst2949 * fRec537[1])) + (fConst2917 * fRec537[2]))))));
			fVbargraph77 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec536[0])))));
			fRec549[0] = (fTemp77 - (fConst2966 * ((fConst2969 * fRec549[2]) + (fConst2970 * fRec549[1]))));
			fRec548[0] = ((fConst2966 * (((fConst2968 * fRec549[0]) + (fConst2971 * fRec549[1])) + (fConst2968 * fRec549[2]))) - (fConst2964 * ((fConst2972 * fRec548[2]) + (fConst2973 * fRec548[1]))));
			fRec547[0] = ((fConst2964 * (((fConst2965 * fRec548[0]) + (fConst2974 * fRec548[1])) + (fConst2965 * fRec548[2]))) - (fConst2962 * ((fConst2975 * fRec547[2]) + (fConst2976 * fRec547[1]))));
			float fTemp78 = (fConst2962 * (((fConst2963 * fRec547[0]) + (fConst2977 * fRec547[1])) + (fConst2963 * fRec547[2])));
			fRec546[0] = (fTemp78 - (fConst2959 * ((fConst2978 * fRec546[2]) + (fConst2980 * fRec546[1]))));
			fRec545[0] = ((fConst2959 * (((fConst2961 * fRec546[0]) + (fConst2981 * fRec546[1])) + (fConst2961 * fRec546[2]))) - (fConst2956 * ((fConst2982 * fRec545[2]) + (fConst2983 * fRec545[1]))));
			fRec544[0] = ((fConst2956 * (((fConst2958 * fRec545[0]) + (fConst2984 * fRec545[1])) + (fConst2958 * fRec545[2]))) - (fConst2952 * ((fConst2985 * fRec544[2]) + (fConst2986 * fRec544[1]))));
			fRec543[0] = ((fSlow1 * fRec543[1]) + (fSlow2 * std::fabs((fConst2952 * (((fConst2955 * fRec544[0]) + (fConst2987 * fRec544[1])) + (fConst2955 * fRec544[2]))))));
			fVbargraph78 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec543[0])))));
			fRec556[0] = (fTemp78 - (fConst3004 * ((fConst3007 * fRec556[2]) + (fConst3008 * fRec556[1]))));
			fRec555[0] = ((fConst3004 * (((fConst3006 * fRec556[0]) + (fConst3009 * fRec556[1])) + (fConst3006 * fRec556[2]))) - (fConst3002 * ((fConst3010 * fRec555[2]) + (fConst3011 * fRec555[1]))));
			fRec554[0] = ((fConst3002 * (((fConst3003 * fRec555[0]) + (fConst3012 * fRec555[1])) + (fConst3003 * fRec555[2]))) - (fConst3000 * ((fConst3013 * fRec554[2]) + (fConst3014 * fRec554[1]))));
			float fTemp79 = (fConst3000 * (((fConst3001 * fRec554[0]) + (fConst3015 * fRec554[1])) + (fConst3001 * fRec554[2])));
			fRec553[0] = (fTemp79 - (fConst2997 * ((fConst3016 * fRec553[2]) + (fConst3018 * fRec553[1]))));
			fRec552[0] = ((fConst2997 * (((fConst2999 * fRec553[0]) + (fConst3019 * fRec553[1])) + (fConst2999 * fRec553[2]))) - (fConst2994 * ((fConst3020 * fRec552[2]) + (fConst3021 * fRec552[1]))));
			fRec551[0] = ((fConst2994 * (((fConst2996 * fRec552[0]) + (fConst3022 * fRec552[1])) + (fConst2996 * fRec552[2]))) - (fConst2990 * ((fConst3023 * fRec551[2]) + (fConst3024 * fRec551[1]))));
			fRec550[0] = ((fSlow1 * fRec550[1]) + (fSlow2 * std::fabs((fConst2990 * (((fConst2993 * fRec551[0]) + (fConst3025 * fRec551[1])) + (fConst2993 * fRec551[2]))))));
			fVbargraph79 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec550[0])))));
			fRec563[0] = (fTemp79 - (fConst3042 * ((fConst3045 * fRec563[2]) + (fConst3046 * fRec563[1]))));
			fRec562[0] = ((fConst3042 * (((fConst3044 * fRec563[0]) + (fConst3047 * fRec563[1])) + (fConst3044 * fRec563[2]))) - (fConst3040 * ((fConst3048 * fRec562[2]) + (fConst3049 * fRec562[1]))));
			fRec561[0] = ((fConst3040 * (((fConst3041 * fRec562[0]) + (fConst3050 * fRec562[1])) + (fConst3041 * fRec562[2]))) - (fConst3038 * ((fConst3051 * fRec561[2]) + (fConst3052 * fRec561[1]))));
			float fTemp80 = (fConst3038 * (((fConst3039 * fRec561[0]) + (fConst3053 * fRec561[1])) + (fConst3039 * fRec561[2])));
			fRec560[0] = (fTemp80 - (fConst3035 * ((fConst3054 * fRec560[2]) + (fConst3056 * fRec560[1]))));
			fRec559[0] = ((fConst3035 * (((fConst3037 * fRec560[0]) + (fConst3057 * fRec560[1])) + (fConst3037 * fRec560[2]))) - (fConst3032 * ((fConst3058 * fRec559[2]) + (fConst3059 * fRec559[1]))));
			fRec558[0] = ((fConst3032 * (((fConst3034 * fRec559[0]) + (fConst3060 * fRec559[1])) + (fConst3034 * fRec559[2]))) - (fConst3028 * ((fConst3061 * fRec558[2]) + (fConst3062 * fRec558[1]))));
			fRec557[0] = ((fSlow1 * fRec557[1]) + (fSlow2 * std::fabs((fConst3028 * (((fConst3031 * fRec558[0]) + (fConst3063 * fRec558[1])) + (fConst3031 * fRec558[2]))))));
			fVbargraph80 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec557[0])))));
			fRec570[0] = (fTemp80 - (fConst3080 * ((fConst3083 * fRec570[2]) + (fConst3084 * fRec570[1]))));
			fRec569[0] = ((fConst3080 * (((fConst3082 * fRec570[0]) + (fConst3085 * fRec570[1])) + (fConst3082 * fRec570[2]))) - (fConst3078 * ((fConst3086 * fRec569[2]) + (fConst3087 * fRec569[1]))));
			fRec568[0] = ((fConst3078 * (((fConst3079 * fRec569[0]) + (fConst3088 * fRec569[1])) + (fConst3079 * fRec569[2]))) - (fConst3076 * ((fConst3089 * fRec568[2]) + (fConst3090 * fRec568[1]))));
			float fTemp81 = (fConst3076 * (((fConst3077 * fRec568[0]) + (fConst3091 * fRec568[1])) + (fConst3077 * fRec568[2])));
			fRec567[0] = (fTemp81 - (fConst3073 * ((fConst3092 * fRec567[2]) + (fConst3094 * fRec567[1]))));
			fRec566[0] = ((fConst3073 * (((fConst3075 * fRec567[0]) + (fConst3095 * fRec567[1])) + (fConst3075 * fRec567[2]))) - (fConst3070 * ((fConst3096 * fRec566[2]) + (fConst3097 * fRec566[1]))));
			fRec565[0] = ((fConst3070 * (((fConst3072 * fRec566[0]) + (fConst3098 * fRec566[1])) + (fConst3072 * fRec566[2]))) - (fConst3066 * ((fConst3099 * fRec565[2]) + (fConst3100 * fRec565[1]))));
			fRec564[0] = ((fSlow1 * fRec564[1]) + (fSlow2 * std::fabs((fConst3066 * (((fConst3069 * fRec565[0]) + (fConst3101 * fRec565[1])) + (fConst3069 * fRec565[2]))))));
			fVbargraph81 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec564[0])))));
			fRec577[0] = (fTemp81 - (fConst3118 * ((fConst3121 * fRec577[2]) + (fConst3122 * fRec577[1]))));
			fRec576[0] = ((fConst3118 * (((fConst3120 * fRec577[0]) + (fConst3123 * fRec577[1])) + (fConst3120 * fRec577[2]))) - (fConst3116 * ((fConst3124 * fRec576[2]) + (fConst3125 * fRec576[1]))));
			fRec575[0] = ((fConst3116 * (((fConst3117 * fRec576[0]) + (fConst3126 * fRec576[1])) + (fConst3117 * fRec576[2]))) - (fConst3114 * ((fConst3127 * fRec575[2]) + (fConst3128 * fRec575[1]))));
			float fTemp82 = (fConst3114 * (((fConst3115 * fRec575[0]) + (fConst3129 * fRec575[1])) + (fConst3115 * fRec575[2])));
			fRec574[0] = (fTemp82 - (fConst3111 * ((fConst3130 * fRec574[2]) + (fConst3132 * fRec574[1]))));
			fRec573[0] = ((fConst3111 * (((fConst3113 * fRec574[0]) + (fConst3133 * fRec574[1])) + (fConst3113 * fRec574[2]))) - (fConst3108 * ((fConst3134 * fRec573[2]) + (fConst3135 * fRec573[1]))));
			fRec572[0] = ((fConst3108 * (((fConst3110 * fRec573[0]) + (fConst3136 * fRec573[1])) + (fConst3110 * fRec573[2]))) - (fConst3104 * ((fConst3137 * fRec572[2]) + (fConst3138 * fRec572[1]))));
			fRec571[0] = ((fSlow1 * fRec571[1]) + (fSlow2 * std::fabs((fConst3104 * (((fConst3107 * fRec572[0]) + (fConst3139 * fRec572[1])) + (fConst3107 * fRec572[2]))))));
			fVbargraph82 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec571[0])))));
			fRec584[0] = (fTemp82 - (fConst3156 * ((fConst3159 * fRec584[2]) + (fConst3160 * fRec584[1]))));
			fRec583[0] = ((fConst3156 * (((fConst3158 * fRec584[0]) + (fConst3161 * fRec584[1])) + (fConst3158 * fRec584[2]))) - (fConst3154 * ((fConst3162 * fRec583[2]) + (fConst3163 * fRec583[1]))));
			fRec582[0] = ((fConst3154 * (((fConst3155 * fRec583[0]) + (fConst3164 * fRec583[1])) + (fConst3155 * fRec583[2]))) - (fConst3152 * ((fConst3165 * fRec582[2]) + (fConst3166 * fRec582[1]))));
			float fTemp83 = (fConst3152 * (((fConst3153 * fRec582[0]) + (fConst3167 * fRec582[1])) + (fConst3153 * fRec582[2])));
			fRec581[0] = (fTemp83 - (fConst3149 * ((fConst3168 * fRec581[2]) + (fConst3170 * fRec581[1]))));
			fRec580[0] = ((fConst3149 * (((fConst3151 * fRec581[0]) + (fConst3171 * fRec581[1])) + (fConst3151 * fRec581[2]))) - (fConst3146 * ((fConst3172 * fRec580[2]) + (fConst3173 * fRec580[1]))));
			fRec579[0] = ((fConst3146 * (((fConst3148 * fRec580[0]) + (fConst3174 * fRec580[1])) + (fConst3148 * fRec580[2]))) - (fConst3142 * ((fConst3175 * fRec579[2]) + (fConst3176 * fRec579[1]))));
			fRec578[0] = ((fSlow1 * fRec578[1]) + (fSlow2 * std::fabs((fConst3142 * (((fConst3145 * fRec579[0]) + (fConst3177 * fRec579[1])) + (fConst3145 * fRec579[2]))))));
			fVbargraph83 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec578[0])))));
			fRec591[0] = (fTemp83 - (fConst3194 * ((fConst3197 * fRec591[2]) + (fConst3198 * fRec591[1]))));
			fRec590[0] = ((fConst3194 * (((fConst3196 * fRec591[0]) + (fConst3199 * fRec591[1])) + (fConst3196 * fRec591[2]))) - (fConst3192 * ((fConst3200 * fRec590[2]) + (fConst3201 * fRec590[1]))));
			fRec589[0] = ((fConst3192 * (((fConst3193 * fRec590[0]) + (fConst3202 * fRec590[1])) + (fConst3193 * fRec590[2]))) - (fConst3190 * ((fConst3203 * fRec589[2]) + (fConst3204 * fRec589[1]))));
			float fTemp84 = (fConst3190 * (((fConst3191 * fRec589[0]) + (fConst3205 * fRec589[1])) + (fConst3191 * fRec589[2])));
			fRec588[0] = (fTemp84 - (fConst3187 * ((fConst3206 * fRec588[2]) + (fConst3208 * fRec588[1]))));
			fRec587[0] = ((fConst3187 * (((fConst3189 * fRec588[0]) + (fConst3209 * fRec588[1])) + (fConst3189 * fRec588[2]))) - (fConst3184 * ((fConst3210 * fRec587[2]) + (fConst3211 * fRec587[1]))));
			fRec586[0] = ((fConst3184 * (((fConst3186 * fRec587[0]) + (fConst3212 * fRec587[1])) + (fConst3186 * fRec587[2]))) - (fConst3180 * ((fConst3213 * fRec586[2]) + (fConst3214 * fRec586[1]))));
			fRec585[0] = ((fSlow1 * fRec585[1]) + (fSlow2 * std::fabs((fConst3180 * (((fConst3183 * fRec586[0]) + (fConst3215 * fRec586[1])) + (fConst3183 * fRec586[2]))))));
			fVbargraph84 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec585[0])))));
			fRec598[0] = (fTemp84 - (fConst3232 * ((fConst3235 * fRec598[2]) + (fConst3236 * fRec598[1]))));
			fRec597[0] = ((fConst3232 * (((fConst3234 * fRec598[0]) + (fConst3237 * fRec598[1])) + (fConst3234 * fRec598[2]))) - (fConst3230 * ((fConst3238 * fRec597[2]) + (fConst3239 * fRec597[1]))));
			fRec596[0] = ((fConst3230 * (((fConst3231 * fRec597[0]) + (fConst3240 * fRec597[1])) + (fConst3231 * fRec597[2]))) - (fConst3228 * ((fConst3241 * fRec596[2]) + (fConst3242 * fRec596[1]))));
			float fTemp85 = (fConst3228 * (((fConst3229 * fRec596[0]) + (fConst3243 * fRec596[1])) + (fConst3229 * fRec596[2])));
			fRec595[0] = (fTemp85 - (fConst3225 * ((fConst3244 * fRec595[2]) + (fConst3246 * fRec595[1]))));
			fRec594[0] = ((fConst3225 * (((fConst3227 * fRec595[0]) + (fConst3247 * fRec595[1])) + (fConst3227 * fRec595[2]))) - (fConst3222 * ((fConst3248 * fRec594[2]) + (fConst3249 * fRec594[1]))));
			fRec593[0] = ((fConst3222 * (((fConst3224 * fRec594[0]) + (fConst3250 * fRec594[1])) + (fConst3224 * fRec594[2]))) - (fConst3218 * ((fConst3251 * fRec593[2]) + (fConst3252 * fRec593[1]))));
			fRec592[0] = ((fSlow1 * fRec592[1]) + (fSlow2 * std::fabs((fConst3218 * (((fConst3221 * fRec593[0]) + (fConst3253 * fRec593[1])) + (fConst3221 * fRec593[2]))))));
			fVbargraph85 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec592[0])))));
			fRec605[0] = (fTemp85 - (fConst3270 * ((fConst3273 * fRec605[2]) + (fConst3274 * fRec605[1]))));
			fRec604[0] = ((fConst3270 * (((fConst3272 * fRec605[0]) + (fConst3275 * fRec605[1])) + (fConst3272 * fRec605[2]))) - (fConst3268 * ((fConst3276 * fRec604[2]) + (fConst3277 * fRec604[1]))));
			fRec603[0] = ((fConst3268 * (((fConst3269 * fRec604[0]) + (fConst3278 * fRec604[1])) + (fConst3269 * fRec604[2]))) - (fConst3266 * ((fConst3279 * fRec603[2]) + (fConst3280 * fRec603[1]))));
			float fTemp86 = (fConst3266 * (((fConst3267 * fRec603[0]) + (fConst3281 * fRec603[1])) + (fConst3267 * fRec603[2])));
			fRec602[0] = (fTemp86 - (fConst3263 * ((fConst3282 * fRec602[2]) + (fConst3284 * fRec602[1]))));
			fRec601[0] = ((fConst3263 * (((fConst3265 * fRec602[0]) + (fConst3285 * fRec602[1])) + (fConst3265 * fRec602[2]))) - (fConst3260 * ((fConst3286 * fRec601[2]) + (fConst3287 * fRec601[1]))));
			fRec600[0] = ((fConst3260 * (((fConst3262 * fRec601[0]) + (fConst3288 * fRec601[1])) + (fConst3262 * fRec601[2]))) - (fConst3256 * ((fConst3289 * fRec600[2]) + (fConst3290 * fRec600[1]))));
			fRec599[0] = ((fSlow1 * fRec599[1]) + (fSlow2 * std::fabs((fConst3256 * (((fConst3259 * fRec600[0]) + (fConst3291 * fRec600[1])) + (fConst3259 * fRec600[2]))))));
			fVbargraph86 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec599[0])))));
			fRec612[0] = (fTemp86 - (fConst3308 * ((fConst3311 * fRec612[2]) + (fConst3312 * fRec612[1]))));
			fRec611[0] = ((fConst3308 * (((fConst3310 * fRec612[0]) + (fConst3313 * fRec612[1])) + (fConst3310 * fRec612[2]))) - (fConst3306 * ((fConst3314 * fRec611[2]) + (fConst3315 * fRec611[1]))));
			fRec610[0] = ((fConst3306 * (((fConst3307 * fRec611[0]) + (fConst3316 * fRec611[1])) + (fConst3307 * fRec611[2]))) - (fConst3304 * ((fConst3317 * fRec610[2]) + (fConst3318 * fRec610[1]))));
			float fTemp87 = (fConst3304 * (((fConst3305 * fRec610[0]) + (fConst3319 * fRec610[1])) + (fConst3305 * fRec610[2])));
			fRec609[0] = (fTemp87 - (fConst3301 * ((fConst3320 * fRec609[2]) + (fConst3322 * fRec609[1]))));
			fRec608[0] = ((fConst3301 * (((fConst3303 * fRec609[0]) + (fConst3323 * fRec609[1])) + (fConst3303 * fRec609[2]))) - (fConst3298 * ((fConst3324 * fRec608[2]) + (fConst3325 * fRec608[1]))));
			fRec607[0] = ((fConst3298 * (((fConst3300 * fRec608[0]) + (fConst3326 * fRec608[1])) + (fConst3300 * fRec608[2]))) - (fConst3294 * ((fConst3327 * fRec607[2]) + (fConst3328 * fRec607[1]))));
			fRec606[0] = ((fSlow1 * fRec606[1]) + (fSlow2 * std::fabs((fConst3294 * (((fConst3297 * fRec607[0]) + (fConst3329 * fRec607[1])) + (fConst3297 * fRec607[2]))))));
			fVbargraph87 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec606[0])))));
			fRec619[0] = (fTemp87 - (fConst3346 * ((fConst3349 * fRec619[2]) + (fConst3350 * fRec619[1]))));
			fRec618[0] = ((fConst3346 * (((fConst3348 * fRec619[0]) + (fConst3351 * fRec619[1])) + (fConst3348 * fRec619[2]))) - (fConst3344 * ((fConst3352 * fRec618[2]) + (fConst3353 * fRec618[1]))));
			fRec617[0] = ((fConst3344 * (((fConst3345 * fRec618[0]) + (fConst3354 * fRec618[1])) + (fConst3345 * fRec618[2]))) - (fConst3342 * ((fConst3355 * fRec617[2]) + (fConst3356 * fRec617[1]))));
			float fTemp88 = (fConst3342 * (((fConst3343 * fRec617[0]) + (fConst3357 * fRec617[1])) + (fConst3343 * fRec617[2])));
			fRec616[0] = (fTemp88 - (fConst3339 * ((fConst3358 * fRec616[2]) + (fConst3360 * fRec616[1]))));
			fRec615[0] = ((fConst3339 * (((fConst3341 * fRec616[0]) + (fConst3361 * fRec616[1])) + (fConst3341 * fRec616[2]))) - (fConst3336 * ((fConst3362 * fRec615[2]) + (fConst3363 * fRec615[1]))));
			fRec614[0] = ((fConst3336 * (((fConst3338 * fRec615[0]) + (fConst3364 * fRec615[1])) + (fConst3338 * fRec615[2]))) - (fConst3332 * ((fConst3365 * fRec614[2]) + (fConst3366 * fRec614[1]))));
			fRec613[0] = ((fSlow1 * fRec613[1]) + (fSlow2 * std::fabs((fConst3332 * (((fConst3335 * fRec614[0]) + (fConst3367 * fRec614[1])) + (fConst3335 * fRec614[2]))))));
			fVbargraph88 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec613[0])))));
			fRec626[0] = (fTemp88 - (fConst3384 * ((fConst3387 * fRec626[2]) + (fConst3388 * fRec626[1]))));
			fRec625[0] = ((fConst3384 * (((fConst3386 * fRec626[0]) + (fConst3389 * fRec626[1])) + (fConst3386 * fRec626[2]))) - (fConst3382 * ((fConst3390 * fRec625[2]) + (fConst3391 * fRec625[1]))));
			fRec624[0] = ((fConst3382 * (((fConst3383 * fRec625[0]) + (fConst3392 * fRec625[1])) + (fConst3383 * fRec625[2]))) - (fConst3380 * ((fConst3393 * fRec624[2]) + (fConst3394 * fRec624[1]))));
			float fTemp89 = (fConst3380 * (((fConst3381 * fRec624[0]) + (fConst3395 * fRec624[1])) + (fConst3381 * fRec624[2])));
			fRec623[0] = (fTemp89 - (fConst3377 * ((fConst3396 * fRec623[2]) + (fConst3398 * fRec623[1]))));
			fRec622[0] = ((fConst3377 * (((fConst3379 * fRec623[0]) + (fConst3399 * fRec623[1])) + (fConst3379 * fRec623[2]))) - (fConst3374 * ((fConst3400 * fRec622[2]) + (fConst3401 * fRec622[1]))));
			fRec621[0] = ((fConst3374 * (((fConst3376 * fRec622[0]) + (fConst3402 * fRec622[1])) + (fConst3376 * fRec622[2]))) - (fConst3370 * ((fConst3403 * fRec621[2]) + (fConst3404 * fRec621[1]))));
			fRec620[0] = ((fSlow1 * fRec620[1]) + (fSlow2 * std::fabs((fConst3370 * (((fConst3373 * fRec621[0]) + (fConst3405 * fRec621[1])) + (fConst3373 * fRec621[2]))))));
			fVbargraph89 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec620[0])))));
			fRec633[0] = (fTemp89 - (fConst3422 * ((fConst3425 * fRec633[2]) + (fConst3426 * fRec633[1]))));
			fRec632[0] = ((fConst3422 * (((fConst3424 * fRec633[0]) + (fConst3427 * fRec633[1])) + (fConst3424 * fRec633[2]))) - (fConst3420 * ((fConst3428 * fRec632[2]) + (fConst3429 * fRec632[1]))));
			fRec631[0] = ((fConst3420 * (((fConst3421 * fRec632[0]) + (fConst3430 * fRec632[1])) + (fConst3421 * fRec632[2]))) - (fConst3418 * ((fConst3431 * fRec631[2]) + (fConst3432 * fRec631[1]))));
			float fTemp90 = (fConst3418 * (((fConst3419 * fRec631[0]) + (fConst3433 * fRec631[1])) + (fConst3419 * fRec631[2])));
			fRec630[0] = (fTemp90 - (fConst3415 * ((fConst3434 * fRec630[2]) + (fConst3436 * fRec630[1]))));
			fRec629[0] = ((fConst3415 * (((fConst3417 * fRec630[0]) + (fConst3437 * fRec630[1])) + (fConst3417 * fRec630[2]))) - (fConst3412 * ((fConst3438 * fRec629[2]) + (fConst3439 * fRec629[1]))));
			fRec628[0] = ((fConst3412 * (((fConst3414 * fRec629[0]) + (fConst3440 * fRec629[1])) + (fConst3414 * fRec629[2]))) - (fConst3408 * ((fConst3441 * fRec628[2]) + (fConst3442 * fRec628[1]))));
			fRec627[0] = ((fSlow1 * fRec627[1]) + (fSlow2 * std::fabs((fConst3408 * (((fConst3411 * fRec628[0]) + (fConst3443 * fRec628[1])) + (fConst3411 * fRec628[2]))))));
			fVbargraph90 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec627[0])))));
			fRec640[0] = (fTemp90 - (fConst3460 * ((fConst3463 * fRec640[2]) + (fConst3464 * fRec640[1]))));
			fRec639[0] = ((fConst3460 * (((fConst3462 * fRec640[0]) + (fConst3465 * fRec640[1])) + (fConst3462 * fRec640[2]))) - (fConst3458 * ((fConst3466 * fRec639[2]) + (fConst3467 * fRec639[1]))));
			fRec638[0] = ((fConst3458 * (((fConst3459 * fRec639[0]) + (fConst3468 * fRec639[1])) + (fConst3459 * fRec639[2]))) - (fConst3456 * ((fConst3469 * fRec638[2]) + (fConst3470 * fRec638[1]))));
			float fTemp91 = (fConst3456 * (((fConst3457 * fRec638[0]) + (fConst3471 * fRec638[1])) + (fConst3457 * fRec638[2])));
			fRec637[0] = (fTemp91 - (fConst3453 * ((fConst3472 * fRec637[2]) + (fConst3474 * fRec637[1]))));
			fRec636[0] = ((fConst3453 * (((fConst3455 * fRec637[0]) + (fConst3475 * fRec637[1])) + (fConst3455 * fRec637[2]))) - (fConst3450 * ((fConst3476 * fRec636[2]) + (fConst3477 * fRec636[1]))));
			fRec635[0] = ((fConst3450 * (((fConst3452 * fRec636[0]) + (fConst3478 * fRec636[1])) + (fConst3452 * fRec636[2]))) - (fConst3446 * ((fConst3479 * fRec635[2]) + (fConst3480 * fRec635[1]))));
			fRec634[0] = ((fSlow1 * fRec634[1]) + (fSlow2 * std::fabs((fConst3446 * (((fConst3449 * fRec635[0]) + (fConst3481 * fRec635[1])) + (fConst3449 * fRec635[2]))))));
			fVbargraph91 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec634[0])))));
			fRec647[0] = (fTemp91 - (fConst3498 * ((fConst3501 * fRec647[2]) + (fConst3502 * fRec647[1]))));
			fRec646[0] = ((fConst3498 * (((fConst3500 * fRec647[0]) + (fConst3503 * fRec647[1])) + (fConst3500 * fRec647[2]))) - (fConst3496 * ((fConst3504 * fRec646[2]) + (fConst3505 * fRec646[1]))));
			fRec645[0] = ((fConst3496 * (((fConst3497 * fRec646[0]) + (fConst3506 * fRec646[1])) + (fConst3497 * fRec646[2]))) - (fConst3494 * ((fConst3507 * fRec645[2]) + (fConst3508 * fRec645[1]))));
			float fTemp92 = (fConst3494 * (((fConst3495 * fRec645[0]) + (fConst3509 * fRec645[1])) + (fConst3495 * fRec645[2])));
			fRec644[0] = (fTemp92 - (fConst3491 * ((fConst3510 * fRec644[2]) + (fConst3512 * fRec644[1]))));
			fRec643[0] = ((fConst3491 * (((fConst3493 * fRec644[0]) + (fConst3513 * fRec644[1])) + (fConst3493 * fRec644[2]))) - (fConst3488 * ((fConst3514 * fRec643[2]) + (fConst3515 * fRec643[1]))));
			fRec642[0] = ((fConst3488 * (((fConst3490 * fRec643[0]) + (fConst3516 * fRec643[1])) + (fConst3490 * fRec643[2]))) - (fConst3484 * ((fConst3517 * fRec642[2]) + (fConst3518 * fRec642[1]))));
			fRec641[0] = ((fSlow1 * fRec641[1]) + (fSlow2 * std::fabs((fConst3484 * (((fConst3487 * fRec642[0]) + (fConst3519 * fRec642[1])) + (fConst3487 * fRec642[2]))))));
			fVbargraph92 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec641[0])))));
			fRec654[0] = (fTemp92 - (fConst3536 * ((fConst3539 * fRec654[2]) + (fConst3540 * fRec654[1]))));
			fRec653[0] = ((fConst3536 * (((fConst3538 * fRec654[0]) + (fConst3541 * fRec654[1])) + (fConst3538 * fRec654[2]))) - (fConst3534 * ((fConst3542 * fRec653[2]) + (fConst3543 * fRec653[1]))));
			fRec652[0] = ((fConst3534 * (((fConst3535 * fRec653[0]) + (fConst3544 * fRec653[1])) + (fConst3535 * fRec653[2]))) - (fConst3532 * ((fConst3545 * fRec652[2]) + (fConst3546 * fRec652[1]))));
			float fTemp93 = (fConst3532 * (((fConst3533 * fRec652[0]) + (fConst3547 * fRec652[1])) + (fConst3533 * fRec652[2])));
			fRec651[0] = (fTemp93 - (fConst3529 * ((fConst3548 * fRec651[2]) + (fConst3550 * fRec651[1]))));
			fRec650[0] = ((fConst3529 * (((fConst3531 * fRec651[0]) + (fConst3551 * fRec651[1])) + (fConst3531 * fRec651[2]))) - (fConst3526 * ((fConst3552 * fRec650[2]) + (fConst3553 * fRec650[1]))));
			fRec649[0] = ((fConst3526 * (((fConst3528 * fRec650[0]) + (fConst3554 * fRec650[1])) + (fConst3528 * fRec650[2]))) - (fConst3522 * ((fConst3555 * fRec649[2]) + (fConst3556 * fRec649[1]))));
			fRec648[0] = ((fSlow1 * fRec648[1]) + (fSlow2 * std::fabs((fConst3522 * (((fConst3525 * fRec649[0]) + (fConst3557 * fRec649[1])) + (fConst3525 * fRec649[2]))))));
			fVbargraph93 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec648[0])))));
			fRec661[0] = (fTemp93 - (fConst3574 * ((fConst3577 * fRec661[2]) + (fConst3578 * fRec661[1]))));
			fRec660[0] = ((fConst3574 * (((fConst3576 * fRec661[0]) + (fConst3579 * fRec661[1])) + (fConst3576 * fRec661[2]))) - (fConst3572 * ((fConst3580 * fRec660[2]) + (fConst3581 * fRec660[1]))));
			fRec659[0] = ((fConst3572 * (((fConst3573 * fRec660[0]) + (fConst3582 * fRec660[1])) + (fConst3573 * fRec660[2]))) - (fConst3570 * ((fConst3583 * fRec659[2]) + (fConst3584 * fRec659[1]))));
			float fTemp94 = (fConst3570 * (((fConst3571 * fRec659[0]) + (fConst3585 * fRec659[1])) + (fConst3571 * fRec659[2])));
			fRec658[0] = (fTemp94 - (fConst3567 * ((fConst3586 * fRec658[2]) + (fConst3588 * fRec658[1]))));
			fRec657[0] = ((fConst3567 * (((fConst3569 * fRec658[0]) + (fConst3589 * fRec658[1])) + (fConst3569 * fRec658[2]))) - (fConst3564 * ((fConst3590 * fRec657[2]) + (fConst3591 * fRec657[1]))));
			fRec656[0] = ((fConst3564 * (((fConst3566 * fRec657[0]) + (fConst3592 * fRec657[1])) + (fConst3566 * fRec657[2]))) - (fConst3560 * ((fConst3593 * fRec656[2]) + (fConst3594 * fRec656[1]))));
			fRec655[0] = ((fSlow1 * fRec655[1]) + (fSlow2 * std::fabs((fConst3560 * (((fConst3563 * fRec656[0]) + (fConst3595 * fRec656[1])) + (fConst3563 * fRec656[2]))))));
			fVbargraph94 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec655[0])))));
			fRec668[0] = (fTemp94 - (fConst3612 * ((fConst3615 * fRec668[2]) + (fConst3616 * fRec668[1]))));
			fRec667[0] = ((fConst3612 * (((fConst3614 * fRec668[0]) + (fConst3617 * fRec668[1])) + (fConst3614 * fRec668[2]))) - (fConst3610 * ((fConst3618 * fRec667[2]) + (fConst3619 * fRec667[1]))));
			fRec666[0] = ((fConst3610 * (((fConst3611 * fRec667[0]) + (fConst3620 * fRec667[1])) + (fConst3611 * fRec667[2]))) - (fConst3608 * ((fConst3621 * fRec666[2]) + (fConst3622 * fRec666[1]))));
			float fTemp95 = (fConst3608 * (((fConst3609 * fRec666[0]) + (fConst3623 * fRec666[1])) + (fConst3609 * fRec666[2])));
			fRec665[0] = (fTemp95 - (fConst3605 * ((fConst3624 * fRec665[2]) + (fConst3626 * fRec665[1]))));
			fRec664[0] = ((fConst3605 * (((fConst3607 * fRec665[0]) + (fConst3627 * fRec665[1])) + (fConst3607 * fRec665[2]))) - (fConst3602 * ((fConst3628 * fRec664[2]) + (fConst3629 * fRec664[1]))));
			fRec663[0] = ((fConst3602 * (((fConst3604 * fRec664[0]) + (fConst3630 * fRec664[1])) + (fConst3604 * fRec664[2]))) - (fConst3598 * ((fConst3631 * fRec663[2]) + (fConst3632 * fRec663[1]))));
			fRec662[0] = ((fSlow1 * fRec662[1]) + (fSlow2 * std::fabs((fConst3598 * (((fConst3601 * fRec663[0]) + (fConst3633 * fRec663[1])) + (fConst3601 * fRec663[2]))))));
			fVbargraph95 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec662[0])))));
			fRec675[0] = (fTemp95 - (fConst3650 * ((fConst3653 * fRec675[2]) + (fConst3654 * fRec675[1]))));
			fRec674[0] = ((fConst3650 * (((fConst3652 * fRec675[0]) + (fConst3655 * fRec675[1])) + (fConst3652 * fRec675[2]))) - (fConst3648 * ((fConst3656 * fRec674[2]) + (fConst3657 * fRec674[1]))));
			fRec673[0] = ((fConst3648 * (((fConst3649 * fRec674[0]) + (fConst3658 * fRec674[1])) + (fConst3649 * fRec674[2]))) - (fConst3646 * ((fConst3659 * fRec673[2]) + (fConst3660 * fRec673[1]))));
			float fTemp96 = (fConst3646 * (((fConst3647 * fRec673[0]) + (fConst3661 * fRec673[1])) + (fConst3647 * fRec673[2])));
			fRec672[0] = (fTemp96 - (fConst3643 * ((fConst3662 * fRec672[2]) + (fConst3664 * fRec672[1]))));
			fRec671[0] = ((fConst3643 * (((fConst3645 * fRec672[0]) + (fConst3665 * fRec672[1])) + (fConst3645 * fRec672[2]))) - (fConst3640 * ((fConst3666 * fRec671[2]) + (fConst3667 * fRec671[1]))));
			fRec670[0] = ((fConst3640 * (((fConst3642 * fRec671[0]) + (fConst3668 * fRec671[1])) + (fConst3642 * fRec671[2]))) - (fConst3636 * ((fConst3669 * fRec670[2]) + (fConst3670 * fRec670[1]))));
			fRec669[0] = ((fSlow1 * fRec669[1]) + (fSlow2 * std::fabs((fConst3636 * (((fConst3639 * fRec670[0]) + (fConst3671 * fRec670[1])) + (fConst3639 * fRec670[2]))))));
			fVbargraph96 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec669[0])))));
			fRec682[0] = (fTemp96 - (fConst3688 * ((fConst3691 * fRec682[2]) + (fConst3692 * fRec682[1]))));
			fRec681[0] = ((fConst3688 * (((fConst3690 * fRec682[0]) + (fConst3693 * fRec682[1])) + (fConst3690 * fRec682[2]))) - (fConst3686 * ((fConst3694 * fRec681[2]) + (fConst3695 * fRec681[1]))));
			fRec680[0] = ((fConst3686 * (((fConst3687 * fRec681[0]) + (fConst3696 * fRec681[1])) + (fConst3687 * fRec681[2]))) - (fConst3684 * ((fConst3697 * fRec680[2]) + (fConst3698 * fRec680[1]))));
			float fTemp97 = (fConst3684 * (((fConst3685 * fRec680[0]) + (fConst3699 * fRec680[1])) + (fConst3685 * fRec680[2])));
			fRec679[0] = (fTemp97 - (fConst3681 * ((fConst3700 * fRec679[2]) + (fConst3702 * fRec679[1]))));
			fRec678[0] = ((fConst3681 * (((fConst3683 * fRec679[0]) + (fConst3703 * fRec679[1])) + (fConst3683 * fRec679[2]))) - (fConst3678 * ((fConst3704 * fRec678[2]) + (fConst3705 * fRec678[1]))));
			fRec677[0] = ((fConst3678 * (((fConst3680 * fRec678[0]) + (fConst3706 * fRec678[1])) + (fConst3680 * fRec678[2]))) - (fConst3674 * ((fConst3707 * fRec677[2]) + (fConst3708 * fRec677[1]))));
			fRec676[0] = ((fSlow1 * fRec676[1]) + (fSlow2 * std::fabs((fConst3674 * (((fConst3677 * fRec677[0]) + (fConst3709 * fRec677[1])) + (fConst3677 * fRec677[2]))))));
			fVbargraph97 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec676[0])))));
			fRec689[0] = (fTemp97 - (fConst3726 * ((fConst3729 * fRec689[2]) + (fConst3730 * fRec689[1]))));
			fRec688[0] = ((fConst3726 * (((fConst3728 * fRec689[0]) + (fConst3731 * fRec689[1])) + (fConst3728 * fRec689[2]))) - (fConst3724 * ((fConst3732 * fRec688[2]) + (fConst3733 * fRec688[1]))));
			fRec687[0] = ((fConst3724 * (((fConst3725 * fRec688[0]) + (fConst3734 * fRec688[1])) + (fConst3725 * fRec688[2]))) - (fConst3722 * ((fConst3735 * fRec687[2]) + (fConst3736 * fRec687[1]))));
			float fTemp98 = (fConst3722 * (((fConst3723 * fRec687[0]) + (fConst3737 * fRec687[1])) + (fConst3723 * fRec687[2])));
			fRec686[0] = (fTemp98 - (fConst3719 * ((fConst3738 * fRec686[2]) + (fConst3740 * fRec686[1]))));
			fRec685[0] = ((fConst3719 * (((fConst3721 * fRec686[0]) + (fConst3741 * fRec686[1])) + (fConst3721 * fRec686[2]))) - (fConst3716 * ((fConst3742 * fRec685[2]) + (fConst3743 * fRec685[1]))));
			fRec684[0] = ((fConst3716 * (((fConst3718 * fRec685[0]) + (fConst3744 * fRec685[1])) + (fConst3718 * fRec685[2]))) - (fConst3712 * ((fConst3745 * fRec684[2]) + (fConst3746 * fRec684[1]))));
			fRec683[0] = ((fSlow1 * fRec683[1]) + (fSlow2 * std::fabs((fConst3712 * (((fConst3715 * fRec684[0]) + (fConst3747 * fRec684[1])) + (fConst3715 * fRec684[2]))))));
			fVbargraph98 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec683[0])))));
			fRec696[0] = (fTemp98 - (fConst3764 * ((fConst3767 * fRec696[2]) + (fConst3768 * fRec696[1]))));
			fRec695[0] = ((fConst3764 * (((fConst3766 * fRec696[0]) + (fConst3769 * fRec696[1])) + (fConst3766 * fRec696[2]))) - (fConst3762 * ((fConst3770 * fRec695[2]) + (fConst3771 * fRec695[1]))));
			fRec694[0] = ((fConst3762 * (((fConst3763 * fRec695[0]) + (fConst3772 * fRec695[1])) + (fConst3763 * fRec695[2]))) - (fConst3760 * ((fConst3773 * fRec694[2]) + (fConst3774 * fRec694[1]))));
			float fTemp99 = (fConst3760 * (((fConst3761 * fRec694[0]) + (fConst3775 * fRec694[1])) + (fConst3761 * fRec694[2])));
			fRec693[0] = (fTemp99 - (fConst3757 * ((fConst3776 * fRec693[2]) + (fConst3778 * fRec693[1]))));
			fRec692[0] = ((fConst3757 * (((fConst3759 * fRec693[0]) + (fConst3779 * fRec693[1])) + (fConst3759 * fRec693[2]))) - (fConst3754 * ((fConst3780 * fRec692[2]) + (fConst3781 * fRec692[1]))));
			fRec691[0] = ((fConst3754 * (((fConst3756 * fRec692[0]) + (fConst3782 * fRec692[1])) + (fConst3756 * fRec692[2]))) - (fConst3750 * ((fConst3783 * fRec691[2]) + (fConst3784 * fRec691[1]))));
			fRec690[0] = ((fSlow1 * fRec690[1]) + (fSlow2 * std::fabs((fConst3750 * (((fConst3753 * fRec691[0]) + (fConst3785 * fRec691[1])) + (fConst3753 * fRec691[2]))))));
			fVbargraph99 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec690[0])))));
			fRec703[0] = (fTemp99 - (fConst3802 * ((fConst3805 * fRec703[2]) + (fConst3806 * fRec703[1]))));
			fRec702[0] = ((fConst3802 * (((fConst3804 * fRec703[0]) + (fConst3807 * fRec703[1])) + (fConst3804 * fRec703[2]))) - (fConst3800 * ((fConst3808 * fRec702[2]) + (fConst3809 * fRec702[1]))));
			fRec701[0] = ((fConst3800 * (((fConst3801 * fRec702[0]) + (fConst3810 * fRec702[1])) + (fConst3801 * fRec702[2]))) - (fConst3798 * ((fConst3811 * fRec701[2]) + (fConst3812 * fRec701[1]))));
			float fTemp100 = (fConst3798 * (((fConst3799 * fRec701[0]) + (fConst3813 * fRec701[1])) + (fConst3799 * fRec701[2])));
			fRec700[0] = (fTemp100 - (fConst3795 * ((fConst3814 * fRec700[2]) + (fConst3816 * fRec700[1]))));
			fRec699[0] = ((fConst3795 * (((fConst3797 * fRec700[0]) + (fConst3817 * fRec700[1])) + (fConst3797 * fRec700[2]))) - (fConst3792 * ((fConst3818 * fRec699[2]) + (fConst3819 * fRec699[1]))));
			fRec698[0] = ((fConst3792 * (((fConst3794 * fRec699[0]) + (fConst3820 * fRec699[1])) + (fConst3794 * fRec699[2]))) - (fConst3788 * ((fConst3821 * fRec698[2]) + (fConst3822 * fRec698[1]))));
			fRec697[0] = ((fSlow1 * fRec697[1]) + (fSlow2 * std::fabs((fConst3788 * (((fConst3791 * fRec698[0]) + (fConst3823 * fRec698[1])) + (fConst3791 * fRec698[2]))))));
			fVbargraph100 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec697[0])))));
			fRec710[0] = (fTemp100 - (fConst3840 * ((fConst3843 * fRec710[2]) + (fConst3844 * fRec710[1]))));
			fRec709[0] = ((fConst3840 * (((fConst3842 * fRec710[0]) + (fConst3845 * fRec710[1])) + (fConst3842 * fRec710[2]))) - (fConst3838 * ((fConst3846 * fRec709[2]) + (fConst3847 * fRec709[1]))));
			fRec708[0] = ((fConst3838 * (((fConst3839 * fRec709[0]) + (fConst3848 * fRec709[1])) + (fConst3839 * fRec709[2]))) - (fConst3836 * ((fConst3849 * fRec708[2]) + (fConst3850 * fRec708[1]))));
			float fTemp101 = (fConst3836 * (((fConst3837 * fRec708[0]) + (fConst3851 * fRec708[1])) + (fConst3837 * fRec708[2])));
			fRec707[0] = (fTemp101 - (fConst3833 * ((fConst3852 * fRec707[2]) + (fConst3854 * fRec707[1]))));
			fRec706[0] = ((fConst3833 * (((fConst3835 * fRec707[0]) + (fConst3855 * fRec707[1])) + (fConst3835 * fRec707[2]))) - (fConst3830 * ((fConst3856 * fRec706[2]) + (fConst3857 * fRec706[1]))));
			fRec705[0] = ((fConst3830 * (((fConst3832 * fRec706[0]) + (fConst3858 * fRec706[1])) + (fConst3832 * fRec706[2]))) - (fConst3826 * ((fConst3859 * fRec705[2]) + (fConst3860 * fRec705[1]))));
			fRec704[0] = ((fSlow1 * fRec704[1]) + (fSlow2 * std::fabs((fConst3826 * (((fConst3829 * fRec705[0]) + (fConst3861 * fRec705[1])) + (fConst3829 * fRec705[2]))))));
			fVbargraph101 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec704[0])))));
			fRec717[0] = (fTemp101 - (fConst3878 * ((fConst3881 * fRec717[2]) + (fConst3882 * fRec717[1]))));
			fRec716[0] = ((fConst3878 * (((fConst3880 * fRec717[0]) + (fConst3883 * fRec717[1])) + (fConst3880 * fRec717[2]))) - (fConst3876 * ((fConst3884 * fRec716[2]) + (fConst3885 * fRec716[1]))));
			fRec715[0] = ((fConst3876 * (((fConst3877 * fRec716[0]) + (fConst3886 * fRec716[1])) + (fConst3877 * fRec716[2]))) - (fConst3874 * ((fConst3887 * fRec715[2]) + (fConst3888 * fRec715[1]))));
			float fTemp102 = (fConst3874 * (((fConst3875 * fRec715[0]) + (fConst3889 * fRec715[1])) + (fConst3875 * fRec715[2])));
			fRec714[0] = (fTemp102 - (fConst3871 * ((fConst3890 * fRec714[2]) + (fConst3892 * fRec714[1]))));
			fRec713[0] = ((fConst3871 * (((fConst3873 * fRec714[0]) + (fConst3893 * fRec714[1])) + (fConst3873 * fRec714[2]))) - (fConst3868 * ((fConst3894 * fRec713[2]) + (fConst3895 * fRec713[1]))));
			fRec712[0] = ((fConst3868 * (((fConst3870 * fRec713[0]) + (fConst3896 * fRec713[1])) + (fConst3870 * fRec713[2]))) - (fConst3864 * ((fConst3897 * fRec712[2]) + (fConst3898 * fRec712[1]))));
			fRec711[0] = ((fSlow1 * fRec711[1]) + (fSlow2 * std::fabs((fConst3864 * (((fConst3867 * fRec712[0]) + (fConst3899 * fRec712[1])) + (fConst3867 * fRec712[2]))))));
			fVbargraph102 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec711[0])))));
			fRec724[0] = (fTemp102 - (fConst3916 * ((fConst3919 * fRec724[2]) + (fConst3920 * fRec724[1]))));
			fRec723[0] = ((fConst3916 * (((fConst3918 * fRec724[0]) + (fConst3921 * fRec724[1])) + (fConst3918 * fRec724[2]))) - (fConst3914 * ((fConst3922 * fRec723[2]) + (fConst3923 * fRec723[1]))));
			fRec722[0] = ((fConst3914 * (((fConst3915 * fRec723[0]) + (fConst3924 * fRec723[1])) + (fConst3915 * fRec723[2]))) - (fConst3912 * ((fConst3925 * fRec722[2]) + (fConst3926 * fRec722[1]))));
			float fTemp103 = (fConst3912 * (((fConst3913 * fRec722[0]) + (fConst3927 * fRec722[1])) + (fConst3913 * fRec722[2])));
			fRec721[0] = (fTemp103 - (fConst3909 * ((fConst3928 * fRec721[2]) + (fConst3930 * fRec721[1]))));
			fRec720[0] = ((fConst3909 * (((fConst3911 * fRec721[0]) + (fConst3931 * fRec721[1])) + (fConst3911 * fRec721[2]))) - (fConst3906 * ((fConst3932 * fRec720[2]) + (fConst3933 * fRec720[1]))));
			fRec719[0] = ((fConst3906 * (((fConst3908 * fRec720[0]) + (fConst3934 * fRec720[1])) + (fConst3908 * fRec720[2]))) - (fConst3902 * ((fConst3935 * fRec719[2]) + (fConst3936 * fRec719[1]))));
			fRec718[0] = ((fSlow1 * fRec718[1]) + (fSlow2 * std::fabs((fConst3902 * (((fConst3905 * fRec719[0]) + (fConst3937 * fRec719[1])) + (fConst3905 * fRec719[2]))))));
			fVbargraph103 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec718[0])))));
			fRec731[0] = (fTemp103 - (fConst3954 * ((fConst3957 * fRec731[2]) + (fConst3958 * fRec731[1]))));
			fRec730[0] = ((fConst3954 * (((fConst3956 * fRec731[0]) + (fConst3959 * fRec731[1])) + (fConst3956 * fRec731[2]))) - (fConst3952 * ((fConst3960 * fRec730[2]) + (fConst3961 * fRec730[1]))));
			fRec729[0] = ((fConst3952 * (((fConst3953 * fRec730[0]) + (fConst3962 * fRec730[1])) + (fConst3953 * fRec730[2]))) - (fConst3950 * ((fConst3963 * fRec729[2]) + (fConst3964 * fRec729[1]))));
			float fTemp104 = (fConst3950 * (((fConst3951 * fRec729[0]) + (fConst3965 * fRec729[1])) + (fConst3951 * fRec729[2])));
			fRec728[0] = (fTemp104 - (fConst3947 * ((fConst3966 * fRec728[2]) + (fConst3968 * fRec728[1]))));
			fRec727[0] = ((fConst3947 * (((fConst3949 * fRec728[0]) + (fConst3969 * fRec728[1])) + (fConst3949 * fRec728[2]))) - (fConst3944 * ((fConst3970 * fRec727[2]) + (fConst3971 * fRec727[1]))));
			fRec726[0] = ((fConst3944 * (((fConst3946 * fRec727[0]) + (fConst3972 * fRec727[1])) + (fConst3946 * fRec727[2]))) - (fConst3940 * ((fConst3973 * fRec726[2]) + (fConst3974 * fRec726[1]))));
			fRec725[0] = ((fSlow1 * fRec725[1]) + (fSlow2 * std::fabs((fConst3940 * (((fConst3943 * fRec726[0]) + (fConst3975 * fRec726[1])) + (fConst3943 * fRec726[2]))))));
			fVbargraph104 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec725[0])))));
			fRec738[0] = (fTemp104 - (fConst3992 * ((fConst3995 * fRec738[2]) + (fConst3996 * fRec738[1]))));
			fRec737[0] = ((fConst3992 * (((fConst3994 * fRec738[0]) + (fConst3997 * fRec738[1])) + (fConst3994 * fRec738[2]))) - (fConst3990 * ((fConst3998 * fRec737[2]) + (fConst3999 * fRec737[1]))));
			fRec736[0] = ((fConst3990 * (((fConst3991 * fRec737[0]) + (fConst4000 * fRec737[1])) + (fConst3991 * fRec737[2]))) - (fConst3988 * ((fConst4001 * fRec736[2]) + (fConst4002 * fRec736[1]))));
			float fTemp105 = (fConst3988 * (((fConst3989 * fRec736[0]) + (fConst4003 * fRec736[1])) + (fConst3989 * fRec736[2])));
			fRec735[0] = (fTemp105 - (fConst3985 * ((fConst4004 * fRec735[2]) + (fConst4006 * fRec735[1]))));
			fRec734[0] = ((fConst3985 * (((fConst3987 * fRec735[0]) + (fConst4007 * fRec735[1])) + (fConst3987 * fRec735[2]))) - (fConst3982 * ((fConst4008 * fRec734[2]) + (fConst4009 * fRec734[1]))));
			fRec733[0] = ((fConst3982 * (((fConst3984 * fRec734[0]) + (fConst4010 * fRec734[1])) + (fConst3984 * fRec734[2]))) - (fConst3978 * ((fConst4011 * fRec733[2]) + (fConst4012 * fRec733[1]))));
			fRec732[0] = ((fSlow1 * fRec732[1]) + (fSlow2 * std::fabs((fConst3978 * (((fConst3981 * fRec733[0]) + (fConst4013 * fRec733[1])) + (fConst3981 * fRec733[2]))))));
			fVbargraph105 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec732[0])))));
			fRec745[0] = (fTemp105 - (fConst4030 * ((fConst4033 * fRec745[2]) + (fConst4034 * fRec745[1]))));
			fRec744[0] = ((fConst4030 * (((fConst4032 * fRec745[0]) + (fConst4035 * fRec745[1])) + (fConst4032 * fRec745[2]))) - (fConst4028 * ((fConst4036 * fRec744[2]) + (fConst4037 * fRec744[1]))));
			fRec743[0] = ((fConst4028 * (((fConst4029 * fRec744[0]) + (fConst4038 * fRec744[1])) + (fConst4029 * fRec744[2]))) - (fConst4026 * ((fConst4039 * fRec743[2]) + (fConst4040 * fRec743[1]))));
			float fTemp106 = (fConst4026 * (((fConst4027 * fRec743[0]) + (fConst4041 * fRec743[1])) + (fConst4027 * fRec743[2])));
			fRec742[0] = (fTemp106 - (fConst4023 * ((fConst4042 * fRec742[2]) + (fConst4044 * fRec742[1]))));
			fRec741[0] = ((fConst4023 * (((fConst4025 * fRec742[0]) + (fConst4045 * fRec742[1])) + (fConst4025 * fRec742[2]))) - (fConst4020 * ((fConst4046 * fRec741[2]) + (fConst4047 * fRec741[1]))));
			fRec740[0] = ((fConst4020 * (((fConst4022 * fRec741[0]) + (fConst4048 * fRec741[1])) + (fConst4022 * fRec741[2]))) - (fConst4016 * ((fConst4049 * fRec740[2]) + (fConst4050 * fRec740[1]))));
			fRec739[0] = ((fSlow1 * fRec739[1]) + (fSlow2 * std::fabs((fConst4016 * (((fConst4019 * fRec740[0]) + (fConst4051 * fRec740[1])) + (fConst4019 * fRec740[2]))))));
			fVbargraph106 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec739[0])))));
			fRec752[0] = (fTemp106 - (fConst4068 * ((fConst4071 * fRec752[2]) + (fConst4072 * fRec752[1]))));
			fRec751[0] = ((fConst4068 * (((fConst4070 * fRec752[0]) + (fConst4073 * fRec752[1])) + (fConst4070 * fRec752[2]))) - (fConst4066 * ((fConst4074 * fRec751[2]) + (fConst4075 * fRec751[1]))));
			fRec750[0] = ((fConst4066 * (((fConst4067 * fRec751[0]) + (fConst4076 * fRec751[1])) + (fConst4067 * fRec751[2]))) - (fConst4064 * ((fConst4077 * fRec750[2]) + (fConst4078 * fRec750[1]))));
			float fTemp107 = (fConst4064 * (((fConst4065 * fRec750[0]) + (fConst4079 * fRec750[1])) + (fConst4065 * fRec750[2])));
			fRec749[0] = (fTemp107 - (fConst4061 * ((fConst4080 * fRec749[2]) + (fConst4082 * fRec749[1]))));
			fRec748[0] = ((fConst4061 * (((fConst4063 * fRec749[0]) + (fConst4083 * fRec749[1])) + (fConst4063 * fRec749[2]))) - (fConst4058 * ((fConst4084 * fRec748[2]) + (fConst4085 * fRec748[1]))));
			fRec747[0] = ((fConst4058 * (((fConst4060 * fRec748[0]) + (fConst4086 * fRec748[1])) + (fConst4060 * fRec748[2]))) - (fConst4054 * ((fConst4087 * fRec747[2]) + (fConst4088 * fRec747[1]))));
			fRec746[0] = ((fSlow1 * fRec746[1]) + (fSlow2 * std::fabs((fConst4054 * (((fConst4057 * fRec747[0]) + (fConst4089 * fRec747[1])) + (fConst4057 * fRec747[2]))))));
			fVbargraph107 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec746[0])))));
			fRec759[0] = (fTemp107 - (fConst4106 * ((fConst4109 * fRec759[2]) + (fConst4110 * fRec759[1]))));
			fRec758[0] = ((fConst4106 * (((fConst4108 * fRec759[0]) + (fConst4111 * fRec759[1])) + (fConst4108 * fRec759[2]))) - (fConst4104 * ((fConst4112 * fRec758[2]) + (fConst4113 * fRec758[1]))));
			fRec757[0] = ((fConst4104 * (((fConst4105 * fRec758[0]) + (fConst4114 * fRec758[1])) + (fConst4105 * fRec758[2]))) - (fConst4102 * ((fConst4115 * fRec757[2]) + (fConst4116 * fRec757[1]))));
			float fTemp108 = (fConst4102 * (((fConst4103 * fRec757[0]) + (fConst4117 * fRec757[1])) + (fConst4103 * fRec757[2])));
			fRec756[0] = (fTemp108 - (fConst4099 * ((fConst4118 * fRec756[2]) + (fConst4120 * fRec756[1]))));
			fRec755[0] = ((fConst4099 * (((fConst4101 * fRec756[0]) + (fConst4121 * fRec756[1])) + (fConst4101 * fRec756[2]))) - (fConst4096 * ((fConst4122 * fRec755[2]) + (fConst4123 * fRec755[1]))));
			fRec754[0] = ((fConst4096 * (((fConst4098 * fRec755[0]) + (fConst4124 * fRec755[1])) + (fConst4098 * fRec755[2]))) - (fConst4092 * ((fConst4125 * fRec754[2]) + (fConst4126 * fRec754[1]))));
			fRec753[0] = ((fSlow1 * fRec753[1]) + (fSlow2 * std::fabs((fConst4092 * (((fConst4095 * fRec754[0]) + (fConst4127 * fRec754[1])) + (fConst4095 * fRec754[2]))))));
			fVbargraph108 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec753[0])))));
			fRec766[0] = (fTemp108 - (fConst4144 * ((fConst4147 * fRec766[2]) + (fConst4148 * fRec766[1]))));
			fRec765[0] = ((fConst4144 * (((fConst4146 * fRec766[0]) + (fConst4149 * fRec766[1])) + (fConst4146 * fRec766[2]))) - (fConst4142 * ((fConst4150 * fRec765[2]) + (fConst4151 * fRec765[1]))));
			fRec764[0] = ((fConst4142 * (((fConst4143 * fRec765[0]) + (fConst4152 * fRec765[1])) + (fConst4143 * fRec765[2]))) - (fConst4140 * ((fConst4153 * fRec764[2]) + (fConst4154 * fRec764[1]))));
			float fTemp109 = (fConst4140 * (((fConst4141 * fRec764[0]) + (fConst4155 * fRec764[1])) + (fConst4141 * fRec764[2])));
			fRec763[0] = (fTemp109 - (fConst4137 * ((fConst4156 * fRec763[2]) + (fConst4158 * fRec763[1]))));
			fRec762[0] = ((fConst4137 * (((fConst4139 * fRec763[0]) + (fConst4159 * fRec763[1])) + (fConst4139 * fRec763[2]))) - (fConst4134 * ((fConst4160 * fRec762[2]) + (fConst4161 * fRec762[1]))));
			fRec761[0] = ((fConst4134 * (((fConst4136 * fRec762[0]) + (fConst4162 * fRec762[1])) + (fConst4136 * fRec762[2]))) - (fConst4130 * ((fConst4163 * fRec761[2]) + (fConst4164 * fRec761[1]))));
			fRec760[0] = ((fSlow1 * fRec760[1]) + (fSlow2 * std::fabs((fConst4130 * (((fConst4133 * fRec761[0]) + (fConst4165 * fRec761[1])) + (fConst4133 * fRec761[2]))))));
			fVbargraph109 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec760[0])))));
			fRec773[0] = (fTemp109 - (fConst4182 * ((fConst4185 * fRec773[2]) + (fConst4186 * fRec773[1]))));
			fRec772[0] = ((fConst4182 * (((fConst4184 * fRec773[0]) + (fConst4187 * fRec773[1])) + (fConst4184 * fRec773[2]))) - (fConst4180 * ((fConst4188 * fRec772[2]) + (fConst4189 * fRec772[1]))));
			fRec771[0] = ((fConst4180 * (((fConst4181 * fRec772[0]) + (fConst4190 * fRec772[1])) + (fConst4181 * fRec772[2]))) - (fConst4178 * ((fConst4191 * fRec771[2]) + (fConst4192 * fRec771[1]))));
			float fTemp110 = (fConst4178 * (((fConst4179 * fRec771[0]) + (fConst4193 * fRec771[1])) + (fConst4179 * fRec771[2])));
			fRec770[0] = (fTemp110 - (fConst4175 * ((fConst4194 * fRec770[2]) + (fConst4196 * fRec770[1]))));
			fRec769[0] = ((fConst4175 * (((fConst4177 * fRec770[0]) + (fConst4197 * fRec770[1])) + (fConst4177 * fRec770[2]))) - (fConst4172 * ((fConst4198 * fRec769[2]) + (fConst4199 * fRec769[1]))));
			fRec768[0] = ((fConst4172 * (((fConst4174 * fRec769[0]) + (fConst4200 * fRec769[1])) + (fConst4174 * fRec769[2]))) - (fConst4168 * ((fConst4201 * fRec768[2]) + (fConst4202 * fRec768[1]))));
			fRec767[0] = ((fSlow1 * fRec767[1]) + (fSlow2 * std::fabs((fConst4168 * (((fConst4171 * fRec768[0]) + (fConst4203 * fRec768[1])) + (fConst4171 * fRec768[2]))))));
			fVbargraph110 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec767[0])))));
			fRec780[0] = (fTemp110 - (fConst4220 * ((fConst4223 * fRec780[2]) + (fConst4224 * fRec780[1]))));
			fRec779[0] = ((fConst4220 * (((fConst4222 * fRec780[0]) + (fConst4225 * fRec780[1])) + (fConst4222 * fRec780[2]))) - (fConst4218 * ((fConst4226 * fRec779[2]) + (fConst4227 * fRec779[1]))));
			fRec778[0] = ((fConst4218 * (((fConst4219 * fRec779[0]) + (fConst4228 * fRec779[1])) + (fConst4219 * fRec779[2]))) - (fConst4216 * ((fConst4229 * fRec778[2]) + (fConst4230 * fRec778[1]))));
			float fTemp111 = (fConst4216 * (((fConst4217 * fRec778[0]) + (fConst4231 * fRec778[1])) + (fConst4217 * fRec778[2])));
			fRec777[0] = (fTemp111 - (fConst4213 * ((fConst4232 * fRec777[2]) + (fConst4234 * fRec777[1]))));
			fRec776[0] = ((fConst4213 * (((fConst4215 * fRec777[0]) + (fConst4235 * fRec777[1])) + (fConst4215 * fRec777[2]))) - (fConst4210 * ((fConst4236 * fRec776[2]) + (fConst4237 * fRec776[1]))));
			fRec775[0] = ((fConst4210 * (((fConst4212 * fRec776[0]) + (fConst4238 * fRec776[1])) + (fConst4212 * fRec776[2]))) - (fConst4206 * ((fConst4239 * fRec775[2]) + (fConst4240 * fRec775[1]))));
			fRec774[0] = ((fSlow1 * fRec774[1]) + (fSlow2 * std::fabs((fConst4206 * (((fConst4209 * fRec775[0]) + (fConst4241 * fRec775[1])) + (fConst4209 * fRec775[2]))))));
			fVbargraph111 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec774[0])))));
			fRec787[0] = (fTemp111 - (fConst4258 * ((fConst4261 * fRec787[2]) + (fConst4262 * fRec787[1]))));
			fRec786[0] = ((fConst4258 * (((fConst4260 * fRec787[0]) + (fConst4263 * fRec787[1])) + (fConst4260 * fRec787[2]))) - (fConst4256 * ((fConst4264 * fRec786[2]) + (fConst4265 * fRec786[1]))));
			fRec785[0] = ((fConst4256 * (((fConst4257 * fRec786[0]) + (fConst4266 * fRec786[1])) + (fConst4257 * fRec786[2]))) - (fConst4254 * ((fConst4267 * fRec785[2]) + (fConst4268 * fRec785[1]))));
			float fTemp112 = (fConst4254 * (((fConst4255 * fRec785[0]) + (fConst4269 * fRec785[1])) + (fConst4255 * fRec785[2])));
			fRec784[0] = (fTemp112 - (fConst4251 * ((fConst4270 * fRec784[2]) + (fConst4272 * fRec784[1]))));
			fRec783[0] = ((fConst4251 * (((fConst4253 * fRec784[0]) + (fConst4273 * fRec784[1])) + (fConst4253 * fRec784[2]))) - (fConst4248 * ((fConst4274 * fRec783[2]) + (fConst4275 * fRec783[1]))));
			fRec782[0] = ((fConst4248 * (((fConst4250 * fRec783[0]) + (fConst4276 * fRec783[1])) + (fConst4250 * fRec783[2]))) - (fConst4244 * ((fConst4277 * fRec782[2]) + (fConst4278 * fRec782[1]))));
			fRec781[0] = ((fSlow1 * fRec781[1]) + (fSlow2 * std::fabs((fConst4244 * (((fConst4247 * fRec782[0]) + (fConst4279 * fRec782[1])) + (fConst4247 * fRec782[2]))))));
			fVbargraph112 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec781[0])))));
			fRec794[0] = (fTemp112 - (fConst4296 * ((fConst4299 * fRec794[2]) + (fConst4300 * fRec794[1]))));
			fRec793[0] = ((fConst4296 * (((fConst4298 * fRec794[0]) + (fConst4301 * fRec794[1])) + (fConst4298 * fRec794[2]))) - (fConst4294 * ((fConst4302 * fRec793[2]) + (fConst4303 * fRec793[1]))));
			fRec792[0] = ((fConst4294 * (((fConst4295 * fRec793[0]) + (fConst4304 * fRec793[1])) + (fConst4295 * fRec793[2]))) - (fConst4292 * ((fConst4305 * fRec792[2]) + (fConst4306 * fRec792[1]))));
			float fTemp113 = (fConst4292 * (((fConst4293 * fRec792[0]) + (fConst4307 * fRec792[1])) + (fConst4293 * fRec792[2])));
			fRec791[0] = (fTemp113 - (fConst4289 * ((fConst4308 * fRec791[2]) + (fConst4310 * fRec791[1]))));
			fRec790[0] = ((fConst4289 * (((fConst4291 * fRec791[0]) + (fConst4311 * fRec791[1])) + (fConst4291 * fRec791[2]))) - (fConst4286 * ((fConst4312 * fRec790[2]) + (fConst4313 * fRec790[1]))));
			fRec789[0] = ((fConst4286 * (((fConst4288 * fRec790[0]) + (fConst4314 * fRec790[1])) + (fConst4288 * fRec790[2]))) - (fConst4282 * ((fConst4315 * fRec789[2]) + (fConst4316 * fRec789[1]))));
			fRec788[0] = ((fSlow1 * fRec788[1]) + (fSlow2 * std::fabs((fConst4282 * (((fConst4285 * fRec789[0]) + (fConst4317 * fRec789[1])) + (fConst4285 * fRec789[2]))))));
			fVbargraph113 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec788[0])))));
			fRec801[0] = (fTemp113 - (fConst4334 * ((fConst4337 * fRec801[2]) + (fConst4338 * fRec801[1]))));
			fRec800[0] = ((fConst4334 * (((fConst4336 * fRec801[0]) + (fConst4339 * fRec801[1])) + (fConst4336 * fRec801[2]))) - (fConst4332 * ((fConst4340 * fRec800[2]) + (fConst4341 * fRec800[1]))));
			fRec799[0] = ((fConst4332 * (((fConst4333 * fRec800[0]) + (fConst4342 * fRec800[1])) + (fConst4333 * fRec800[2]))) - (fConst4330 * ((fConst4343 * fRec799[2]) + (fConst4344 * fRec799[1]))));
			float fTemp114 = (fConst4330 * (((fConst4331 * fRec799[0]) + (fConst4345 * fRec799[1])) + (fConst4331 * fRec799[2])));
			fRec798[0] = (fTemp114 - (fConst4327 * ((fConst4346 * fRec798[2]) + (fConst4348 * fRec798[1]))));
			fRec797[0] = ((fConst4327 * (((fConst4329 * fRec798[0]) + (fConst4349 * fRec798[1])) + (fConst4329 * fRec798[2]))) - (fConst4324 * ((fConst4350 * fRec797[2]) + (fConst4351 * fRec797[1]))));
			fRec796[0] = ((fConst4324 * (((fConst4326 * fRec797[0]) + (fConst4352 * fRec797[1])) + (fConst4326 * fRec797[2]))) - (fConst4320 * ((fConst4353 * fRec796[2]) + (fConst4354 * fRec796[1]))));
			fRec795[0] = ((fSlow1 * fRec795[1]) + (fSlow2 * std::fabs((fConst4320 * (((fConst4323 * fRec796[0]) + (fConst4355 * fRec796[1])) + (fConst4323 * fRec796[2]))))));
			fVbargraph114 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec795[0])))));
			fRec808[0] = (fTemp114 - (fConst4372 * ((fConst4375 * fRec808[2]) + (fConst4376 * fRec808[1]))));
			fRec807[0] = ((fConst4372 * (((fConst4374 * fRec808[0]) + (fConst4377 * fRec808[1])) + (fConst4374 * fRec808[2]))) - (fConst4370 * ((fConst4378 * fRec807[2]) + (fConst4379 * fRec807[1]))));
			fRec806[0] = ((fConst4370 * (((fConst4371 * fRec807[0]) + (fConst4380 * fRec807[1])) + (fConst4371 * fRec807[2]))) - (fConst4368 * ((fConst4381 * fRec806[2]) + (fConst4382 * fRec806[1]))));
			float fTemp115 = (fConst4368 * (((fConst4369 * fRec806[0]) + (fConst4383 * fRec806[1])) + (fConst4369 * fRec806[2])));
			fRec805[0] = (fTemp115 - (fConst4365 * ((fConst4384 * fRec805[2]) + (fConst4386 * fRec805[1]))));
			fRec804[0] = ((fConst4365 * (((fConst4367 * fRec805[0]) + (fConst4387 * fRec805[1])) + (fConst4367 * fRec805[2]))) - (fConst4362 * ((fConst4388 * fRec804[2]) + (fConst4389 * fRec804[1]))));
			fRec803[0] = ((fConst4362 * (((fConst4364 * fRec804[0]) + (fConst4390 * fRec804[1])) + (fConst4364 * fRec804[2]))) - (fConst4358 * ((fConst4391 * fRec803[2]) + (fConst4392 * fRec803[1]))));
			fRec802[0] = ((fSlow1 * fRec802[1]) + (fSlow2 * std::fabs((fConst4358 * (((fConst4361 * fRec803[0]) + (fConst4393 * fRec803[1])) + (fConst4361 * fRec803[2]))))));
			fVbargraph115 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec802[0])))));
			fRec815[0] = (fTemp115 - (fConst4410 * ((fConst4413 * fRec815[2]) + (fConst4414 * fRec815[1]))));
			fRec814[0] = ((fConst4410 * (((fConst4412 * fRec815[0]) + (fConst4415 * fRec815[1])) + (fConst4412 * fRec815[2]))) - (fConst4408 * ((fConst4416 * fRec814[2]) + (fConst4417 * fRec814[1]))));
			fRec813[0] = ((fConst4408 * (((fConst4409 * fRec814[0]) + (fConst4418 * fRec814[1])) + (fConst4409 * fRec814[2]))) - (fConst4406 * ((fConst4419 * fRec813[2]) + (fConst4420 * fRec813[1]))));
			float fTemp116 = (fConst4406 * (((fConst4407 * fRec813[0]) + (fConst4421 * fRec813[1])) + (fConst4407 * fRec813[2])));
			fRec812[0] = (fTemp116 - (fConst4403 * ((fConst4422 * fRec812[2]) + (fConst4424 * fRec812[1]))));
			fRec811[0] = ((fConst4403 * (((fConst4405 * fRec812[0]) + (fConst4425 * fRec812[1])) + (fConst4405 * fRec812[2]))) - (fConst4400 * ((fConst4426 * fRec811[2]) + (fConst4427 * fRec811[1]))));
			fRec810[0] = ((fConst4400 * (((fConst4402 * fRec811[0]) + (fConst4428 * fRec811[1])) + (fConst4402 * fRec811[2]))) - (fConst4396 * ((fConst4429 * fRec810[2]) + (fConst4430 * fRec810[1]))));
			fRec809[0] = ((fSlow1 * fRec809[1]) + (fSlow2 * std::fabs((fConst4396 * (((fConst4399 * fRec810[0]) + (fConst4431 * fRec810[1])) + (fConst4399 * fRec810[2]))))));
			fVbargraph116 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec809[0])))));
			fRec822[0] = (fTemp116 - (fConst4448 * ((fConst4451 * fRec822[2]) + (fConst4452 * fRec822[1]))));
			fRec821[0] = ((fConst4448 * (((fConst4450 * fRec822[0]) + (fConst4453 * fRec822[1])) + (fConst4450 * fRec822[2]))) - (fConst4446 * ((fConst4454 * fRec821[2]) + (fConst4455 * fRec821[1]))));
			fRec820[0] = ((fConst4446 * (((fConst4447 * fRec821[0]) + (fConst4456 * fRec821[1])) + (fConst4447 * fRec821[2]))) - (fConst4444 * ((fConst4457 * fRec820[2]) + (fConst4458 * fRec820[1]))));
			float fTemp117 = (fConst4444 * (((fConst4445 * fRec820[0]) + (fConst4459 * fRec820[1])) + (fConst4445 * fRec820[2])));
			fRec819[0] = (fTemp117 - (fConst4441 * ((fConst4460 * fRec819[2]) + (fConst4462 * fRec819[1]))));
			fRec818[0] = ((fConst4441 * (((fConst4443 * fRec819[0]) + (fConst4463 * fRec819[1])) + (fConst4443 * fRec819[2]))) - (fConst4438 * ((fConst4464 * fRec818[2]) + (fConst4465 * fRec818[1]))));
			fRec817[0] = ((fConst4438 * (((fConst4440 * fRec818[0]) + (fConst4466 * fRec818[1])) + (fConst4440 * fRec818[2]))) - (fConst4434 * ((fConst4467 * fRec817[2]) + (fConst4468 * fRec817[1]))));
			fRec816[0] = ((fSlow1 * fRec816[1]) + (fSlow2 * std::fabs((fConst4434 * (((fConst4437 * fRec817[0]) + (fConst4469 * fRec817[1])) + (fConst4437 * fRec817[2]))))));
			fVbargraph117 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec816[0])))));
			fRec829[0] = (fTemp117 - (fConst4486 * ((fConst4489 * fRec829[2]) + (fConst4490 * fRec829[1]))));
			fRec828[0] = ((fConst4486 * (((fConst4488 * fRec829[0]) + (fConst4491 * fRec829[1])) + (fConst4488 * fRec829[2]))) - (fConst4484 * ((fConst4492 * fRec828[2]) + (fConst4493 * fRec828[1]))));
			fRec827[0] = ((fConst4484 * (((fConst4485 * fRec828[0]) + (fConst4494 * fRec828[1])) + (fConst4485 * fRec828[2]))) - (fConst4482 * ((fConst4495 * fRec827[2]) + (fConst4496 * fRec827[1]))));
			float fTemp118 = (fConst4482 * (((fConst4483 * fRec827[0]) + (fConst4497 * fRec827[1])) + (fConst4483 * fRec827[2])));
			fRec826[0] = (fTemp118 - (fConst4479 * ((fConst4498 * fRec826[2]) + (fConst4500 * fRec826[1]))));
			fRec825[0] = ((fConst4479 * (((fConst4481 * fRec826[0]) + (fConst4501 * fRec826[1])) + (fConst4481 * fRec826[2]))) - (fConst4476 * ((fConst4502 * fRec825[2]) + (fConst4503 * fRec825[1]))));
			fRec824[0] = ((fConst4476 * (((fConst4478 * fRec825[0]) + (fConst4504 * fRec825[1])) + (fConst4478 * fRec825[2]))) - (fConst4472 * ((fConst4505 * fRec824[2]) + (fConst4506 * fRec824[1]))));
			fRec823[0] = ((fSlow1 * fRec823[1]) + (fSlow2 * std::fabs((fConst4472 * (((fConst4475 * fRec824[0]) + (fConst4507 * fRec824[1])) + (fConst4475 * fRec824[2]))))));
			fVbargraph118 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec823[0])))));
			fRec833[0] = (fTemp118 - (fConst4512 * ((fConst4515 * fRec833[2]) + (fConst4516 * fRec833[1]))));
			fRec832[0] = ((fConst4512 * (((fConst4514 * fRec833[0]) + (fConst4517 * fRec833[1])) + (fConst4514 * fRec833[2]))) - (fConst4510 * ((fConst4518 * fRec832[2]) + (fConst4519 * fRec832[1]))));
			fRec831[0] = ((fConst4510 * (((fConst4511 * fRec832[0]) + (fConst4520 * fRec832[1])) + (fConst4511 * fRec832[2]))) - (fConst4508 * ((fConst4521 * fRec831[2]) + (fConst4522 * fRec831[1]))));
			fRec830[0] = ((fSlow1 * fRec830[1]) + (fSlow2 * std::fabs((fConst4508 * (((fConst4509 * fRec831[0]) + (fConst4523 * fRec831[1])) + (fConst4509 * fRec831[2]))))));
			fVbargraph119 = FAUSTFLOAT((fSlow0 + (20.0f * std::log10(std::max<float>(1.00000001e-07f, fRec830[0])))));
			
		
			allsamples[0] = fVbargraph0;
			allsamples[1] = fVbargraph1;
			allsamples[2] = fVbargraph2;
			allsamples[3] = fVbargraph3;
			allsamples[4] = fVbargraph4;
			allsamples[5] = fVbargraph5;
			allsamples[6] = fVbargraph6;
			allsamples[7] = fVbargraph7;
			allsamples[8] = fVbargraph8;
			allsamples[9] = fVbargraph9;

			allsamples[10] = fVbargraph10;
			allsamples[11] = fVbargraph11;
			allsamples[12] = fVbargraph12;
			allsamples[13] = fVbargraph13;
			allsamples[14] = fVbargraph14;
			allsamples[15] = fVbargraph15;
			allsamples[16] = fVbargraph16;
			allsamples[17] = fVbargraph17;
			allsamples[18] = fVbargraph18;
			allsamples[19] = fVbargraph19;

			allsamples[20] = fVbargraph20;
			allsamples[21] = fVbargraph21;
			allsamples[22] = fVbargraph22;
			allsamples[23] = fVbargraph23;
			allsamples[24] = fVbargraph24;
			allsamples[25] = fVbargraph25;
			allsamples[26] = fVbargraph26;
			allsamples[27] = fVbargraph27;
			allsamples[28] = fVbargraph28;
			allsamples[29] = fVbargraph29;

			allsamples[30] = fVbargraph30;
			allsamples[31] = fVbargraph31;
			allsamples[32] = fVbargraph32;
			allsamples[33] = fVbargraph33;
			allsamples[34] = fVbargraph34;
			allsamples[35] = fVbargraph35;
			allsamples[36] = fVbargraph36;
			allsamples[37] = fVbargraph37;
			allsamples[38] = fVbargraph38;
			allsamples[39] = fVbargraph39;

			allsamples[40] = fVbargraph40;
			allsamples[41] = fVbargraph41;
			allsamples[42] = fVbargraph42;
			allsamples[43] = fVbargraph43;
			allsamples[44] = fVbargraph44;
			allsamples[45] = fVbargraph45;
			allsamples[46] = fVbargraph46;
			allsamples[47] = fVbargraph47;
			allsamples[48] = fVbargraph48;
			allsamples[49] = fVbargraph49;

			allsamples[50] = fVbargraph50;
			allsamples[51] = fVbargraph51;
			allsamples[52] = fVbargraph52;
			allsamples[53] = fVbargraph53;
			allsamples[54] = fVbargraph54;
			allsamples[55] = fVbargraph55;
			allsamples[56] = fVbargraph56;
			allsamples[57] = fVbargraph57;
			allsamples[58] = fVbargraph58;
			allsamples[59] = fVbargraph59;

			allsamples[60] = fVbargraph60;
			allsamples[61] = fVbargraph61;
			allsamples[62] = fVbargraph62;
			allsamples[63] = fVbargraph63;
			allsamples[64] = fVbargraph64;
			allsamples[65] = fVbargraph65;
			allsamples[66] = fVbargraph66;
			allsamples[67] = fVbargraph67;
			allsamples[68] = fVbargraph68;
			allsamples[69] = fVbargraph69;

			allsamples[70] = fVbargraph70;
			allsamples[71] = fVbargraph71;
			allsamples[72] = fVbargraph72;
			allsamples[73] = fVbargraph73;
			allsamples[74] = fVbargraph74;
			allsamples[75] = fVbargraph75;
			allsamples[76] = fVbargraph76;
			allsamples[77] = fVbargraph77;
			allsamples[78] = fVbargraph78;
			allsamples[79] = fVbargraph79;

			allsamples[80] = fVbargraph80;
			allsamples[81] = fVbargraph81;
			allsamples[82] = fVbargraph82;
			allsamples[83] = fVbargraph83;
			allsamples[84] = fVbargraph84;
			allsamples[85] = fVbargraph85;
			allsamples[86] = fVbargraph86;
			allsamples[87] = fVbargraph87;
			allsamples[88] = fVbargraph88;
			allsamples[89] = fVbargraph89;

			allsamples[90] = fVbargraph90;
			allsamples[91] = fVbargraph91;
			allsamples[92] = fVbargraph92;
			allsamples[93] = fVbargraph93;
			allsamples[94] = fVbargraph94;
			allsamples[95] = fVbargraph95;
			allsamples[96] = fVbargraph96;
			allsamples[97] = fVbargraph97;
			allsamples[98] = fVbargraph98;
			allsamples[99] = fVbargraph99;

			allsamples[100] = fVbargraph100;
			allsamples[101] = fVbargraph101;
			allsamples[102] = fVbargraph102;
			allsamples[103] = fVbargraph103;
			allsamples[104] = fVbargraph104;
			allsamples[105] = fVbargraph105;
			allsamples[106] = fVbargraph106;
			allsamples[107] = fVbargraph107;
			allsamples[108] = fVbargraph108;
			allsamples[109] = fVbargraph109;

			allsamples[110] = fVbargraph110;
			allsamples[111] = fVbargraph111;
			allsamples[112] = fVbargraph112;
			allsamples[113] = fVbargraph113;
			allsamples[114] = fVbargraph114;
			allsamples[115] = fVbargraph115;
			allsamples[116] = fVbargraph116;
			allsamples[117] = fVbargraph117;
			allsamples[118] = fVbargraph118;
			allsamples[119] = fVbargraph119;

			max = -50;
			for (int l = 0; l < 120; l++)
			{
				if (allsamples[l] > max)
				{
					max = allsamples[l];
					maxnum = 119 - l;
				};
			};

			









			/*if (maxnum > 50)
			{
				sNote = "aa";
			}
			else
			{
				sNote = "tt";
			}*/
			//sNote = str;*/

			//std::cout << str << std::endl;
			//std::cout << sNote << std::endl;



			output0[i] = FAUSTFLOAT(fTemp0);
			fRec3[2] = fRec3[1];
			fRec3[1] = fRec3[0];
			fRec2[2] = fRec2[1];
			fRec2[1] = fRec2[0];
			fRec1[2] = fRec1[1];
			fRec1[1] = fRec1[0];
			fRec0[1] = fRec0[0];
			fRec10[2] = fRec10[1];
			fRec10[1] = fRec10[0];
			fRec9[2] = fRec9[1];
			fRec9[1] = fRec9[0];
			fRec8[2] = fRec8[1];
			fRec8[1] = fRec8[0];
			fRec7[2] = fRec7[1];
			fRec7[1] = fRec7[0];
			fRec6[2] = fRec6[1];
			fRec6[1] = fRec6[0];
			fRec5[2] = fRec5[1];
			fRec5[1] = fRec5[0];
			fRec4[1] = fRec4[0];
			fRec17[2] = fRec17[1];
			fRec17[1] = fRec17[0];
			fRec16[2] = fRec16[1];
			fRec16[1] = fRec16[0];
			fRec15[2] = fRec15[1];
			fRec15[1] = fRec15[0];
			fRec14[2] = fRec14[1];
			fRec14[1] = fRec14[0];
			fRec13[2] = fRec13[1];
			fRec13[1] = fRec13[0];
			fRec12[2] = fRec12[1];
			fRec12[1] = fRec12[0];
			fRec11[1] = fRec11[0];
			fRec24[2] = fRec24[1];
			fRec24[1] = fRec24[0];
			fRec23[2] = fRec23[1];
			fRec23[1] = fRec23[0];
			fRec22[2] = fRec22[1];
			fRec22[1] = fRec22[0];
			fRec21[2] = fRec21[1];
			fRec21[1] = fRec21[0];
			fRec20[2] = fRec20[1];
			fRec20[1] = fRec20[0];
			fRec19[2] = fRec19[1];
			fRec19[1] = fRec19[0];
			fRec18[1] = fRec18[0];
			fRec31[2] = fRec31[1];
			fRec31[1] = fRec31[0];
			fRec30[2] = fRec30[1];
			fRec30[1] = fRec30[0];
			fRec29[2] = fRec29[1];
			fRec29[1] = fRec29[0];
			fRec28[2] = fRec28[1];
			fRec28[1] = fRec28[0];
			fRec27[2] = fRec27[1];
			fRec27[1] = fRec27[0];
			fRec26[2] = fRec26[1];
			fRec26[1] = fRec26[0];
			fRec25[1] = fRec25[0];
			fRec38[2] = fRec38[1];
			fRec38[1] = fRec38[0];
			fRec37[2] = fRec37[1];
			fRec37[1] = fRec37[0];
			fRec36[2] = fRec36[1];
			fRec36[1] = fRec36[0];
			fRec35[2] = fRec35[1];
			fRec35[1] = fRec35[0];
			fRec34[2] = fRec34[1];
			fRec34[1] = fRec34[0];
			fRec33[2] = fRec33[1];
			fRec33[1] = fRec33[0];
			fRec32[1] = fRec32[0];
			fRec45[2] = fRec45[1];
			fRec45[1] = fRec45[0];
			fRec44[2] = fRec44[1];
			fRec44[1] = fRec44[0];
			fRec43[2] = fRec43[1];
			fRec43[1] = fRec43[0];
			fRec42[2] = fRec42[1];
			fRec42[1] = fRec42[0];
			fRec41[2] = fRec41[1];
			fRec41[1] = fRec41[0];
			fRec40[2] = fRec40[1];
			fRec40[1] = fRec40[0];
			fRec39[1] = fRec39[0];
			fRec52[2] = fRec52[1];
			fRec52[1] = fRec52[0];
			fRec51[2] = fRec51[1];
			fRec51[1] = fRec51[0];
			fRec50[2] = fRec50[1];
			fRec50[1] = fRec50[0];
			fRec49[2] = fRec49[1];
			fRec49[1] = fRec49[0];
			fRec48[2] = fRec48[1];
			fRec48[1] = fRec48[0];
			fRec47[2] = fRec47[1];
			fRec47[1] = fRec47[0];
			fRec46[1] = fRec46[0];
			fRec59[2] = fRec59[1];
			fRec59[1] = fRec59[0];
			fRec58[2] = fRec58[1];
			fRec58[1] = fRec58[0];
			fRec57[2] = fRec57[1];
			fRec57[1] = fRec57[0];
			fRec56[2] = fRec56[1];
			fRec56[1] = fRec56[0];
			fRec55[2] = fRec55[1];
			fRec55[1] = fRec55[0];
			fRec54[2] = fRec54[1];
			fRec54[1] = fRec54[0];
			fRec53[1] = fRec53[0];
			fRec66[2] = fRec66[1];
			fRec66[1] = fRec66[0];
			fRec65[2] = fRec65[1];
			fRec65[1] = fRec65[0];
			fRec64[2] = fRec64[1];
			fRec64[1] = fRec64[0];
			fRec63[2] = fRec63[1];
			fRec63[1] = fRec63[0];
			fRec62[2] = fRec62[1];
			fRec62[1] = fRec62[0];
			fRec61[2] = fRec61[1];
			fRec61[1] = fRec61[0];
			fRec60[1] = fRec60[0];
			fRec73[2] = fRec73[1];
			fRec73[1] = fRec73[0];
			fRec72[2] = fRec72[1];
			fRec72[1] = fRec72[0];
			fRec71[2] = fRec71[1];
			fRec71[1] = fRec71[0];
			fRec70[2] = fRec70[1];
			fRec70[1] = fRec70[0];
			fRec69[2] = fRec69[1];
			fRec69[1] = fRec69[0];
			fRec68[2] = fRec68[1];
			fRec68[1] = fRec68[0];
			fRec67[1] = fRec67[0];
			fRec80[2] = fRec80[1];
			fRec80[1] = fRec80[0];
			fRec79[2] = fRec79[1];
			fRec79[1] = fRec79[0];
			fRec78[2] = fRec78[1];
			fRec78[1] = fRec78[0];
			fRec77[2] = fRec77[1];
			fRec77[1] = fRec77[0];
			fRec76[2] = fRec76[1];
			fRec76[1] = fRec76[0];
			fRec75[2] = fRec75[1];
			fRec75[1] = fRec75[0];
			fRec74[1] = fRec74[0];
			fRec87[2] = fRec87[1];
			fRec87[1] = fRec87[0];
			fRec86[2] = fRec86[1];
			fRec86[1] = fRec86[0];
			fRec85[2] = fRec85[1];
			fRec85[1] = fRec85[0];
			fRec84[2] = fRec84[1];
			fRec84[1] = fRec84[0];
			fRec83[2] = fRec83[1];
			fRec83[1] = fRec83[0];
			fRec82[2] = fRec82[1];
			fRec82[1] = fRec82[0];
			fRec81[1] = fRec81[0];
			fRec94[2] = fRec94[1];
			fRec94[1] = fRec94[0];
			fRec93[2] = fRec93[1];
			fRec93[1] = fRec93[0];
			fRec92[2] = fRec92[1];
			fRec92[1] = fRec92[0];
			fRec91[2] = fRec91[1];
			fRec91[1] = fRec91[0];
			fRec90[2] = fRec90[1];
			fRec90[1] = fRec90[0];
			fRec89[2] = fRec89[1];
			fRec89[1] = fRec89[0];
			fRec88[1] = fRec88[0];
			fRec101[2] = fRec101[1];
			fRec101[1] = fRec101[0];
			fRec100[2] = fRec100[1];
			fRec100[1] = fRec100[0];
			fRec99[2] = fRec99[1];
			fRec99[1] = fRec99[0];
			fRec98[2] = fRec98[1];
			fRec98[1] = fRec98[0];
			fRec97[2] = fRec97[1];
			fRec97[1] = fRec97[0];
			fRec96[2] = fRec96[1];
			fRec96[1] = fRec96[0];
			fRec95[1] = fRec95[0];
			fRec108[2] = fRec108[1];
			fRec108[1] = fRec108[0];
			fRec107[2] = fRec107[1];
			fRec107[1] = fRec107[0];
			fRec106[2] = fRec106[1];
			fRec106[1] = fRec106[0];
			fRec105[2] = fRec105[1];
			fRec105[1] = fRec105[0];
			fRec104[2] = fRec104[1];
			fRec104[1] = fRec104[0];
			fRec103[2] = fRec103[1];
			fRec103[1] = fRec103[0];
			fRec102[1] = fRec102[0];
			fRec115[2] = fRec115[1];
			fRec115[1] = fRec115[0];
			fRec114[2] = fRec114[1];
			fRec114[1] = fRec114[0];
			fRec113[2] = fRec113[1];
			fRec113[1] = fRec113[0];
			fRec112[2] = fRec112[1];
			fRec112[1] = fRec112[0];
			fRec111[2] = fRec111[1];
			fRec111[1] = fRec111[0];
			fRec110[2] = fRec110[1];
			fRec110[1] = fRec110[0];
			fRec109[1] = fRec109[0];
			fRec122[2] = fRec122[1];
			fRec122[1] = fRec122[0];
			fRec121[2] = fRec121[1];
			fRec121[1] = fRec121[0];
			fRec120[2] = fRec120[1];
			fRec120[1] = fRec120[0];
			fRec119[2] = fRec119[1];
			fRec119[1] = fRec119[0];
			fRec118[2] = fRec118[1];
			fRec118[1] = fRec118[0];
			fRec117[2] = fRec117[1];
			fRec117[1] = fRec117[0];
			fRec116[1] = fRec116[0];
			fRec129[2] = fRec129[1];
			fRec129[1] = fRec129[0];
			fRec128[2] = fRec128[1];
			fRec128[1] = fRec128[0];
			fRec127[2] = fRec127[1];
			fRec127[1] = fRec127[0];
			fRec126[2] = fRec126[1];
			fRec126[1] = fRec126[0];
			fRec125[2] = fRec125[1];
			fRec125[1] = fRec125[0];
			fRec124[2] = fRec124[1];
			fRec124[1] = fRec124[0];
			fRec123[1] = fRec123[0];
			fRec136[2] = fRec136[1];
			fRec136[1] = fRec136[0];
			fRec135[2] = fRec135[1];
			fRec135[1] = fRec135[0];
			fRec134[2] = fRec134[1];
			fRec134[1] = fRec134[0];
			fRec133[2] = fRec133[1];
			fRec133[1] = fRec133[0];
			fRec132[2] = fRec132[1];
			fRec132[1] = fRec132[0];
			fRec131[2] = fRec131[1];
			fRec131[1] = fRec131[0];
			fRec130[1] = fRec130[0];
			fRec143[2] = fRec143[1];
			fRec143[1] = fRec143[0];
			fRec142[2] = fRec142[1];
			fRec142[1] = fRec142[0];
			fRec141[2] = fRec141[1];
			fRec141[1] = fRec141[0];
			fRec140[2] = fRec140[1];
			fRec140[1] = fRec140[0];
			fRec139[2] = fRec139[1];
			fRec139[1] = fRec139[0];
			fRec138[2] = fRec138[1];
			fRec138[1] = fRec138[0];
			fRec137[1] = fRec137[0];
			fRec150[2] = fRec150[1];
			fRec150[1] = fRec150[0];
			fRec149[2] = fRec149[1];
			fRec149[1] = fRec149[0];
			fRec148[2] = fRec148[1];
			fRec148[1] = fRec148[0];
			fRec147[2] = fRec147[1];
			fRec147[1] = fRec147[0];
			fRec146[2] = fRec146[1];
			fRec146[1] = fRec146[0];
			fRec145[2] = fRec145[1];
			fRec145[1] = fRec145[0];
			fRec144[1] = fRec144[0];
			fRec157[2] = fRec157[1];
			fRec157[1] = fRec157[0];
			fRec156[2] = fRec156[1];
			fRec156[1] = fRec156[0];
			fRec155[2] = fRec155[1];
			fRec155[1] = fRec155[0];
			fRec154[2] = fRec154[1];
			fRec154[1] = fRec154[0];
			fRec153[2] = fRec153[1];
			fRec153[1] = fRec153[0];
			fRec152[2] = fRec152[1];
			fRec152[1] = fRec152[0];
			fRec151[1] = fRec151[0];
			fRec164[2] = fRec164[1];
			fRec164[1] = fRec164[0];
			fRec163[2] = fRec163[1];
			fRec163[1] = fRec163[0];
			fRec162[2] = fRec162[1];
			fRec162[1] = fRec162[0];
			fRec161[2] = fRec161[1];
			fRec161[1] = fRec161[0];
			fRec160[2] = fRec160[1];
			fRec160[1] = fRec160[0];
			fRec159[2] = fRec159[1];
			fRec159[1] = fRec159[0];
			fRec158[1] = fRec158[0];
			fRec171[2] = fRec171[1];
			fRec171[1] = fRec171[0];
			fRec170[2] = fRec170[1];
			fRec170[1] = fRec170[0];
			fRec169[2] = fRec169[1];
			fRec169[1] = fRec169[0];
			fRec168[2] = fRec168[1];
			fRec168[1] = fRec168[0];
			fRec167[2] = fRec167[1];
			fRec167[1] = fRec167[0];
			fRec166[2] = fRec166[1];
			fRec166[1] = fRec166[0];
			fRec165[1] = fRec165[0];
			fRec178[2] = fRec178[1];
			fRec178[1] = fRec178[0];
			fRec177[2] = fRec177[1];
			fRec177[1] = fRec177[0];
			fRec176[2] = fRec176[1];
			fRec176[1] = fRec176[0];
			fRec175[2] = fRec175[1];
			fRec175[1] = fRec175[0];
			fRec174[2] = fRec174[1];
			fRec174[1] = fRec174[0];
			fRec173[2] = fRec173[1];
			fRec173[1] = fRec173[0];
			fRec172[1] = fRec172[0];
			fRec185[2] = fRec185[1];
			fRec185[1] = fRec185[0];
			fRec184[2] = fRec184[1];
			fRec184[1] = fRec184[0];
			fRec183[2] = fRec183[1];
			fRec183[1] = fRec183[0];
			fRec182[2] = fRec182[1];
			fRec182[1] = fRec182[0];
			fRec181[2] = fRec181[1];
			fRec181[1] = fRec181[0];
			fRec180[2] = fRec180[1];
			fRec180[1] = fRec180[0];
			fRec179[1] = fRec179[0];
			fRec192[2] = fRec192[1];
			fRec192[1] = fRec192[0];
			fRec191[2] = fRec191[1];
			fRec191[1] = fRec191[0];
			fRec190[2] = fRec190[1];
			fRec190[1] = fRec190[0];
			fRec189[2] = fRec189[1];
			fRec189[1] = fRec189[0];
			fRec188[2] = fRec188[1];
			fRec188[1] = fRec188[0];
			fRec187[2] = fRec187[1];
			fRec187[1] = fRec187[0];
			fRec186[1] = fRec186[0];
			fRec199[2] = fRec199[1];
			fRec199[1] = fRec199[0];
			fRec198[2] = fRec198[1];
			fRec198[1] = fRec198[0];
			fRec197[2] = fRec197[1];
			fRec197[1] = fRec197[0];
			fRec196[2] = fRec196[1];
			fRec196[1] = fRec196[0];
			fRec195[2] = fRec195[1];
			fRec195[1] = fRec195[0];
			fRec194[2] = fRec194[1];
			fRec194[1] = fRec194[0];
			fRec193[1] = fRec193[0];
			fRec206[2] = fRec206[1];
			fRec206[1] = fRec206[0];
			fRec205[2] = fRec205[1];
			fRec205[1] = fRec205[0];
			fRec204[2] = fRec204[1];
			fRec204[1] = fRec204[0];
			fRec203[2] = fRec203[1];
			fRec203[1] = fRec203[0];
			fRec202[2] = fRec202[1];
			fRec202[1] = fRec202[0];
			fRec201[2] = fRec201[1];
			fRec201[1] = fRec201[0];
			fRec200[1] = fRec200[0];
			fRec213[2] = fRec213[1];
			fRec213[1] = fRec213[0];
			fRec212[2] = fRec212[1];
			fRec212[1] = fRec212[0];
			fRec211[2] = fRec211[1];
			fRec211[1] = fRec211[0];
			fRec210[2] = fRec210[1];
			fRec210[1] = fRec210[0];
			fRec209[2] = fRec209[1];
			fRec209[1] = fRec209[0];
			fRec208[2] = fRec208[1];
			fRec208[1] = fRec208[0];
			fRec207[1] = fRec207[0];
			fRec220[2] = fRec220[1];
			fRec220[1] = fRec220[0];
			fRec219[2] = fRec219[1];
			fRec219[1] = fRec219[0];
			fRec218[2] = fRec218[1];
			fRec218[1] = fRec218[0];
			fRec217[2] = fRec217[1];
			fRec217[1] = fRec217[0];
			fRec216[2] = fRec216[1];
			fRec216[1] = fRec216[0];
			fRec215[2] = fRec215[1];
			fRec215[1] = fRec215[0];
			fRec214[1] = fRec214[0];
			fRec227[2] = fRec227[1];
			fRec227[1] = fRec227[0];
			fRec226[2] = fRec226[1];
			fRec226[1] = fRec226[0];
			fRec225[2] = fRec225[1];
			fRec225[1] = fRec225[0];
			fRec224[2] = fRec224[1];
			fRec224[1] = fRec224[0];
			fRec223[2] = fRec223[1];
			fRec223[1] = fRec223[0];
			fRec222[2] = fRec222[1];
			fRec222[1] = fRec222[0];
			fRec221[1] = fRec221[0];
			fRec234[2] = fRec234[1];
			fRec234[1] = fRec234[0];
			fRec233[2] = fRec233[1];
			fRec233[1] = fRec233[0];
			fRec232[2] = fRec232[1];
			fRec232[1] = fRec232[0];
			fRec231[2] = fRec231[1];
			fRec231[1] = fRec231[0];
			fRec230[2] = fRec230[1];
			fRec230[1] = fRec230[0];
			fRec229[2] = fRec229[1];
			fRec229[1] = fRec229[0];
			fRec228[1] = fRec228[0];
			fRec241[2] = fRec241[1];
			fRec241[1] = fRec241[0];
			fRec240[2] = fRec240[1];
			fRec240[1] = fRec240[0];
			fRec239[2] = fRec239[1];
			fRec239[1] = fRec239[0];
			fRec238[2] = fRec238[1];
			fRec238[1] = fRec238[0];
			fRec237[2] = fRec237[1];
			fRec237[1] = fRec237[0];
			fRec236[2] = fRec236[1];
			fRec236[1] = fRec236[0];
			fRec235[1] = fRec235[0];
			fRec248[2] = fRec248[1];
			fRec248[1] = fRec248[0];
			fRec247[2] = fRec247[1];
			fRec247[1] = fRec247[0];
			fRec246[2] = fRec246[1];
			fRec246[1] = fRec246[0];
			fRec245[2] = fRec245[1];
			fRec245[1] = fRec245[0];
			fRec244[2] = fRec244[1];
			fRec244[1] = fRec244[0];
			fRec243[2] = fRec243[1];
			fRec243[1] = fRec243[0];
			fRec242[1] = fRec242[0];
			fRec255[2] = fRec255[1];
			fRec255[1] = fRec255[0];
			fRec254[2] = fRec254[1];
			fRec254[1] = fRec254[0];
			fRec253[2] = fRec253[1];
			fRec253[1] = fRec253[0];
			fRec252[2] = fRec252[1];
			fRec252[1] = fRec252[0];
			fRec251[2] = fRec251[1];
			fRec251[1] = fRec251[0];
			fRec250[2] = fRec250[1];
			fRec250[1] = fRec250[0];
			fRec249[1] = fRec249[0];
			fRec262[2] = fRec262[1];
			fRec262[1] = fRec262[0];
			fRec261[2] = fRec261[1];
			fRec261[1] = fRec261[0];
			fRec260[2] = fRec260[1];
			fRec260[1] = fRec260[0];
			fRec259[2] = fRec259[1];
			fRec259[1] = fRec259[0];
			fRec258[2] = fRec258[1];
			fRec258[1] = fRec258[0];
			fRec257[2] = fRec257[1];
			fRec257[1] = fRec257[0];
			fRec256[1] = fRec256[0];
			fRec269[2] = fRec269[1];
			fRec269[1] = fRec269[0];
			fRec268[2] = fRec268[1];
			fRec268[1] = fRec268[0];
			fRec267[2] = fRec267[1];
			fRec267[1] = fRec267[0];
			fRec266[2] = fRec266[1];
			fRec266[1] = fRec266[0];
			fRec265[2] = fRec265[1];
			fRec265[1] = fRec265[0];
			fRec264[2] = fRec264[1];
			fRec264[1] = fRec264[0];
			fRec263[1] = fRec263[0];
			fRec276[2] = fRec276[1];
			fRec276[1] = fRec276[0];
			fRec275[2] = fRec275[1];
			fRec275[1] = fRec275[0];
			fRec274[2] = fRec274[1];
			fRec274[1] = fRec274[0];
			fRec273[2] = fRec273[1];
			fRec273[1] = fRec273[0];
			fRec272[2] = fRec272[1];
			fRec272[1] = fRec272[0];
			fRec271[2] = fRec271[1];
			fRec271[1] = fRec271[0];
			fRec270[1] = fRec270[0];
			fRec283[2] = fRec283[1];
			fRec283[1] = fRec283[0];
			fRec282[2] = fRec282[1];
			fRec282[1] = fRec282[0];
			fRec281[2] = fRec281[1];
			fRec281[1] = fRec281[0];
			fRec280[2] = fRec280[1];
			fRec280[1] = fRec280[0];
			fRec279[2] = fRec279[1];
			fRec279[1] = fRec279[0];
			fRec278[2] = fRec278[1];
			fRec278[1] = fRec278[0];
			fRec277[1] = fRec277[0];
			fRec290[2] = fRec290[1];
			fRec290[1] = fRec290[0];
			fRec289[2] = fRec289[1];
			fRec289[1] = fRec289[0];
			fRec288[2] = fRec288[1];
			fRec288[1] = fRec288[0];
			fRec287[2] = fRec287[1];
			fRec287[1] = fRec287[0];
			fRec286[2] = fRec286[1];
			fRec286[1] = fRec286[0];
			fRec285[2] = fRec285[1];
			fRec285[1] = fRec285[0];
			fRec284[1] = fRec284[0];
			fRec297[2] = fRec297[1];
			fRec297[1] = fRec297[0];
			fRec296[2] = fRec296[1];
			fRec296[1] = fRec296[0];
			fRec295[2] = fRec295[1];
			fRec295[1] = fRec295[0];
			fRec294[2] = fRec294[1];
			fRec294[1] = fRec294[0];
			fRec293[2] = fRec293[1];
			fRec293[1] = fRec293[0];
			fRec292[2] = fRec292[1];
			fRec292[1] = fRec292[0];
			fRec291[1] = fRec291[0];
			fRec304[2] = fRec304[1];
			fRec304[1] = fRec304[0];
			fRec303[2] = fRec303[1];
			fRec303[1] = fRec303[0];
			fRec302[2] = fRec302[1];
			fRec302[1] = fRec302[0];
			fRec301[2] = fRec301[1];
			fRec301[1] = fRec301[0];
			fRec300[2] = fRec300[1];
			fRec300[1] = fRec300[0];
			fRec299[2] = fRec299[1];
			fRec299[1] = fRec299[0];
			fRec298[1] = fRec298[0];
			fRec311[2] = fRec311[1];
			fRec311[1] = fRec311[0];
			fRec310[2] = fRec310[1];
			fRec310[1] = fRec310[0];
			fRec309[2] = fRec309[1];
			fRec309[1] = fRec309[0];
			fRec308[2] = fRec308[1];
			fRec308[1] = fRec308[0];
			fRec307[2] = fRec307[1];
			fRec307[1] = fRec307[0];
			fRec306[2] = fRec306[1];
			fRec306[1] = fRec306[0];
			fRec305[1] = fRec305[0];
			fRec318[2] = fRec318[1];
			fRec318[1] = fRec318[0];
			fRec317[2] = fRec317[1];
			fRec317[1] = fRec317[0];
			fRec316[2] = fRec316[1];
			fRec316[1] = fRec316[0];
			fRec315[2] = fRec315[1];
			fRec315[1] = fRec315[0];
			fRec314[2] = fRec314[1];
			fRec314[1] = fRec314[0];
			fRec313[2] = fRec313[1];
			fRec313[1] = fRec313[0];
			fRec312[1] = fRec312[0];
			fRec325[2] = fRec325[1];
			fRec325[1] = fRec325[0];
			fRec324[2] = fRec324[1];
			fRec324[1] = fRec324[0];
			fRec323[2] = fRec323[1];
			fRec323[1] = fRec323[0];
			fRec322[2] = fRec322[1];
			fRec322[1] = fRec322[0];
			fRec321[2] = fRec321[1];
			fRec321[1] = fRec321[0];
			fRec320[2] = fRec320[1];
			fRec320[1] = fRec320[0];
			fRec319[1] = fRec319[0];
			fRec332[2] = fRec332[1];
			fRec332[1] = fRec332[0];
			fRec331[2] = fRec331[1];
			fRec331[1] = fRec331[0];
			fRec330[2] = fRec330[1];
			fRec330[1] = fRec330[0];
			fRec329[2] = fRec329[1];
			fRec329[1] = fRec329[0];
			fRec328[2] = fRec328[1];
			fRec328[1] = fRec328[0];
			fRec327[2] = fRec327[1];
			fRec327[1] = fRec327[0];
			fRec326[1] = fRec326[0];
			fRec339[2] = fRec339[1];
			fRec339[1] = fRec339[0];
			fRec338[2] = fRec338[1];
			fRec338[1] = fRec338[0];
			fRec337[2] = fRec337[1];
			fRec337[1] = fRec337[0];
			fRec336[2] = fRec336[1];
			fRec336[1] = fRec336[0];
			fRec335[2] = fRec335[1];
			fRec335[1] = fRec335[0];
			fRec334[2] = fRec334[1];
			fRec334[1] = fRec334[0];
			fRec333[1] = fRec333[0];
			fRec346[2] = fRec346[1];
			fRec346[1] = fRec346[0];
			fRec345[2] = fRec345[1];
			fRec345[1] = fRec345[0];
			fRec344[2] = fRec344[1];
			fRec344[1] = fRec344[0];
			fRec343[2] = fRec343[1];
			fRec343[1] = fRec343[0];
			fRec342[2] = fRec342[1];
			fRec342[1] = fRec342[0];
			fRec341[2] = fRec341[1];
			fRec341[1] = fRec341[0];
			fRec340[1] = fRec340[0];
			fRec353[2] = fRec353[1];
			fRec353[1] = fRec353[0];
			fRec352[2] = fRec352[1];
			fRec352[1] = fRec352[0];
			fRec351[2] = fRec351[1];
			fRec351[1] = fRec351[0];
			fRec350[2] = fRec350[1];
			fRec350[1] = fRec350[0];
			fRec349[2] = fRec349[1];
			fRec349[1] = fRec349[0];
			fRec348[2] = fRec348[1];
			fRec348[1] = fRec348[0];
			fRec347[1] = fRec347[0];
			fRec360[2] = fRec360[1];
			fRec360[1] = fRec360[0];
			fRec359[2] = fRec359[1];
			fRec359[1] = fRec359[0];
			fRec358[2] = fRec358[1];
			fRec358[1] = fRec358[0];
			fRec357[2] = fRec357[1];
			fRec357[1] = fRec357[0];
			fRec356[2] = fRec356[1];
			fRec356[1] = fRec356[0];
			fRec355[2] = fRec355[1];
			fRec355[1] = fRec355[0];
			fRec354[1] = fRec354[0];
			fRec367[2] = fRec367[1];
			fRec367[1] = fRec367[0];
			fRec366[2] = fRec366[1];
			fRec366[1] = fRec366[0];
			fRec365[2] = fRec365[1];
			fRec365[1] = fRec365[0];
			fRec364[2] = fRec364[1];
			fRec364[1] = fRec364[0];
			fRec363[2] = fRec363[1];
			fRec363[1] = fRec363[0];
			fRec362[2] = fRec362[1];
			fRec362[1] = fRec362[0];
			fRec361[1] = fRec361[0];
			fRec374[2] = fRec374[1];
			fRec374[1] = fRec374[0];
			fRec373[2] = fRec373[1];
			fRec373[1] = fRec373[0];
			fRec372[2] = fRec372[1];
			fRec372[1] = fRec372[0];
			fRec371[2] = fRec371[1];
			fRec371[1] = fRec371[0];
			fRec370[2] = fRec370[1];
			fRec370[1] = fRec370[0];
			fRec369[2] = fRec369[1];
			fRec369[1] = fRec369[0];
			fRec368[1] = fRec368[0];
			fRec381[2] = fRec381[1];
			fRec381[1] = fRec381[0];
			fRec380[2] = fRec380[1];
			fRec380[1] = fRec380[0];
			fRec379[2] = fRec379[1];
			fRec379[1] = fRec379[0];
			fRec378[2] = fRec378[1];
			fRec378[1] = fRec378[0];
			fRec377[2] = fRec377[1];
			fRec377[1] = fRec377[0];
			fRec376[2] = fRec376[1];
			fRec376[1] = fRec376[0];
			fRec375[1] = fRec375[0];
			fRec388[2] = fRec388[1];
			fRec388[1] = fRec388[0];
			fRec387[2] = fRec387[1];
			fRec387[1] = fRec387[0];
			fRec386[2] = fRec386[1];
			fRec386[1] = fRec386[0];
			fRec385[2] = fRec385[1];
			fRec385[1] = fRec385[0];
			fRec384[2] = fRec384[1];
			fRec384[1] = fRec384[0];
			fRec383[2] = fRec383[1];
			fRec383[1] = fRec383[0];
			fRec382[1] = fRec382[0];
			fRec395[2] = fRec395[1];
			fRec395[1] = fRec395[0];
			fRec394[2] = fRec394[1];
			fRec394[1] = fRec394[0];
			fRec393[2] = fRec393[1];
			fRec393[1] = fRec393[0];
			fRec392[2] = fRec392[1];
			fRec392[1] = fRec392[0];
			fRec391[2] = fRec391[1];
			fRec391[1] = fRec391[0];
			fRec390[2] = fRec390[1];
			fRec390[1] = fRec390[0];
			fRec389[1] = fRec389[0];
			fRec402[2] = fRec402[1];
			fRec402[1] = fRec402[0];
			fRec401[2] = fRec401[1];
			fRec401[1] = fRec401[0];
			fRec400[2] = fRec400[1];
			fRec400[1] = fRec400[0];
			fRec399[2] = fRec399[1];
			fRec399[1] = fRec399[0];
			fRec398[2] = fRec398[1];
			fRec398[1] = fRec398[0];
			fRec397[2] = fRec397[1];
			fRec397[1] = fRec397[0];
			fRec396[1] = fRec396[0];
			fRec409[2] = fRec409[1];
			fRec409[1] = fRec409[0];
			fRec408[2] = fRec408[1];
			fRec408[1] = fRec408[0];
			fRec407[2] = fRec407[1];
			fRec407[1] = fRec407[0];
			fRec406[2] = fRec406[1];
			fRec406[1] = fRec406[0];
			fRec405[2] = fRec405[1];
			fRec405[1] = fRec405[0];
			fRec404[2] = fRec404[1];
			fRec404[1] = fRec404[0];
			fRec403[1] = fRec403[0];
			fRec416[2] = fRec416[1];
			fRec416[1] = fRec416[0];
			fRec415[2] = fRec415[1];
			fRec415[1] = fRec415[0];
			fRec414[2] = fRec414[1];
			fRec414[1] = fRec414[0];
			fRec413[2] = fRec413[1];
			fRec413[1] = fRec413[0];
			fRec412[2] = fRec412[1];
			fRec412[1] = fRec412[0];
			fRec411[2] = fRec411[1];
			fRec411[1] = fRec411[0];
			fRec410[1] = fRec410[0];
			fRec423[2] = fRec423[1];
			fRec423[1] = fRec423[0];
			fRec422[2] = fRec422[1];
			fRec422[1] = fRec422[0];
			fRec421[2] = fRec421[1];
			fRec421[1] = fRec421[0];
			fRec420[2] = fRec420[1];
			fRec420[1] = fRec420[0];
			fRec419[2] = fRec419[1];
			fRec419[1] = fRec419[0];
			fRec418[2] = fRec418[1];
			fRec418[1] = fRec418[0];
			fRec417[1] = fRec417[0];
			fRec430[2] = fRec430[1];
			fRec430[1] = fRec430[0];
			fRec429[2] = fRec429[1];
			fRec429[1] = fRec429[0];
			fRec428[2] = fRec428[1];
			fRec428[1] = fRec428[0];
			fRec427[2] = fRec427[1];
			fRec427[1] = fRec427[0];
			fRec426[2] = fRec426[1];
			fRec426[1] = fRec426[0];
			fRec425[2] = fRec425[1];
			fRec425[1] = fRec425[0];
			fRec424[1] = fRec424[0];
			fRec437[2] = fRec437[1];
			fRec437[1] = fRec437[0];
			fRec436[2] = fRec436[1];
			fRec436[1] = fRec436[0];
			fRec435[2] = fRec435[1];
			fRec435[1] = fRec435[0];
			fRec434[2] = fRec434[1];
			fRec434[1] = fRec434[0];
			fRec433[2] = fRec433[1];
			fRec433[1] = fRec433[0];
			fRec432[2] = fRec432[1];
			fRec432[1] = fRec432[0];
			fRec431[1] = fRec431[0];
			fRec444[2] = fRec444[1];
			fRec444[1] = fRec444[0];
			fRec443[2] = fRec443[1];
			fRec443[1] = fRec443[0];
			fRec442[2] = fRec442[1];
			fRec442[1] = fRec442[0];
			fRec441[2] = fRec441[1];
			fRec441[1] = fRec441[0];
			fRec440[2] = fRec440[1];
			fRec440[1] = fRec440[0];
			fRec439[2] = fRec439[1];
			fRec439[1] = fRec439[0];
			fRec438[1] = fRec438[0];
			fRec451[2] = fRec451[1];
			fRec451[1] = fRec451[0];
			fRec450[2] = fRec450[1];
			fRec450[1] = fRec450[0];
			fRec449[2] = fRec449[1];
			fRec449[1] = fRec449[0];
			fRec448[2] = fRec448[1];
			fRec448[1] = fRec448[0];
			fRec447[2] = fRec447[1];
			fRec447[1] = fRec447[0];
			fRec446[2] = fRec446[1];
			fRec446[1] = fRec446[0];
			fRec445[1] = fRec445[0];
			fRec458[2] = fRec458[1];
			fRec458[1] = fRec458[0];
			fRec457[2] = fRec457[1];
			fRec457[1] = fRec457[0];
			fRec456[2] = fRec456[1];
			fRec456[1] = fRec456[0];
			fRec455[2] = fRec455[1];
			fRec455[1] = fRec455[0];
			fRec454[2] = fRec454[1];
			fRec454[1] = fRec454[0];
			fRec453[2] = fRec453[1];
			fRec453[1] = fRec453[0];
			fRec452[1] = fRec452[0];
			fRec465[2] = fRec465[1];
			fRec465[1] = fRec465[0];
			fRec464[2] = fRec464[1];
			fRec464[1] = fRec464[0];
			fRec463[2] = fRec463[1];
			fRec463[1] = fRec463[0];
			fRec462[2] = fRec462[1];
			fRec462[1] = fRec462[0];
			fRec461[2] = fRec461[1];
			fRec461[1] = fRec461[0];
			fRec460[2] = fRec460[1];
			fRec460[1] = fRec460[0];
			fRec459[1] = fRec459[0];
			fRec472[2] = fRec472[1];
			fRec472[1] = fRec472[0];
			fRec471[2] = fRec471[1];
			fRec471[1] = fRec471[0];
			fRec470[2] = fRec470[1];
			fRec470[1] = fRec470[0];
			fRec469[2] = fRec469[1];
			fRec469[1] = fRec469[0];
			fRec468[2] = fRec468[1];
			fRec468[1] = fRec468[0];
			fRec467[2] = fRec467[1];
			fRec467[1] = fRec467[0];
			fRec466[1] = fRec466[0];
			fRec479[2] = fRec479[1];
			fRec479[1] = fRec479[0];
			fRec478[2] = fRec478[1];
			fRec478[1] = fRec478[0];
			fRec477[2] = fRec477[1];
			fRec477[1] = fRec477[0];
			fRec476[2] = fRec476[1];
			fRec476[1] = fRec476[0];
			fRec475[2] = fRec475[1];
			fRec475[1] = fRec475[0];
			fRec474[2] = fRec474[1];
			fRec474[1] = fRec474[0];
			fRec473[1] = fRec473[0];
			fRec486[2] = fRec486[1];
			fRec486[1] = fRec486[0];
			fRec485[2] = fRec485[1];
			fRec485[1] = fRec485[0];
			fRec484[2] = fRec484[1];
			fRec484[1] = fRec484[0];
			fRec483[2] = fRec483[1];
			fRec483[1] = fRec483[0];
			fRec482[2] = fRec482[1];
			fRec482[1] = fRec482[0];
			fRec481[2] = fRec481[1];
			fRec481[1] = fRec481[0];
			fRec480[1] = fRec480[0];
			fRec493[2] = fRec493[1];
			fRec493[1] = fRec493[0];
			fRec492[2] = fRec492[1];
			fRec492[1] = fRec492[0];
			fRec491[2] = fRec491[1];
			fRec491[1] = fRec491[0];
			fRec490[2] = fRec490[1];
			fRec490[1] = fRec490[0];
			fRec489[2] = fRec489[1];
			fRec489[1] = fRec489[0];
			fRec488[2] = fRec488[1];
			fRec488[1] = fRec488[0];
			fRec487[1] = fRec487[0];
			fRec500[2] = fRec500[1];
			fRec500[1] = fRec500[0];
			fRec499[2] = fRec499[1];
			fRec499[1] = fRec499[0];
			fRec498[2] = fRec498[1];
			fRec498[1] = fRec498[0];
			fRec497[2] = fRec497[1];
			fRec497[1] = fRec497[0];
			fRec496[2] = fRec496[1];
			fRec496[1] = fRec496[0];
			fRec495[2] = fRec495[1];
			fRec495[1] = fRec495[0];
			fRec494[1] = fRec494[0];
			fRec507[2] = fRec507[1];
			fRec507[1] = fRec507[0];
			fRec506[2] = fRec506[1];
			fRec506[1] = fRec506[0];
			fRec505[2] = fRec505[1];
			fRec505[1] = fRec505[0];
			fRec504[2] = fRec504[1];
			fRec504[1] = fRec504[0];
			fRec503[2] = fRec503[1];
			fRec503[1] = fRec503[0];
			fRec502[2] = fRec502[1];
			fRec502[1] = fRec502[0];
			fRec501[1] = fRec501[0];
			fRec514[2] = fRec514[1];
			fRec514[1] = fRec514[0];
			fRec513[2] = fRec513[1];
			fRec513[1] = fRec513[0];
			fRec512[2] = fRec512[1];
			fRec512[1] = fRec512[0];
			fRec511[2] = fRec511[1];
			fRec511[1] = fRec511[0];
			fRec510[2] = fRec510[1];
			fRec510[1] = fRec510[0];
			fRec509[2] = fRec509[1];
			fRec509[1] = fRec509[0];
			fRec508[1] = fRec508[0];
			fRec521[2] = fRec521[1];
			fRec521[1] = fRec521[0];
			fRec520[2] = fRec520[1];
			fRec520[1] = fRec520[0];
			fRec519[2] = fRec519[1];
			fRec519[1] = fRec519[0];
			fRec518[2] = fRec518[1];
			fRec518[1] = fRec518[0];
			fRec517[2] = fRec517[1];
			fRec517[1] = fRec517[0];
			fRec516[2] = fRec516[1];
			fRec516[1] = fRec516[0];
			fRec515[1] = fRec515[0];
			fRec528[2] = fRec528[1];
			fRec528[1] = fRec528[0];
			fRec527[2] = fRec527[1];
			fRec527[1] = fRec527[0];
			fRec526[2] = fRec526[1];
			fRec526[1] = fRec526[0];
			fRec525[2] = fRec525[1];
			fRec525[1] = fRec525[0];
			fRec524[2] = fRec524[1];
			fRec524[1] = fRec524[0];
			fRec523[2] = fRec523[1];
			fRec523[1] = fRec523[0];
			fRec522[1] = fRec522[0];
			fRec535[2] = fRec535[1];
			fRec535[1] = fRec535[0];
			fRec534[2] = fRec534[1];
			fRec534[1] = fRec534[0];
			fRec533[2] = fRec533[1];
			fRec533[1] = fRec533[0];
			fRec532[2] = fRec532[1];
			fRec532[1] = fRec532[0];
			fRec531[2] = fRec531[1];
			fRec531[1] = fRec531[0];
			fRec530[2] = fRec530[1];
			fRec530[1] = fRec530[0];
			fRec529[1] = fRec529[0];
			fRec542[2] = fRec542[1];
			fRec542[1] = fRec542[0];
			fRec541[2] = fRec541[1];
			fRec541[1] = fRec541[0];
			fRec540[2] = fRec540[1];
			fRec540[1] = fRec540[0];
			fRec539[2] = fRec539[1];
			fRec539[1] = fRec539[0];
			fRec538[2] = fRec538[1];
			fRec538[1] = fRec538[0];
			fRec537[2] = fRec537[1];
			fRec537[1] = fRec537[0];
			fRec536[1] = fRec536[0];
			fRec549[2] = fRec549[1];
			fRec549[1] = fRec549[0];
			fRec548[2] = fRec548[1];
			fRec548[1] = fRec548[0];
			fRec547[2] = fRec547[1];
			fRec547[1] = fRec547[0];
			fRec546[2] = fRec546[1];
			fRec546[1] = fRec546[0];
			fRec545[2] = fRec545[1];
			fRec545[1] = fRec545[0];
			fRec544[2] = fRec544[1];
			fRec544[1] = fRec544[0];
			fRec543[1] = fRec543[0];
			fRec556[2] = fRec556[1];
			fRec556[1] = fRec556[0];
			fRec555[2] = fRec555[1];
			fRec555[1] = fRec555[0];
			fRec554[2] = fRec554[1];
			fRec554[1] = fRec554[0];
			fRec553[2] = fRec553[1];
			fRec553[1] = fRec553[0];
			fRec552[2] = fRec552[1];
			fRec552[1] = fRec552[0];
			fRec551[2] = fRec551[1];
			fRec551[1] = fRec551[0];
			fRec550[1] = fRec550[0];
			fRec563[2] = fRec563[1];
			fRec563[1] = fRec563[0];
			fRec562[2] = fRec562[1];
			fRec562[1] = fRec562[0];
			fRec561[2] = fRec561[1];
			fRec561[1] = fRec561[0];
			fRec560[2] = fRec560[1];
			fRec560[1] = fRec560[0];
			fRec559[2] = fRec559[1];
			fRec559[1] = fRec559[0];
			fRec558[2] = fRec558[1];
			fRec558[1] = fRec558[0];
			fRec557[1] = fRec557[0];
			fRec570[2] = fRec570[1];
			fRec570[1] = fRec570[0];
			fRec569[2] = fRec569[1];
			fRec569[1] = fRec569[0];
			fRec568[2] = fRec568[1];
			fRec568[1] = fRec568[0];
			fRec567[2] = fRec567[1];
			fRec567[1] = fRec567[0];
			fRec566[2] = fRec566[1];
			fRec566[1] = fRec566[0];
			fRec565[2] = fRec565[1];
			fRec565[1] = fRec565[0];
			fRec564[1] = fRec564[0];
			fRec577[2] = fRec577[1];
			fRec577[1] = fRec577[0];
			fRec576[2] = fRec576[1];
			fRec576[1] = fRec576[0];
			fRec575[2] = fRec575[1];
			fRec575[1] = fRec575[0];
			fRec574[2] = fRec574[1];
			fRec574[1] = fRec574[0];
			fRec573[2] = fRec573[1];
			fRec573[1] = fRec573[0];
			fRec572[2] = fRec572[1];
			fRec572[1] = fRec572[0];
			fRec571[1] = fRec571[0];
			fRec584[2] = fRec584[1];
			fRec584[1] = fRec584[0];
			fRec583[2] = fRec583[1];
			fRec583[1] = fRec583[0];
			fRec582[2] = fRec582[1];
			fRec582[1] = fRec582[0];
			fRec581[2] = fRec581[1];
			fRec581[1] = fRec581[0];
			fRec580[2] = fRec580[1];
			fRec580[1] = fRec580[0];
			fRec579[2] = fRec579[1];
			fRec579[1] = fRec579[0];
			fRec578[1] = fRec578[0];
			fRec591[2] = fRec591[1];
			fRec591[1] = fRec591[0];
			fRec590[2] = fRec590[1];
			fRec590[1] = fRec590[0];
			fRec589[2] = fRec589[1];
			fRec589[1] = fRec589[0];
			fRec588[2] = fRec588[1];
			fRec588[1] = fRec588[0];
			fRec587[2] = fRec587[1];
			fRec587[1] = fRec587[0];
			fRec586[2] = fRec586[1];
			fRec586[1] = fRec586[0];
			fRec585[1] = fRec585[0];
			fRec598[2] = fRec598[1];
			fRec598[1] = fRec598[0];
			fRec597[2] = fRec597[1];
			fRec597[1] = fRec597[0];
			fRec596[2] = fRec596[1];
			fRec596[1] = fRec596[0];
			fRec595[2] = fRec595[1];
			fRec595[1] = fRec595[0];
			fRec594[2] = fRec594[1];
			fRec594[1] = fRec594[0];
			fRec593[2] = fRec593[1];
			fRec593[1] = fRec593[0];
			fRec592[1] = fRec592[0];
			fRec605[2] = fRec605[1];
			fRec605[1] = fRec605[0];
			fRec604[2] = fRec604[1];
			fRec604[1] = fRec604[0];
			fRec603[2] = fRec603[1];
			fRec603[1] = fRec603[0];
			fRec602[2] = fRec602[1];
			fRec602[1] = fRec602[0];
			fRec601[2] = fRec601[1];
			fRec601[1] = fRec601[0];
			fRec600[2] = fRec600[1];
			fRec600[1] = fRec600[0];
			fRec599[1] = fRec599[0];
			fRec612[2] = fRec612[1];
			fRec612[1] = fRec612[0];
			fRec611[2] = fRec611[1];
			fRec611[1] = fRec611[0];
			fRec610[2] = fRec610[1];
			fRec610[1] = fRec610[0];
			fRec609[2] = fRec609[1];
			fRec609[1] = fRec609[0];
			fRec608[2] = fRec608[1];
			fRec608[1] = fRec608[0];
			fRec607[2] = fRec607[1];
			fRec607[1] = fRec607[0];
			fRec606[1] = fRec606[0];
			fRec619[2] = fRec619[1];
			fRec619[1] = fRec619[0];
			fRec618[2] = fRec618[1];
			fRec618[1] = fRec618[0];
			fRec617[2] = fRec617[1];
			fRec617[1] = fRec617[0];
			fRec616[2] = fRec616[1];
			fRec616[1] = fRec616[0];
			fRec615[2] = fRec615[1];
			fRec615[1] = fRec615[0];
			fRec614[2] = fRec614[1];
			fRec614[1] = fRec614[0];
			fRec613[1] = fRec613[0];
			fRec626[2] = fRec626[1];
			fRec626[1] = fRec626[0];
			fRec625[2] = fRec625[1];
			fRec625[1] = fRec625[0];
			fRec624[2] = fRec624[1];
			fRec624[1] = fRec624[0];
			fRec623[2] = fRec623[1];
			fRec623[1] = fRec623[0];
			fRec622[2] = fRec622[1];
			fRec622[1] = fRec622[0];
			fRec621[2] = fRec621[1];
			fRec621[1] = fRec621[0];
			fRec620[1] = fRec620[0];
			fRec633[2] = fRec633[1];
			fRec633[1] = fRec633[0];
			fRec632[2] = fRec632[1];
			fRec632[1] = fRec632[0];
			fRec631[2] = fRec631[1];
			fRec631[1] = fRec631[0];
			fRec630[2] = fRec630[1];
			fRec630[1] = fRec630[0];
			fRec629[2] = fRec629[1];
			fRec629[1] = fRec629[0];
			fRec628[2] = fRec628[1];
			fRec628[1] = fRec628[0];
			fRec627[1] = fRec627[0];
			fRec640[2] = fRec640[1];
			fRec640[1] = fRec640[0];
			fRec639[2] = fRec639[1];
			fRec639[1] = fRec639[0];
			fRec638[2] = fRec638[1];
			fRec638[1] = fRec638[0];
			fRec637[2] = fRec637[1];
			fRec637[1] = fRec637[0];
			fRec636[2] = fRec636[1];
			fRec636[1] = fRec636[0];
			fRec635[2] = fRec635[1];
			fRec635[1] = fRec635[0];
			fRec634[1] = fRec634[0];
			fRec647[2] = fRec647[1];
			fRec647[1] = fRec647[0];
			fRec646[2] = fRec646[1];
			fRec646[1] = fRec646[0];
			fRec645[2] = fRec645[1];
			fRec645[1] = fRec645[0];
			fRec644[2] = fRec644[1];
			fRec644[1] = fRec644[0];
			fRec643[2] = fRec643[1];
			fRec643[1] = fRec643[0];
			fRec642[2] = fRec642[1];
			fRec642[1] = fRec642[0];
			fRec641[1] = fRec641[0];
			fRec654[2] = fRec654[1];
			fRec654[1] = fRec654[0];
			fRec653[2] = fRec653[1];
			fRec653[1] = fRec653[0];
			fRec652[2] = fRec652[1];
			fRec652[1] = fRec652[0];
			fRec651[2] = fRec651[1];
			fRec651[1] = fRec651[0];
			fRec650[2] = fRec650[1];
			fRec650[1] = fRec650[0];
			fRec649[2] = fRec649[1];
			fRec649[1] = fRec649[0];
			fRec648[1] = fRec648[0];
			fRec661[2] = fRec661[1];
			fRec661[1] = fRec661[0];
			fRec660[2] = fRec660[1];
			fRec660[1] = fRec660[0];
			fRec659[2] = fRec659[1];
			fRec659[1] = fRec659[0];
			fRec658[2] = fRec658[1];
			fRec658[1] = fRec658[0];
			fRec657[2] = fRec657[1];
			fRec657[1] = fRec657[0];
			fRec656[2] = fRec656[1];
			fRec656[1] = fRec656[0];
			fRec655[1] = fRec655[0];
			fRec668[2] = fRec668[1];
			fRec668[1] = fRec668[0];
			fRec667[2] = fRec667[1];
			fRec667[1] = fRec667[0];
			fRec666[2] = fRec666[1];
			fRec666[1] = fRec666[0];
			fRec665[2] = fRec665[1];
			fRec665[1] = fRec665[0];
			fRec664[2] = fRec664[1];
			fRec664[1] = fRec664[0];
			fRec663[2] = fRec663[1];
			fRec663[1] = fRec663[0];
			fRec662[1] = fRec662[0];
			fRec675[2] = fRec675[1];
			fRec675[1] = fRec675[0];
			fRec674[2] = fRec674[1];
			fRec674[1] = fRec674[0];
			fRec673[2] = fRec673[1];
			fRec673[1] = fRec673[0];
			fRec672[2] = fRec672[1];
			fRec672[1] = fRec672[0];
			fRec671[2] = fRec671[1];
			fRec671[1] = fRec671[0];
			fRec670[2] = fRec670[1];
			fRec670[1] = fRec670[0];
			fRec669[1] = fRec669[0];
			fRec682[2] = fRec682[1];
			fRec682[1] = fRec682[0];
			fRec681[2] = fRec681[1];
			fRec681[1] = fRec681[0];
			fRec680[2] = fRec680[1];
			fRec680[1] = fRec680[0];
			fRec679[2] = fRec679[1];
			fRec679[1] = fRec679[0];
			fRec678[2] = fRec678[1];
			fRec678[1] = fRec678[0];
			fRec677[2] = fRec677[1];
			fRec677[1] = fRec677[0];
			fRec676[1] = fRec676[0];
			fRec689[2] = fRec689[1];
			fRec689[1] = fRec689[0];
			fRec688[2] = fRec688[1];
			fRec688[1] = fRec688[0];
			fRec687[2] = fRec687[1];
			fRec687[1] = fRec687[0];
			fRec686[2] = fRec686[1];
			fRec686[1] = fRec686[0];
			fRec685[2] = fRec685[1];
			fRec685[1] = fRec685[0];
			fRec684[2] = fRec684[1];
			fRec684[1] = fRec684[0];
			fRec683[1] = fRec683[0];
			fRec696[2] = fRec696[1];
			fRec696[1] = fRec696[0];
			fRec695[2] = fRec695[1];
			fRec695[1] = fRec695[0];
			fRec694[2] = fRec694[1];
			fRec694[1] = fRec694[0];
			fRec693[2] = fRec693[1];
			fRec693[1] = fRec693[0];
			fRec692[2] = fRec692[1];
			fRec692[1] = fRec692[0];
			fRec691[2] = fRec691[1];
			fRec691[1] = fRec691[0];
			fRec690[1] = fRec690[0];
			fRec703[2] = fRec703[1];
			fRec703[1] = fRec703[0];
			fRec702[2] = fRec702[1];
			fRec702[1] = fRec702[0];
			fRec701[2] = fRec701[1];
			fRec701[1] = fRec701[0];
			fRec700[2] = fRec700[1];
			fRec700[1] = fRec700[0];
			fRec699[2] = fRec699[1];
			fRec699[1] = fRec699[0];
			fRec698[2] = fRec698[1];
			fRec698[1] = fRec698[0];
			fRec697[1] = fRec697[0];
			fRec710[2] = fRec710[1];
			fRec710[1] = fRec710[0];
			fRec709[2] = fRec709[1];
			fRec709[1] = fRec709[0];
			fRec708[2] = fRec708[1];
			fRec708[1] = fRec708[0];
			fRec707[2] = fRec707[1];
			fRec707[1] = fRec707[0];
			fRec706[2] = fRec706[1];
			fRec706[1] = fRec706[0];
			fRec705[2] = fRec705[1];
			fRec705[1] = fRec705[0];
			fRec704[1] = fRec704[0];
			fRec717[2] = fRec717[1];
			fRec717[1] = fRec717[0];
			fRec716[2] = fRec716[1];
			fRec716[1] = fRec716[0];
			fRec715[2] = fRec715[1];
			fRec715[1] = fRec715[0];
			fRec714[2] = fRec714[1];
			fRec714[1] = fRec714[0];
			fRec713[2] = fRec713[1];
			fRec713[1] = fRec713[0];
			fRec712[2] = fRec712[1];
			fRec712[1] = fRec712[0];
			fRec711[1] = fRec711[0];
			fRec724[2] = fRec724[1];
			fRec724[1] = fRec724[0];
			fRec723[2] = fRec723[1];
			fRec723[1] = fRec723[0];
			fRec722[2] = fRec722[1];
			fRec722[1] = fRec722[0];
			fRec721[2] = fRec721[1];
			fRec721[1] = fRec721[0];
			fRec720[2] = fRec720[1];
			fRec720[1] = fRec720[0];
			fRec719[2] = fRec719[1];
			fRec719[1] = fRec719[0];
			fRec718[1] = fRec718[0];
			fRec731[2] = fRec731[1];
			fRec731[1] = fRec731[0];
			fRec730[2] = fRec730[1];
			fRec730[1] = fRec730[0];
			fRec729[2] = fRec729[1];
			fRec729[1] = fRec729[0];
			fRec728[2] = fRec728[1];
			fRec728[1] = fRec728[0];
			fRec727[2] = fRec727[1];
			fRec727[1] = fRec727[0];
			fRec726[2] = fRec726[1];
			fRec726[1] = fRec726[0];
			fRec725[1] = fRec725[0];
			fRec738[2] = fRec738[1];
			fRec738[1] = fRec738[0];
			fRec737[2] = fRec737[1];
			fRec737[1] = fRec737[0];
			fRec736[2] = fRec736[1];
			fRec736[1] = fRec736[0];
			fRec735[2] = fRec735[1];
			fRec735[1] = fRec735[0];
			fRec734[2] = fRec734[1];
			fRec734[1] = fRec734[0];
			fRec733[2] = fRec733[1];
			fRec733[1] = fRec733[0];
			fRec732[1] = fRec732[0];
			fRec745[2] = fRec745[1];
			fRec745[1] = fRec745[0];
			fRec744[2] = fRec744[1];
			fRec744[1] = fRec744[0];
			fRec743[2] = fRec743[1];
			fRec743[1] = fRec743[0];
			fRec742[2] = fRec742[1];
			fRec742[1] = fRec742[0];
			fRec741[2] = fRec741[1];
			fRec741[1] = fRec741[0];
			fRec740[2] = fRec740[1];
			fRec740[1] = fRec740[0];
			fRec739[1] = fRec739[0];
			fRec752[2] = fRec752[1];
			fRec752[1] = fRec752[0];
			fRec751[2] = fRec751[1];
			fRec751[1] = fRec751[0];
			fRec750[2] = fRec750[1];
			fRec750[1] = fRec750[0];
			fRec749[2] = fRec749[1];
			fRec749[1] = fRec749[0];
			fRec748[2] = fRec748[1];
			fRec748[1] = fRec748[0];
			fRec747[2] = fRec747[1];
			fRec747[1] = fRec747[0];
			fRec746[1] = fRec746[0];
			fRec759[2] = fRec759[1];
			fRec759[1] = fRec759[0];
			fRec758[2] = fRec758[1];
			fRec758[1] = fRec758[0];
			fRec757[2] = fRec757[1];
			fRec757[1] = fRec757[0];
			fRec756[2] = fRec756[1];
			fRec756[1] = fRec756[0];
			fRec755[2] = fRec755[1];
			fRec755[1] = fRec755[0];
			fRec754[2] = fRec754[1];
			fRec754[1] = fRec754[0];
			fRec753[1] = fRec753[0];
			fRec766[2] = fRec766[1];
			fRec766[1] = fRec766[0];
			fRec765[2] = fRec765[1];
			fRec765[1] = fRec765[0];
			fRec764[2] = fRec764[1];
			fRec764[1] = fRec764[0];
			fRec763[2] = fRec763[1];
			fRec763[1] = fRec763[0];
			fRec762[2] = fRec762[1];
			fRec762[1] = fRec762[0];
			fRec761[2] = fRec761[1];
			fRec761[1] = fRec761[0];
			fRec760[1] = fRec760[0];
			fRec773[2] = fRec773[1];
			fRec773[1] = fRec773[0];
			fRec772[2] = fRec772[1];
			fRec772[1] = fRec772[0];
			fRec771[2] = fRec771[1];
			fRec771[1] = fRec771[0];
			fRec770[2] = fRec770[1];
			fRec770[1] = fRec770[0];
			fRec769[2] = fRec769[1];
			fRec769[1] = fRec769[0];
			fRec768[2] = fRec768[1];
			fRec768[1] = fRec768[0];
			fRec767[1] = fRec767[0];
			fRec780[2] = fRec780[1];
			fRec780[1] = fRec780[0];
			fRec779[2] = fRec779[1];
			fRec779[1] = fRec779[0];
			fRec778[2] = fRec778[1];
			fRec778[1] = fRec778[0];
			fRec777[2] = fRec777[1];
			fRec777[1] = fRec777[0];
			fRec776[2] = fRec776[1];
			fRec776[1] = fRec776[0];
			fRec775[2] = fRec775[1];
			fRec775[1] = fRec775[0];
			fRec774[1] = fRec774[0];
			fRec787[2] = fRec787[1];
			fRec787[1] = fRec787[0];
			fRec786[2] = fRec786[1];
			fRec786[1] = fRec786[0];
			fRec785[2] = fRec785[1];
			fRec785[1] = fRec785[0];
			fRec784[2] = fRec784[1];
			fRec784[1] = fRec784[0];
			fRec783[2] = fRec783[1];
			fRec783[1] = fRec783[0];
			fRec782[2] = fRec782[1];
			fRec782[1] = fRec782[0];
			fRec781[1] = fRec781[0];
			fRec794[2] = fRec794[1];
			fRec794[1] = fRec794[0];
			fRec793[2] = fRec793[1];
			fRec793[1] = fRec793[0];
			fRec792[2] = fRec792[1];
			fRec792[1] = fRec792[0];
			fRec791[2] = fRec791[1];
			fRec791[1] = fRec791[0];
			fRec790[2] = fRec790[1];
			fRec790[1] = fRec790[0];
			fRec789[2] = fRec789[1];
			fRec789[1] = fRec789[0];
			fRec788[1] = fRec788[0];
			fRec801[2] = fRec801[1];
			fRec801[1] = fRec801[0];
			fRec800[2] = fRec800[1];
			fRec800[1] = fRec800[0];
			fRec799[2] = fRec799[1];
			fRec799[1] = fRec799[0];
			fRec798[2] = fRec798[1];
			fRec798[1] = fRec798[0];
			fRec797[2] = fRec797[1];
			fRec797[1] = fRec797[0];
			fRec796[2] = fRec796[1];
			fRec796[1] = fRec796[0];
			fRec795[1] = fRec795[0];
			fRec808[2] = fRec808[1];
			fRec808[1] = fRec808[0];
			fRec807[2] = fRec807[1];
			fRec807[1] = fRec807[0];
			fRec806[2] = fRec806[1];
			fRec806[1] = fRec806[0];
			fRec805[2] = fRec805[1];
			fRec805[1] = fRec805[0];
			fRec804[2] = fRec804[1];
			fRec804[1] = fRec804[0];
			fRec803[2] = fRec803[1];
			fRec803[1] = fRec803[0];
			fRec802[1] = fRec802[0];
			fRec815[2] = fRec815[1];
			fRec815[1] = fRec815[0];
			fRec814[2] = fRec814[1];
			fRec814[1] = fRec814[0];
			fRec813[2] = fRec813[1];
			fRec813[1] = fRec813[0];
			fRec812[2] = fRec812[1];
			fRec812[1] = fRec812[0];
			fRec811[2] = fRec811[1];
			fRec811[1] = fRec811[0];
			fRec810[2] = fRec810[1];
			fRec810[1] = fRec810[0];
			fRec809[1] = fRec809[0];
			fRec822[2] = fRec822[1];
			fRec822[1] = fRec822[0];
			fRec821[2] = fRec821[1];
			fRec821[1] = fRec821[0];
			fRec820[2] = fRec820[1];
			fRec820[1] = fRec820[0];
			fRec819[2] = fRec819[1];
			fRec819[1] = fRec819[0];
			fRec818[2] = fRec818[1];
			fRec818[1] = fRec818[0];
			fRec817[2] = fRec817[1];
			fRec817[1] = fRec817[0];
			fRec816[1] = fRec816[0];
			fRec829[2] = fRec829[1];
			fRec829[1] = fRec829[0];
			fRec828[2] = fRec828[1];
			fRec828[1] = fRec828[0];
			fRec827[2] = fRec827[1];
			fRec827[1] = fRec827[0];
			fRec826[2] = fRec826[1];
			fRec826[1] = fRec826[0];
			fRec825[2] = fRec825[1];
			fRec825[1] = fRec825[0];
			fRec824[2] = fRec824[1];
			fRec824[1] = fRec824[0];
			fRec823[1] = fRec823[0];
			fRec833[2] = fRec833[1];
			fRec833[1] = fRec833[0];
			fRec832[2] = fRec832[1];
			fRec832[1] = fRec832[0];
			fRec831[2] = fRec831[1];
			fRec831[1] = fRec831[0];
			fRec830[1] = fRec830[0];
			
		}
		
	}

};

#if defined(JUCE_POLY)

struct FaustSound : public SynthesiserSound {
    
    bool appliesToNote (int /*midiNoteNumber*/) override        { return true; }
    bool appliesToChannel (int /*midiChannel*/) override        { return true; }
};

// An hybrid JUCE and Faust voice

class FaustVoice : public SynthesiserVoice, public dsp_voice {
    
    private:
        
        ScopedPointer<AudioBuffer<FAUSTFLOAT>> fBuffer;
        
    public:
        
        FaustVoice(dsp* dsp):dsp_voice(dsp)
        {
            // Allocate buffer for mixing
            fBuffer = new AudioBuffer<FAUSTFLOAT>(dsp->getNumOutputs(), 8192);
            fDSP->init(SynthesiserVoice::getSampleRate());
        }
        
        bool canPlaySound (SynthesiserSound* sound) override
        {
            return dynamic_cast<FaustSound*> (sound) != nullptr;
        }
        
        void startNote (int midiNoteNumber,
                        float velocity,
                        SynthesiserSound* s,
                        int currentPitchWheelPosition) override
        {
            // Note is triggered
            keyOn(midiNoteNumber, velocity, true);
        }
        
        void stopNote (float velocity, bool allowTailOff) override
        {
            keyOff(!allowTailOff);
        }
        
        void pitchWheelMoved (int newPitchWheelValue) override
        {
            // not implemented for now
        }
        
        void controllerMoved (int controllerNumber, int newControllerValue) override
        {
            // not implemented for now
        }
        
        void renderNextBlock (AudioBuffer<FAUSTFLOAT>& outputBuffer,
                              int startSample,
                              int numSamples) override
        {
            // Only plays when the voice is active
            if (isVoiceActive()) {
                
                // Play the voice
                compute(numSamples, nullptr, (FAUSTFLOAT**)fBuffer->getArrayOfWritePointers());
                
                // Mix it in outputs
                for (int i = 0; i < fDSP->getNumOutputs(); i++) {
                    outputBuffer.addFrom(i, startSample, *fBuffer, i, 0, numSamples);
                }
            }
        }
    
};

// Decorates the JUCE Synthesiser and adds Faust polyphonic code for GUI handling

class FaustSynthesiser : public Synthesiser, public dsp_voice_group {
    
    private:
        
        Synthesiser fSynth;
    
        static void panic(float val, void* arg)
        {
            static_cast<FaustSynthesiser*>(arg)->allNotesOff(0, false); // 0 stops all voices
        }
  
    public:
        
        FaustSynthesiser():dsp_voice_group(panic, this, true, true)
        {
            setNoteStealingEnabled(true);
        }
        
        virtual ~FaustSynthesiser()
        {
            // Voices will be deallocated by fSynth
            dsp_voice_group::clearVoices();
        }
        
        void addVoice(FaustVoice* voice)
        {
            fSynth.addVoice(voice);
            dsp_voice_group::addVoice(voice);
        }
        
        void addSound(SynthesiserSound* sound)
        {
            fSynth.addSound(sound);
        }
        
        void allNotesOff(int midiChannel, bool allowTailOff)
        {
            fSynth.allNotesOff(midiChannel, allowTailOff);
        }
        
        void setCurrentPlaybackSampleRate (double newRate)
        {
            fSynth.setCurrentPlaybackSampleRate(newRate);
        }
        
        void renderNextBlock (AudioBuffer<float>& outputAudio,
                              const MidiBuffer& inputMidi,
                              int startSample,
                              int numSamples)
        {
            fSynth.renderNextBlock(outputAudio, inputMidi, startSample, numSamples);
        }
        
        void renderNextBlock (AudioBuffer<double>& outputAudio,
                              const MidiBuffer& inputMidi,
                              int startSample,
                              int numSamples)
        {
            fSynth.renderNextBlock(outputAudio, inputMidi, startSample, numSamples);
        }
    
};

#endif

class FaustPlugInAudioProcessor : public AudioProcessor, private Timer
{

    public:
        
        FaustPlugInAudioProcessor();
        virtual ~FaustPlugInAudioProcessor();
        
        void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    
        bool isBusesLayoutSupported (const BusesLayout& layouts) const override;
        
        void processBlock (AudioBuffer<float>& buffer, MidiBuffer& midiMessages) override
        {
            jassert (! isUsingDoublePrecision());
            process (buffer, midiMessages);
        }
        
        void processBlock (AudioBuffer<double>& buffer, MidiBuffer& midiMessages) override
        {
            jassert (isUsingDoublePrecision());
            process (buffer, midiMessages);
        }

    
        AudioProcessorEditor* createEditor() override;
        bool hasEditor() const override;
        
        const String getName() const override;
        
        bool acceptsMidi() const override;
        bool producesMidi() const override;
        double getTailLengthSeconds() const override;
        
        int getNumPrograms() override;
        int getCurrentProgram() override;
        void setCurrentProgram (int index) override;
        const String getProgramName (int index) override;
        void changeProgramName (int index, const String& newName) override;
        
        void getStateInformation (MemoryBlock& destData) override;
        void setStateInformation (const void* data, int sizeInBytes) override;
    
        void releaseResources() override
        {}
        
        void timerCallback() override;
    
        AudioProcessor::BusesProperties getBusesProperties();
        bool supportsDoublePrecisionProcessing() const override;
    
    #ifdef JUCE_POLY
        ScopedPointer<FaustSynthesiser> fSynth;
    #else
    #if defined(MIDICTRL)
        ScopedPointer<juce_midi_handler> fMIDIHandler;
        ScopedPointer<MidiUI> fMIDIUI;
    #endif
        ScopedPointer<dsp> fDSP;
    #endif
        
    #if defined(OSCCTRL)
        ScopedPointer<JuceOSCUI> fOSCUI;
    #endif
    
    #if defined(SOUNDFILE)
        ScopedPointer<SoundUI> fSoundUI;
    #endif
    
        JuceStateUI fStateUI;
        JuceParameterUI fParameterUI;
        
    private:

        template <typename FloatType>
        void process (AudioBuffer<FloatType>& buffer, MidiBuffer& midiMessages);
    
        JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FaustPlugInAudioProcessor)
    
};

class FaustPlugInAudioProcessorEditor : public AudioProcessorEditor, public Timer, public Slider::Listener
//class FaustPlugInAudioProcessorEditor : public AudioProcessorEditor
{
    
    public:
        
        FaustPlugInAudioProcessorEditor (FaustPlugInAudioProcessor&);
        virtual ~FaustPlugInAudioProcessorEditor();
        
        void paint (Graphics&) override;
        void resized() override;
		void timerCallback();
		void sliderValueChanged(Slider* slider) override;


    private:
        
        // This reference is provided as a quick way for your editor to
        // access the processor object that created it.
        FaustPlugInAudioProcessor& processor;
        
        JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FaustPlugInAudioProcessorEditor)
        
        JuceGUI fJuceGUI;
		Ball Note;
		Slider timeslider;
		Slider velslider;
		
		
};

static mydsp gDSP;

FaustPlugInAudioProcessor::FaustPlugInAudioProcessor()
: AudioProcessor (getBusesProperties()), fParameterUI(this)
{
	bool midi_sync = false;
    int nvoices = 0;
    
    mydsp* tmp_dsp = new mydsp();
    MidiMeta::analyse(tmp_dsp, midi_sync, nvoices);
    delete tmp_dsp;
    
#ifdef JUCE_POLY
    assert(nvoices > 0);
    fSynth = new FaustSynthesiser();
    for (int i = 0; i < nvoices; i++) {
        fSynth->addVoice(new FaustVoice(new mydsp()));
    }
    fSynth->init();
    fSynth->addSound(new FaustSound());
#else
    
    bool group = true;
    mydsp_poly* dsp_poly = nullptr;
    
#ifdef POLY2
    assert(nvoices > 0);
    std::cout << "Started with " << nvoices << " voices\n";
    dsp_poly = new mydsp_poly(new mydsp(), nvoices, true, group);
    
#if MIDICTRL
    if (midi_sync) {
        fDSP = new timed_dsp(new dsp_sequencer(dsp_poly, new effect()));
    } else {
        fDSP = new dsp_sequencer(dsp_poly, new effect());
    }
#else
    fDSP = new dsp_sequencer(dsp_poly, new effects());
#endif
    
#else
    if (nvoices > 0) {
        std::cout << "Started with " << nvoices << " voices\n";
        dsp_poly = new mydsp_poly(new mydsp(), nvoices, true, group);
        
#if MIDICTRL
        if (midi_sync) {
            fDSP = new timed_dsp(dsp_poly);
        } else {
            fDSP = dsp_poly;
        }
#else
        fDSP = dsp_poly;
#endif
    } else {
#if MIDICTRL
        if (midi_sync) {
            fDSP = new timed_dsp(new mydsp());
        } else {
            fDSP = new mydsp();
        }
#else
        fDSP = new mydsp();
#endif
    }
    
#endif
    
#if defined(MIDICTRL)
    fMIDIHandler = new juce_midi_handler();
    fMIDIHandler->addMidiIn(dsp_poly);
    fMIDIUI = new MidiUI(fMIDIHandler);
    fDSP->buildUserInterface(fMIDIUI);
    if (!fMIDIUI->run()) {
        std::cerr << "JUCE MIDI handler cannot be started..." << std::endl;
    }
#endif
    
#endif
    
#if defined(OSCCTRL)
    fOSCUI = new JuceOSCUI("127.0.0.1", 5510, 5511);
#ifdef JUCE_POLY
    fSynth->buildUserInterface(fOSCUI);
#else
    fDSP->buildUserInterface(fOSCUI);
#endif
    if (!fOSCUI->run()) {
        std::cerr << "JUCE OSC handler cannot be started..." << std::endl;
    }
#endif
    
#if defined(SOUNDFILE)
    // Use bundle path
    auto file = File::getSpecialLocation(File::currentExecutableFile)
        .getParentDirectory().getParentDirectory().getChildFile("Resources");
    fSoundUI = new SoundUI(file.getFullPathName().toStdString());
    // SoundUI has to be dispatched on all internal voices
    if (dsp_poly) dsp_poly->setGroup(false);
    fDSP->buildUserInterface(fSoundUI);
    if (dsp_poly) dsp_poly->setGroup(group);
#endif
    
#ifdef JUCE_POLY
    fSynth->buildUserInterface(&fStateUI);
    fSynth->buildUserInterface(&fParameterUI);
#else
    fDSP->buildUserInterface(&fStateUI);
    fDSP->buildUserInterface(&fParameterUI);
#endif
    
    startTimerHz(25);
}

FaustPlugInAudioProcessor::~FaustPlugInAudioProcessor()
{
	//Timer::stopTimer();
}

AudioProcessor::BusesProperties FaustPlugInAudioProcessor::getBusesProperties()
{
    if (PluginHostType::getPluginLoadedAs() == wrapperType_Standalone) {
        if (gDSP.getNumInputs() == 0) {
            return BusesProperties().withOutput("Output", AudioChannelSet::discreteChannels(std::min<int>(2, gDSP.getNumOutputs())), true);
        } else {
            return BusesProperties()
            .withInput("Input", AudioChannelSet::discreteChannels(std::min<int>(2, gDSP.getNumInputs())), true)
            .withOutput("Output", AudioChannelSet::discreteChannels(std::min<int>(2, gDSP.getNumOutputs())), true);
        }
    } else {
        if (gDSP.getNumInputs() == 0) {
            return BusesProperties().withOutput("Output", AudioChannelSet::discreteChannels(gDSP.getNumOutputs()), true);
        } else {
            return BusesProperties()
            .withInput("Input", AudioChannelSet::discreteChannels(gDSP.getNumInputs()), true)
            .withOutput("Output", AudioChannelSet::discreteChannels(gDSP.getNumOutputs()), true);
        }
    }
}

void FaustPlugInAudioProcessor::timerCallback()
{
    GUI::updateAllGuis();
}

//==============================================================================
const String FaustPlugInAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

bool FaustPlugInAudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
    return true;
#else
    return false;
#endif
}

bool FaustPlugInAudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
    return true;
#else
    return false;
#endif
}

double FaustPlugInAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int FaustPlugInAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
    // so this should be at least 1, even if you're not really implementing programs.
}

int FaustPlugInAudioProcessor::getCurrentProgram()
{
    return 0;
}

void FaustPlugInAudioProcessor::setCurrentProgram (int index)
{}

const String FaustPlugInAudioProcessor::getProgramName (int index)
{
    return String();
}

void FaustPlugInAudioProcessor::changeProgramName (int index, const String& newName)
{}

bool FaustPlugInAudioProcessor::supportsDoublePrecisionProcessing() const
{
    return sizeof(FAUSTFLOAT) == 8;
}

//==============================================================================
void FaustPlugInAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need...
    
#ifdef JUCE_POLY
    fSynth->setCurrentPlaybackSampleRate (sampleRate);
#else
    
    // Possibly adapt DSP
    if (fDSP->getNumInputs() > getTotalNumInputChannels() || fDSP->getNumOutputs() > getTotalNumOutputChannels()) {
        fDSP = new dsp_adapter(fDSP.release(), getTotalNumInputChannels(), getTotalNumOutputChannels(), 4096);
    }
   
    // Setting the DSP control values has already been done by 'buildUserInterface(&fStateUI)', using the saved values.
    // What has to be done to finish the DSP initialization is done now.
    mydsp::classInit(int(sampleRate));
    fDSP->instanceConstants(int(sampleRate));
    fDSP->instanceClear();
    
#endif
}

bool FaustPlugInAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const
{
#ifdef JUCE_POLY
    return true;
#else
    
#if JucePlugin_IsSynth
    // Stereo is supported
    return (layouts.getMainOutputChannelSet().size() == 2) || (layouts.getMainOutputChannelSet().size() == fDSP->getNumOutputs());
#else
    // Stereo is supported
    return
    ((layouts.getMainInputChannelSet().size() == 2) && (layouts.getMainOutputChannelSet().size() == 2))
    ||
    ((layouts.getMainInputChannelSet().size() == fDSP->getNumInputs()) && (layouts.getMainOutputChannelSet().size() == fDSP->getNumOutputs()));
#endif
    
#endif
}

template <typename FloatType>
void FaustPlugInAudioProcessor::process (AudioBuffer<FloatType>& buffer, MidiBuffer& midiMessages)
{
    AVOIDDENORMALS;
    
#ifdef JUCE_POLY
    fSynth->renderNextBlock(buffer, midiMessages, 0, buffer.getNumSamples());
#else
#if defined(MIDICTRL)
    // Read MIDI input events from midiMessages
    fMIDIHandler->decodeBuffer(midiMessages);
    // Then write MIDI output events to midiMessages
    fMIDIHandler->encodeBuffer(midiMessages);
#endif
    // MIDI timestamp is expressed in frames
    fDSP->compute(-1, buffer.getNumSamples(),
                  (FAUSTFLOAT**)buffer.getArrayOfReadPointers(),
                  (FAUSTFLOAT**)buffer.getArrayOfWritePointers());
#endif
}

//==============================================================================
bool FaustPlugInAudioProcessor::hasEditor() const
{
    return true;
}

AudioProcessorEditor* FaustPlugInAudioProcessor::createEditor()
{
    return new FaustPlugInAudioProcessorEditor (*this);
}

//==============================================================================
void FaustPlugInAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
    
    fStateUI.getStateInformation(destData);
}

void FaustPlugInAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
    
    fStateUI.setStateInformation(data, sizeInBytes);
 }

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new FaustPlugInAudioProcessor();
}

//==============================================================================
FaustPlugInAudioProcessorEditor::FaustPlugInAudioProcessorEditor (FaustPlugInAudioProcessor& p)
: AudioProcessorEditor (&p), processor (p), fJuceGUI(false)
{
    addAndMakeVisible(fJuceGUI);
    
#ifdef JUCE_POLY
    p.fSynth->buildUserInterface(&fJuceGUI);
#else
    p.fDSP->buildUserInterface(&fJuceGUI);
#endif
    
    juce::Rectangle<int> recommendedSize = fJuceGUI.getSize();
	
	setSize(800, 400);
	addAndMakeVisible(Note);

	timeslider.setSliderStyle(Slider::SliderStyle::LinearHorizontal);
	timeslider.setRange(1.0, 10000.0,1);
	timeslider.setValue(1000);
	addAndMakeVisible(timeslider);
	timeslider.addListener(this);
	timeslider.setSkewFactorFromMidPoint(100);
	timeslider.setColour(Slider::textBoxTextColourId, Colours::black);
	timeslider.setColour(Slider::textBoxOutlineColourId, Colours::transparentWhite);
	timeslider.setTextValueSuffix(" ms");
	timeslider.setNumDecimalPlacesToDisplay(0);


	velslider.setSliderStyle(Slider::SliderStyle::LinearHorizontal);
	velslider.setRange(-50.0, 100.0,1);
	velslider.setValue(0);
	velslider.addListener(this);
	velslider.setColour(Slider::textBoxTextColourId, Colours::black);
	velslider.setColour(Slider::textBoxOutlineColourId, Colours::transparentWhite);
	velslider.setTextValueSuffix(" dB");
	velslider.setNumDecimalPlacesToDisplay(0);


	addAndMakeVisible(velslider);
	velslider.setSkewFactorFromMidPoint(0);


	//Note.showa.attachToComponent(&timeslider, true);
	//Note.showb.attachToComponent(&velslider, true);

	startTimerHz(25);
}
void FaustPlugInAudioProcessorEditor::sliderValueChanged(Slider* slider)
{
	if (slider == &timeslider)
	{
		a = timeslider.getValue();
	} 
	else if (slider == &velslider)
	{
		b = velslider.getValue();
	}
}


FaustPlugInAudioProcessorEditor::~FaustPlugInAudioProcessorEditor()
{
	
}

//==============================================================================
void FaustPlugInAudioProcessorEditor::paint (Graphics& g)
{
    g.fillAll (Colours::white);
}



void FaustPlugInAudioProcessorEditor::resized()
{
    fJuceGUI.setBounds(getLocalBounds());
	Note.setBounds(getLocalBounds());
	timeslider.setBounds(10,110,300,20);
	velslider.setBounds(10,210, 300, 20);
}

void FaustPlugInAudioProcessorEditor::timerCallback()
{


	switch ((int)maxnum)
	{
	case 1: Note.uppercaseText.setText("F0", dontSendNotification);
		    break;
	case 2: Note.uppercaseText.setText("F#0/Gb0", dontSendNotification);
		break;
	case 3: Note.uppercaseText.setText("G0", dontSendNotification);
		break;
	case 4: Note.uppercaseText.setText("G#0/Ab0", dontSendNotification);
		break;
	case 5: Note.uppercaseText.setText("A0", dontSendNotification);
		break;
	case 6: Note.uppercaseText.setText("A#0/Bb0", dontSendNotification);
		break;
	case 7: Note.uppercaseText.setText("B0", dontSendNotification);
		break;	
	case 8: Note.uppercaseText.setText("C1", dontSendNotification);
		break;
	case 9: Note.uppercaseText.setText("C#1/Db1", dontSendNotification);
		break;
	case 10: Note.uppercaseText.setText("D1", dontSendNotification);
		break;
	case 11: Note.uppercaseText.setText("D#1/Eb1", dontSendNotification);
		break;
	case 12: Note.uppercaseText.setText("E1", dontSendNotification);
		break;
	case 13: Note.uppercaseText.setText("F1", dontSendNotification);
		break;
	case 14: Note.uppercaseText.setText("F#1/Gb1", dontSendNotification);
		break;
	case 15: Note.uppercaseText.setText("G1", dontSendNotification);
		break;
	case 16: Note.uppercaseText.setText("G#1/Ab1", dontSendNotification);
		break;
	case 17: Note.uppercaseText.setText("A1", dontSendNotification);
		break;
	case 18: Note.uppercaseText.setText("A#1/Bb1", dontSendNotification);
		break;
	case 19: Note.uppercaseText.setText("B1", dontSendNotification);
		break;
	case 20: Note.uppercaseText.setText("C2", dontSendNotification);
		break;	
	case 21: Note.uppercaseText.setText("C#2/Db2", dontSendNotification);
		break;
		case 22: Note.uppercaseText.setText("D2", dontSendNotification);
			break;
		case 23: Note.uppercaseText.setText("D#2/Eb2", dontSendNotification);
			break;
		case 24: Note.uppercaseText.setText("E2", dontSendNotification);
			break;
		case 25: Note.uppercaseText.setText("F2", dontSendNotification);
			break;
		case 26: Note.uppercaseText.setText("F#2/Gb2", dontSendNotification);
			break;
		case 27: Note.uppercaseText.setText("G2", dontSendNotification);
			break;
		case 28: Note.uppercaseText.setText("G#2/Ab2", dontSendNotification);
			break;
		case 29: Note.uppercaseText.setText("A2", dontSendNotification);
			break;
		case 30: Note.uppercaseText.setText("A#2/Bb2", dontSendNotification);
			break;
		case 31: Note.uppercaseText.setText("B2", dontSendNotification);
			break;
		case 32: Note.uppercaseText.setText("C3", dontSendNotification);
			break;
		case 33: Note.uppercaseText.setText("C#3/Db3", dontSendNotification);
			break;
		case 34: Note.uppercaseText.setText("D3", dontSendNotification);
			break;
		case 35: Note.uppercaseText.setText("D#3/Eb3", dontSendNotification);
			break;
		case 36: Note.uppercaseText.setText("E3", dontSendNotification);
			break;
		case 37: Note.uppercaseText.setText("F3", dontSendNotification);
			break;
		case 38: Note.uppercaseText.setText("F#3/Gb3", dontSendNotification);
			break;
		case 39: Note.uppercaseText.setText("G3", dontSendNotification);
			break;
		case 40: Note.uppercaseText.setText("G#3/Ab3", dontSendNotification);
			break;
		case 41: Note.uppercaseText.setText("A3", dontSendNotification);
			break;
		case 42: Note.uppercaseText.setText("A#3/Bb3", dontSendNotification);
			break;
		case 43: Note.uppercaseText.setText("B3", dontSendNotification);
			break;
		case 44: Note.uppercaseText.setText("C4", dontSendNotification);
			break;
		case 45: Note.uppercaseText.setText("C#4/Db4", dontSendNotification);
			break;
		case 46: Note.uppercaseText.setText("D4", dontSendNotification);
			break;
		case 47: Note.uppercaseText.setText("D#4/Eb4", dontSendNotification);
			break;
		case 48: Note.uppercaseText.setText("E4", dontSendNotification);
			break;
		case 49: Note.uppercaseText.setText("F4", dontSendNotification);
			break;
		case 50: Note.uppercaseText.setText("F#4/Gb4", dontSendNotification);
			break;
		case 51: Note.uppercaseText.setText("G4", dontSendNotification);
			break;
		case 52: Note.uppercaseText.setText("G#4/Ab4", dontSendNotification);
			break;
		case 53: Note.uppercaseText.setText("A4", dontSendNotification);
			break;
		case 54: Note.uppercaseText.setText("A#4/Bb4", dontSendNotification);
			break;
		case 55: Note.uppercaseText.setText("B4", dontSendNotification);
			break;
		case 56: Note.uppercaseText.setText("C5", dontSendNotification);
			break;
		case 57: Note.uppercaseText.setText("C#5/Db5", dontSendNotification);
			break;
		case 58: Note.uppercaseText.setText("D5", dontSendNotification);
			break;
		case 59: Note.uppercaseText.setText("D#5/Eb5", dontSendNotification);
			break;
		case 60: Note.uppercaseText.setText("E5", dontSendNotification);
			break;
		case 61: Note.uppercaseText.setText("F5", dontSendNotification);
			break;
		case 62: Note.uppercaseText.setText("F#5/Gb5", dontSendNotification);
			break;
		case 63: Note.uppercaseText.setText("G5", dontSendNotification);
			break;
		case 64: Note.uppercaseText.setText("G#5/Ab5", dontSendNotification);
			break;
		case 65: Note.uppercaseText.setText("A5", dontSendNotification);
			break;
		case 66: Note.uppercaseText.setText("A#5/Bb5", dontSendNotification);
			break;
		case 67: Note.uppercaseText.setText("B5", dontSendNotification);
			break;
		case 68: Note.uppercaseText.setText("C6", dontSendNotification);
			break;
		case 69: Note.uppercaseText.setText("C#6/Db6", dontSendNotification);
			break;
		case 70: Note.uppercaseText.setText("D6", dontSendNotification);
			break;
		case 71: Note.uppercaseText.setText("D#6/Eb6", dontSendNotification);
			break;
		case 72: Note.uppercaseText.setText("E6", dontSendNotification);
			break;
		case 73: Note.uppercaseText.setText("F6", dontSendNotification);
			break;
		case 74: Note.uppercaseText.setText("F#6/Gb6", dontSendNotification);
			break;
		case 75: Note.uppercaseText.setText("G6", dontSendNotification);
			break;
		case 76: Note.uppercaseText.setText("G#6/Ab6", dontSendNotification);
			break;
		case 77: Note.uppercaseText.setText("A6", dontSendNotification);
			break;
		case 78: Note.uppercaseText.setText("A#6/Bb6", dontSendNotification);
			break;
		case 79: Note.uppercaseText.setText("B6", dontSendNotification);
			break;
		case 80: Note.uppercaseText.setText("C7", dontSendNotification);
			break;
		case 81: Note.uppercaseText.setText("C#7/Db7", dontSendNotification);
			break;
		case 82: Note.uppercaseText.setText("D7", dontSendNotification);
			break;
		case 83: Note.uppercaseText.setText("D#7/Eb7", dontSendNotification);
			break;
		case 84: Note.uppercaseText.setText("E7", dontSendNotification);
			break;
		case 85: Note.uppercaseText.setText("F7", dontSendNotification);
			break;
		case 86: Note.uppercaseText.setText("F#7/Gb7", dontSendNotification);
			break;
		case 87: Note.uppercaseText.setText("G7", dontSendNotification);
			break;
		case 88: Note.uppercaseText.setText("G#7/Ab7", dontSendNotification);
			break;
		case 89: Note.uppercaseText.setText("A7", dontSendNotification);
			break;
		case 90: Note.uppercaseText.setText("A#7/Bb7", dontSendNotification);
			break;
		case 91: Note.uppercaseText.setText("B7", dontSendNotification);
			break;
		case 92: Note.uppercaseText.setText("C8", dontSendNotification);
			break;
		case 93: Note.uppercaseText.setText("C#8/Db8", dontSendNotification);
			break;
		case 94: Note.uppercaseText.setText("D8", dontSendNotification);
			break;
		case 95: Note.uppercaseText.setText("D#8/Eb8", dontSendNotification);
			break;
		case 96: Note.uppercaseText.setText("E8", dontSendNotification);
			break;
		case 97: Note.uppercaseText.setText("F8", dontSendNotification);
			break;
		case 98: Note.uppercaseText.setText("F#8/Gb8", dontSendNotification);
			break;
		case 99: Note.uppercaseText.setText("G8", dontSendNotification);
			break;
		case 100: Note.uppercaseText.setText("G#8/Ab8", dontSendNotification);
			break;
		case 101: Note.uppercaseText.setText("A8", dontSendNotification);
			break;
		case 102: Note.uppercaseText.setText("A#8/Bb8", dontSendNotification);
			break;
		case 103: Note.uppercaseText.setText("B8", dontSendNotification);
			break;
		case 104: Note.uppercaseText.setText("C9", dontSendNotification);
			break;
		case 105: Note.uppercaseText.setText("C#9/Db9", dontSendNotification);
			break;
		case 106: Note.uppercaseText.setText("D9", dontSendNotification);
			break;
		case 107: Note.uppercaseText.setText("D#9/Eb9", dontSendNotification);
			break;
		case 108: Note.uppercaseText.setText("E9", dontSendNotification);
			break;
		case 109: Note.uppercaseText.setText("F9", dontSendNotification);
			break;
		case 110: Note.uppercaseText.setText("F#9/Gb9", dontSendNotification);
			break;
		case 111: Note.uppercaseText.setText("G9", dontSendNotification);
			break;
		case 112: Note.uppercaseText.setText("G#9/Ab9", dontSendNotification);
			break;
		case 113: Note.uppercaseText.setText("A9", dontSendNotification);
			break;
		case 114: Note.uppercaseText.setText("A#9/Bb9", dontSendNotification);
			break;
		case 115: Note.uppercaseText.setText("B9", dontSendNotification);
			break;
		case 116: Note.uppercaseText.setText("C10", dontSendNotification);
			break;
		case 117: Note.uppercaseText.setText("C#10/Db10", dontSendNotification);
			break;
		case 118: Note.uppercaseText.setText("D10", dontSendNotification);
			break;
		case 119: Note.uppercaseText.setText("D#10/Eb10", dontSendNotification);
			break;
		case 120: Note.uppercaseText.setText("E10", dontSendNotification);
			break;
		default: Note.uppercaseText.setText("Play a key", dontSendNotification);
	}


//	if (maxnum>51)
//{
//	//Note.uppercaseText.setText((String)a, dontSendNotification);
//	Note.uppercaseText.setText("aa", dontSendNotification);
//	//g.drawText("cc", getLocalBounds(), Justification::centred, true);
//}
//else
//{
//	Note.uppercaseText.setText("bb", dontSendNotification);
//	//g.drawText("bb", getLocalBounds(), Justification::centred, true);
//}
	Note.repaint();
	fJuceGUI.repaint();
}

// Globals
std::list<GUI*> GUI::fGuiList;
ztimedmap GUI::gTimedZoneMap;

#endif
